############################################################
# NAME :          procs.tcl
#
# SUMMARY :       file containing many utility procedures
#
# REQUIRED :      yes
# 
# USAGE :         source procs.tcl
#
# ARGUMENTS :     None
#
# VARIABLES :     INTEL_DESIGN_NAME, INTEL_GROUND_NAME, INTEL_POWER_NET, INTEL_MW_LIB, INTEL_UPF_POWER_NETS, INTEL_SCRIPTS_SEARCH_PATH, INTEL_SOURCE_OPTIONS, INTEL_GDS_OUT_LAYER_MAP, INTEL_INSERT_SCAN, INSERT_SCAN_REPLACE_FLOPS, INTEL_UPF 
#
# PROCS USED :    None
#                         
# DESCRIPTION :   The file contains sets of procedures used throughout the adf flow
#
# EXAMPLES :      
#
#############################################################
##############################################################################
# This file sets up procedures used by the synthesis, APR & STA flows        #
# This file is sectioned according to steps and tcl files which use them     #
##############################################################################

##########################################
# Common Procedures - Used by DC/ICC/STA
##########################################
# P_source_if_exists: Used by all flows to source scripts from a provided INTEL_SCRIPTS_SEARCH_PATH
# P_rdtConvertSeconds: Used by P_source_if_exists to convert time in a specific reporting format
# P_get_scr_proc_name: Used by all flows to provide additional stack info when erroring out
# P_msg_info: Used by all flows to provide info messages
# P_msg_warn: Used by all flows to provide warning messages
# P_msg_error: Used by all flows to provide error messages
# P_msg_fatal: Used by all flows to provide fatal error messages
# P_find_common_collection: Utility which can be used to find overlap/common elements between two collections

#################################################
# Synthesis Procedures - Used by Synthesis flow
#################################################
# P_smash_design: Used by the synthesis flow  for smashing hierarchies
# P_smash_design_recursive: Used by P_smash_design for smashing design to the lowest hierarchy
# P_remove_donttouch_on_hier_cells: Used by P_smash_design for removing dont_touch on hierachical instances.

#######################################################
# Floorplan Procedures - Used by floorplan step of APR
#######################################################
# P_add_bonuscore_core2h_rows: Used by init_floorplan.tcl to create site rows for different core tiles
# P_get_techfile_info: Used by P_add_bonuscore_core2h_rows and stdcell PG hookup to get techfile related
# P_set_repeating_custom_tracks: Used by set_wiretracks.tcl to create custom tracks based on track settings
# P_check_boundary_contact: Used by halo.tcl to determine if the Core Boundary contacts with any cell
# P_get_abut_chain: Used by halo.tcl to get list of macros abutting each other
# P_get_abutted_cells: Used by halo.tcl to get macro ells which are abutting
# P_get_abut_macro_chain: Used by integration_checks.tcl to get list of macros abutting each other
# P_get_abutted_macro_cells: Used by integration_checks.tcl to get macro ells which are abutting
# P_get_boundary_polygon: Used by halo.tcl to calculate boundary polygon for halo insertion
# P_lcount: Used by halo.tcl to get repeated element
# P_place_halo: Used by halo.tcl to place a halo at a particular location
# P_find_direction: Used by halo.tcl and halo_power_voltage_island.tcl to place correct ver/horiz halo cells according to direction
# P_ret_intersect_list: Used by halo_power_voltage_island.tcl to get voltage areas abutting with boundary/macro/non-va-halo
# P_check_exclusion: Used by halo_power_voltage_island.tcl to get intersection points of boundary/macro/non-va-halo
# P_macro_route_guide_cmd: Used by create_power_straps.tcl to create correct PG pullback from macro boundaries
# P_strap_cmd: Used by create_power_strpas.tcl to create power straps
# P_gather_track_data: Used in create_power_straps.tcl, and check_floorplan.tcl for building track width tbl
# P_query_track_width: Uses dictionary generated by P_gather_track_data to return width of layer on specfied coords
# P_get_layer_dir: Returns direction of layer
# P_check_partition_dimension: Used by check_floorplan.tcl to check if the partition dimensions are a multiple of the modular grid
# P_adv_polygon_size: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
# P_adv_polygon_check: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
# P_adv_polygon_logic: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
# P_create_diffcheck_grid: Used by create_check_grid.tcl to create diffcheckgrid over the partition
# P_create_polycheck_grid: Used by create_check_grid.tcl to create polycheckgrid over the partition
# P_placement_blockage_move_or_unmove: Used by pre_place_fiducial.tcl and add_filler_cells.tcl to move placement blockages
# P_insert_pre_place_cells_blockage: Used by pre_place_fib_bonus.tcl to insert placement blockages at pre_place cells location or reverse locations
# P_compare: Used by P_insert_pre_place_cells_blockage to do list comparison of blockages
# P_adv_polygon_get: Used by P_insert_pre_place_cells_blockage to do polygon computations
# P_check_macro_notch_min_width: Used by integration_checks.tcl to catch invalid macro placement
# P_create_upf_macro_pg_route_guide: Used in UPF flows to create route guides around macros for proper pullback
# P_remove_upf_macro_pg_route_guide: Used in UPF flows to remove route guides created by P_create_upf_macro_pg_route_guide
# P_abstract_to_design: Used to change view from abstract to design
# P_abstract_to_frame: Used to change view from abstract to frame
# P_frame_to_abstract: Used to change view from frame to abstract 

################################################################
# Place-UPF Procedures - Used by UPF flow in Place step of APR
################################################################
# P_parse_pwrgrid_params: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stages
# P_ret_aon_net: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stage
# P_check_sec_pg_overlap: Used by P_add_sec_pg_hookup defined within upf_sec_pg_hookup.tcl to determine if a secondary PG staple overlaps with another staple.

###########################################################
# CTS-UPF Procedures - Used by UPF flow in CTS step of APR
###########################################################
# P_query_voltage_pgnet: Used by stdcell PG hookup procedure to find out primary pg net for each voltage area

################################################
# Route Procedures - Used by route step of APR
################################################
# P_bonus_array_blockage: Used by add_filler_cells.tcl to create blockages for bonus array addition before decap insertion

########################################################
# Focal opt Procedures - Used by Focal opt step of APR
########################################################
# P_fix_min_cap args: Used by focal_opt.tcl for fixing min-cap violations on design

########################################################
# Fill Procedures - Used by Fill step of APR
########################################################
# P_create_viazone_layer: Used by metal_via_fill.tcl to create viazone layer
# P_create_fill_kor: Used to create fill kor 
# P_create_fill_nlib: Used to create fill nlib and generate fill outputs for run.tcl
# P_create_fill_label: Used to create fill block and generate fill outputs for run_ref flow

##################
# STA Procedures
##################
# P_report_xtalk_deltas: Used by STA flow to report xtalk delta delays
# P_restore_dmsa_session: Used by DMSA flows of STA to restore dmsa sessions
# P_report_qor: Used by STA flow to report QoR data in a format similar to DC/ICC

#################################
# Reports and Outputs Procedures
#################################
# P_create_xyv_icc: Used by P_outputs_xyv procedure to dump out xyv file fo use by RV tools
# P_report_related_supply_net: Used by P_reports to get related supply nets for generate reportsin UPF flow
# P_reports: Used by Syn, APR & STA flows to generate design reports controlled by INTEL_REPORTS variable
# P_get_logic_levels: Used by P_reports procedure to get logic levels during reporting
# P_create_pg_terminals: Used by P_outputs_fram
# P_outputs_linkname: Used by P_outputs_* procedures to get file name used to create link
# P_outputs_verilog: Used by P_outputs to write a verilog output
# P_outputs_verilog_pg: Used by P_outputs to write a verilog output with PG pin and physical-only cells
# P_outputs_upf: Used by P_outputs to write a upf file
# P_outputs_spef: Used by P_outputs to write output spef file
# P_outputs_def: Used by P_outputs to write output def file
# P_syn_output_def: Used by synthesis to write output def file
# P_outputs_fp: Used by P_outputs to write floorplan outputs
# P_outputs_sdc: Used by P_outputs to write sdc output
# P_outputs_saif: Used by P_outputs to write saif output
# P_outputs_scandef: Used by P_outputs at the end of syn flow to write scandef output
# P_outputs_oas: Used by P_outputs to write oas output
# P_outputs_gds: Used by P_outputs to write gds output
# P_outputs_fram: Used by P_outputs to write fram output
# P_outputs_abstract: Used by P_outputs to create abstract view of the design
# P_outputs_lteloc: Used by P_outputs to create an output xyv file used for RV flow
# P_outputs: Main Output procedure used by Synthesis and APR flow to write out outputs. It is controlled by INTEL_OUTPUTS variable
# P_check_place_overlap: Used by Check_* scripts in APR for checking cell overlaps
# P_check_cells: Used by Check_* scripts in APR for checking if dont use cells are used in design
# P_check_power_ground_nets: Used by check_route.tcl to verify shorts/opens/floating metals in design

set start_time [clock seconds]
puts "==>SOURCING: [info script] START TIME: [date]"

## -----------------------------------------------------------------------------
## These procedures/variables are not uniformly available
## for all tools used in the flow. This section of code creates
## the procedures/variables if they are not available.
## -----------------------------------------------------------------------------

if { ![info exists synopsys_root] } {
  set synopsys_root "synopsys_root"
}

if { ![info exists synopsys_program_name] } {
  set synopsys_program_name "tcl"
}

if { $synopsys_program_name == "tcl" } {
  set sh_product_version [info patchlevel]
}

if { [info command date] != "date" } {
  proc date {} {
    return [clock format [clock seconds] -format {%a %b %e %H:%M:%S %Y}]
  }
}

########################
# Common Procedures
########################

################################################################################
# Procedure   : P_source_if_exists
# Description : This sources the specified script.  It searches through directories
#               in the following order:
#                Local script
#                ==> Project flow path flow specific (syn, apr, ..) script
#                ==> Project flow path common script
#                ==> Flow default flow specific (syn, apr, ..) script
#                ==> Flow default common script
#               When it finds the specified script in one of the above directoreis,
#               it sources the script, and stops searching for the script in the
#               next directory.
#               If "-inclusive" option is specified, it sources the script inclusively
#               in the following order:
#                Flow default common script
#                ==> Flow default flow specific (syn, apr, ..) script
#                ==> Project flow path common script
#                ==> Project flow path flow specific (syn, apr, ..) script
#                ==> Local script
#               If the specified script does not exists, it prints out a warning
#               message.


proc P_source_if_exists {args} {
  global INTEL_SCRIPTS_SEARCH_PATH
  global INTEL_SOURCE_OPTIONS

  #parse_proc_arguments -args $args flag

  foreach arg $args {
    if {$arg == "-require"} {
      set require 1
    } elseif {$arg == "-inclusive"} {
      set inclusive 1
    } elseif {$arg == "-display"} {
      set display 1
    } else {
      set filename $arg
    }
  }
  if {![info exists require]} {set require 0}
  if {![info exists inclusive]} {set inclusive 0}
  if {![info exists display]} {set display 0}
  #  set filename $flag(filename)
  #  if { [info exists flag(-require) ] } {
  #    set require 1
  #  } else {
  #    set require 0
  #  }
  #  if {[info exists flag(-inclusive)]} {
  #    set inclusive 1
  #  } else {
  #    set inclusive 0
  #  }

  set prereq_list {}
  # Look for the file in the search_path, if file not yet determined
  if {[info exists INTEL_SCRIPTS_SEARCH_PATH]} {
    foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
      set prereq [file join $search_dir $filename]
      if {[file exists $prereq]} {
        set prereq_list [linsert $prereq_list 0 $prereq]
        if {! $inclusive} {
          break ;# Found the file, so stop looking
        }
      }
    }
  }

  if {$display} {
    foreach prereq $prereq_list {
      puts $prereq
    }
    return
  }

  if {[llength $prereq_list] == 0} {
    if { $require == 1 } {
      P_msg_error "Required file not found: $filename."
    } else {
      puts "==>WARNING: File $filename does not exist."
      return 0
    }
  }

  foreach prereq $prereq_list {
  # Now that the prereq has been determined, source it.
    set start_time [clock seconds]
    set cpu_start [cputime]
    set dates [exec date]
    puts "==>INFORMATION: P_source_if_exists: Sourcing $prereq : START $dates"
    # Source the file in the global scope
    if {[info exists INTEL_SOURCE_OPTIONS] && $INTEL_SOURCE_OPTIONS != ""} {
      set catch_return [catch {uplevel \#0 eval source $INTEL_SOURCE_OPTIONS $prereq} catch_result]
    } else {
      set catch_return [catch {uplevel \#0 source $prereq} catch_result]
    }
    # Check to see if an error occurred in the script
    if {$catch_return != 0} {
      puts "Error: Problem with sourced file \"$prereq\". See errorInfo below"
      error $catch_result
    }
    set end_time [clock seconds]
    set cpu_end [cputime]
    set dates [exec date]
    regexp {.*\/(\S+)} $prereq t localFile
    #    set elapsed_time [format "%6.4f" [expr ($end_time - $start_time) / 60.0 / 60.0]]
    set elapsed_time [P_rdtConvertSeconds [expr ($end_time - $start_time)]]
    set elapsed_cpu [P_rdtConvertSeconds [expr ($cpu_end - $cpu_start)]]
    puts "==>INFORMATION: P_source_if_exists: $localFile : END $dates : WALLCLOCK RUNTIME in (hh:mm:ss) : $elapsed_time hrs : CPU RUNTIME in (hh:mm:ss) : $elapsed_cpu hrs : MEMORY : [mem] KB"
  }
  return 1
}

if {[info exists synopsys_program_name]} {
  define_proc_attributes P_source_if_exists \
    -info "source script, if it exists" \
    -define_args { \
                   {filename "file name to be sourced" filename string required} \
                   {-require "require file" "" boolean optional} \
                   {-display "Shows which file will be sourced without sourcing it" "" boolean optional} \
                   {-inclusive "Source all files found in all paths in the order of priority. Default is to source only the first found file" "" boolean optional} \
  }
}

################################################################################
# Procedure   : P_rdtConvertSeconds #{{{
# Description : This is a time conversion utility

proc P_rdtConvertSeconds {secs} {

  set h [expr {$secs/3600}]
  incr secs [expr {$h*-3600}]
  set m [expr {$secs/60}]
  set s [expr {$secs%60}]
  format "%02.2d:%02.2d:%02.2d" $h $m $s
}

################################################################################
# Procedure   : P_get_scr_proc_name #{{{
# Description : This gets the name of procedures, and returns names of all procedures
#               on the stack.

proc P_get_scr_proc_name { args } {

  set all [string match "*-all*" $args]

  # Start with the current script
  set proc_list "[file tail [info script]]"

  set start 1
  set end [info level]

  # Special cases
  if {$end == 1} {
  # Called from script?
    if {$proc_list != ""} {
      return "$proc_list"

      # Interactive call
    } else {
      return "<interactive>"
    }
  } elseif {$end >= 2} {
  # Don't consider the last procedure (which is P_get_scr_proc_name)
    incr end -1
  }

  for {set i $start} {$i <= $end} {incr i} {
    set proc_name [lindex [info level $i] 0]
    lappend proc_list $proc_name
  }

  # Return all if all was specified
  set len_proc_list [llength $proc_list]
  if {!$all && $len_proc_list > 2} {
  # Get the name of the last two procedures
  # or script & procedure
  # or script only
  # or procedure only

    set proc_list [lrange $proc_list [expr {$len_proc_list - 2}] end]
  }

  # Return values joined by ":" to make it one string
  return [join $proc_list ":"]

}; # P_get_scr_proc_name

if {[info exists synopsys_program_name]} {
  create_command_group {flow_procs}
}


if {[info exists synopsys_program_name]} {
  define_proc_attributes P_get_scr_proc_name \
    -command_group "flow_procs" \
    -info "Procedure to get caller and callee script and procedure names \n\t\t\tdefined in script: [info script]\n" \
    -define_args {
      {-all "name of all the procedures on the stack is returned" "" boolean optional}
  }
}
#}}}


################################################################################
# Procedure   : P_msg_info #{{{
# Description : This prints information messages.

proc P_msg_info { args } {
  set prefix "#INFO-MSG==> "
  puts "$prefix [join [concat $args] { }]"
}

if {[info exists synopsys_program_name]} {
  define_proc_attributes P_msg_info \
    -command_group "flow_procs" \
    -info "Procedure to print info messages \n\t\t\tdefined in script: [info script]\n" \
    -define_args {
      {args "info message" message string required}
  }
}
#}}}


################################################################################
# Procedure   : P_msg_warn #{{{
# Description : This prints warning messages.

proc P_msg_warn { args } {
  set prefix "#WARNING-MSG==> "
  puts "$prefix [join [concat $args] { }]"
}

if {[info exists synopsys_program_name]} {
  define_proc_attributes P_msg_warn \
    -command_group "flow_procs" \
    -info "Procedure to print warning messages \n\t\t\tdefined in script: [info script]\n" \
    -define_args {
      {args "warning message" message string required}
  }
}
#}}}


################################################################################
# Procedure   : P_msg_error #{{{
# Description : This prints error messages.  The flow goes through, and does not stop.

proc P_msg_error { args } {
  set prefix "#ERROR-MSG==> "
  puts "$prefix [join [concat $args] { }]"
}

if {[info exists synopsys_program_name]} {
  define_proc_attributes P_msg_error \
    -command_group "flow_procs" \
    -info "Procedure to print error messages \n\t\t\tdefined in script: [info script]\n" \
    -define_args {
      {args "error message" message string required}
  }
}
#}}}


################################################################################
# Procedure   : P_msg_fatal #{{{
# Description : This prints messages about fatal errors, and exits from the shell.

proc P_msg_fatal { args } {
  set prefix "\n#INFO-STACK==> [uplevel 1 {P_get_scr_proc_name -all}] \n#FATALERROR-MSG==> "
  puts stderr "$prefix [join [concat $args] { }]"
  exit 1
}

if {[info exists synopsys_program_name]} {
  define_proc_attributes P_msg_fatal \
    -command_group "flow_procs" \
    -info "Procedure to print fatal messages and exit the tool \n\t\t\tdefined in script: [info script]\n" \
    -define_args {
      {target "file to create before exiting" target.db string required}
      {args "fatal message" message string required}
  }
}
#}}}

proc P_find_common_collection {a b} {
  set in_a_but_notin_b [remove_from_collection $a $b]
  set in_b_but_notin_a [remove_from_collection $b $a]
  set common_a_b [remove_from_collection $a $in_a_but_notin_b]
  if { [sizeof_collection $b] == 0 } {
    return $a
  } else {
    return $common_a_b
  }
}

define_proc_attributes P_find_common_collection \
  -info "Returns common elements between 2 collections" \
  -define_args {
    {a "First Coll" "First Coll" string required}
    {b "Second Coll" "Second Coll" string required}
}

########################
# Synthesis Procedures
########################

##############################################################################
# Procedure   : P_smash_design
# Description : This proc smashes the design but presevers the hierarchies listed in the argument.
#               It also takes the numbers of level below which the smashing has to happen.
#   If 2 is given, the it descends to 2 levels of hierarchy below the top and smashes thoses levels.
#               But regardless of levels specified, the list specified in \$preserve_hier_instance_list will be honored.
#   If levels is less than 0, then no smashing is done

proc P_smash_design {{preserve_hier_instance_list {}} {levels 0}} {
  if {$levels < 0} {return 0}
  global smashed_designs_hash
  set start_time [clock seconds]
  set cur_design [get_attribute [current_design] name]
  set hiers_level_list {}
  foreach preserve_hier_instance $preserve_hier_instance_list {
    if {[get_attribute [get_cells $preserve_hier_instance] is_hierarchical] == "true"} {
      set hiers [split $preserve_hier_instance "/"]
      set mid_index [expr [llength $hiers] - 2]
      set end_index [expr [llength $hiers] - 1]
      set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
      set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
      while {([get_cells -quiet $parent_hier] == "") && ($mid_index >= 0)} {
        incr mid_index -1
        set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
        set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
      }
      if {$parent_hier == ""} {
        set parent_hier_ref $cur_design
      } else {
        set parent_hier_ref [get_attribute [get_cells $parent_hier] ref_name]
      }
      set hier_hash($preserve_hier_instance) [list $parent_hier_ref $child_inst]
      lappend hiers_level_list [list $preserve_hier_instance [llength $hiers] $parent_hier_ref $child_inst]
    }
  }
  current_design $cur_design
  foreach hiers_level_pair [lsort -decreasing -index 1 $hiers_level_list] {
    set parent_hier_ref [lindex $hiers_level_pair 2]
    set child_inst [lindex $hiers_level_pair 3]
    set preserve_hier_instance [lindex $hiers_level_pair 0]
    set child_hier_level [lindex $hiers_level_pair 1]
    if {$child_hier_level > $levels} {
      set preserve_hier_ref [get_attribute [get_cells $preserve_hier_instance] ref_name]
      current_design $preserve_hier_ref
      set smashed_designs_hash($preserve_hier_ref) 1
      ungroup -all -flatten
      current_design $parent_hier_ref
      set_dont_touch $child_inst
      current_design $cur_design
    }
  }
  current_design $cur_design

  P_smash_design_recursive $levels
  P_remove_donttouch_on_hier_cells
  array unset smashed_designs_hash
  set end_time [clock seconds]
  set elapsed_time [expr ($end_time - $start_time) / 60.0 / 60.0]
  #echo "Runtime to smash the design = $elapsed_time hrs"
}

#################################################################
# Procedure   : P_smash_design_recursive
# Description : This proc starts at the current design and descends into the lowest hierarchy and smashes from that level upwards.
#   This proc is called from proc:P_smash_design

proc P_smash_design_recursive {levels} {
  global smashed_designs_hash
  set cur_design [current_design]
  set cur_design_name [get_attribute $cur_design name]
  if {[info exists smashed_designs_hash($cur_design_name)]} {
    return 0
  }
  if {$levels <= 0} {
    ungroup -all -flatten
    set smashed_designs_hash($cur_design_name) 1
  } else {
    set ref_designs {}
    set insts_col [get_cells -filter is_hierarchical==true]
    set insts_count [sizeof_collection $insts_col]
    foreach_in_collection inst_col $insts_col {
      lappend ref_designs [get_attribute $inst_col ref_name]
    }
    foreach ref_design $ref_designs {
      if {![info exists smashed_designs_hash($ref_design)]} {
        current_design $ref_design
        P_smash_design_recursive [expr $levels - 1]
      }
    }
    current_design $cur_design
  }
}

##################################################################
# Procedure   : P_remove_donttouch_on_hier_cells
# Description : This proc recursively traverses the hierarchies in the design.
#   If a hiararchical instance as a dont touch on it remove that dont touch attribute

proc P_remove_donttouch_on_hier_cells {} {
  set cur_design [current_design]
  set ref_designs {}
  set insts_col [get_cells -filter is_hierarchical==true]
  foreach_in_collection inst_col $insts_col {
    lappend ref_designs [get_attribute $inst_col ref_name]
    remove_attribute $inst_col dont_touch -quiet
  }
  foreach ref_design $ref_designs {
    current_design $ref_design
    P_remove_donttouch_on_hier_cells
  }
  current_design $cur_design
}

########################
# Floorplan Procedures
########################

#-------------------------------------------------------------------
# __start
# __author: jeheidem
# __proc:  P_add_bonuscore_core2h_rows
# __description:  add bonuscore & core2h site_rows to an existing FP
# __proc returns: 0 = successful
#                 1 = error
# __required_args:  -unit_tile    = name of base unit tile
# __optional_args:  -bonus_tile   = name of bonus tile
#                   -unit_2h_tile = name of double height tile
# __end
#-------------------------------------------------------------------
#
proc P_add_bonuscore_core2h_rows { args } {
  parse_proc_arguments -args $args flag
  set func_name [lindex [info level [info level]] 0]

  # set up error outputs
  set puts "puts"
  set puts_nnl "puts -nonewline"
  set info_stack "\n#INFO-STACK==> $func_name"
  set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
  set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
  if { [llength [info commands da_error]] > 0 } { set da_error da_error
  } else { set da_error [eval $fmte ERROR] }
  if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
  } else { set da_warn [eval $fmt WARNING] }
  if { [llength [info commands da_info]] > 0 } { set da_info da_info
  } else { set da_info [eval $fmt INFO] }

  ###########################################################################
  # procedure P_add_bonuscore_core2h_rows
  # the function assumes that only single tile pattern exists in the design
  # assumes that rows alternate between N & S with no gaps in site_rows.
  # bonuscore rows are the same height & orientation as existing core tile
  # core2h rows are the same width as existing core tile, and require N-S pair
  ###########################################################################


  # get techfile info
  set tech_info [P_get_techfile_info]
  if { [llength $tech_info] == 0 } {
    eval $da_error "\"No MW library open or insufficient disk space\""
    return 1
  }
  # look up info for tiles
  set all_tiles {}
  set all_tile_names {}
  foreach tech_item $tech_info {
    if { ! [string equal "Tile" [lindex $tech_item 0]] } {
      continue
    }
    unset -nocomplain tech_tile_name tech_tile_width tech_tile_length
    set tech_tile_name [lindex $tech_item 1]
    foreach sub_item [lrange $tech_item 2 end] {
      if { [string equal -nocase "width" [lindex $sub_item 0]] } {
        set tech_tile_width [lindex $sub_item 1]
      } elseif { [string equal -nocase "height" [lindex $sub_item 0]] } {
        set tech_tile_height [lindex $sub_item 1]
      }
    }
    if { (! [info exists tech_tile_width]) || (! [info exists tech_tile_height]) } {
      continue
    }
    set new_tile [list $tech_tile_name $tech_tile_width $tech_tile_height]
    lappend all_tiles $new_tile
    lappend all_tile_names $tech_tile_name
  }



  # ensure that a design is open and has core_area
  redirect /dev/null {catch {set core_area [get_core_area]}}
  if { (! [info exists core_area]) || ([llength $core_area] == 0) } {
  # no design is open or core_area isn't defined
    eval $da_error "\"No design open or undefined core_area\""
    return 1
  }


  # get min resolution (the round about method for icc)
  redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
  regexp -line {^length.*} $unit_vars length_units
  set resolution [expr 1.0 / ([lindex $length_units 2] + 0.0)]


  # check that each tile specified exists
  set error 0
  set core_step 1.0
  set core2h_width 1.0
  set core2h_height 1.0
  set bonus_width  1.0
  set bonuscore_mult 1
  if { [info exists flag(-unit_tile)] } {
    set tile_number [lsearch -exact $all_tile_names $flag(-unit_tile)]
    if { $tile_number == -1 } {
      set error 1
      eval $da_warn "\"unit_tile '$flag(-unit_tile)' doesn't exist\""
    } else {
      set core_tile $flag(-unit_tile)
      set core_item [lindex $all_tiles $tile_number]
      set tile_width  [lindex $core_item 1]
      set tile_height [lindex $core_item 2]
      set core_step [expr int(round($tile_width / $resolution))]
    }
  }
  if { [info exists flag(-bonus_tile)] } {
    set tile_number [lsearch -exact $all_tile_names $flag(-bonus_tile)]
    if { $tile_number == -1 } {
      set error 1
      eval $da_warn "\"bonus_tile '$flag(-bonus_tile)' doesn't exist\""
    } else {
      set bonuscore_tile $flag(-bonus_tile)
      set bonus_item [lindex $all_tiles $tile_number]
      set bonus_width  [lindex $bonus_item 1]
      set bonuscore_step [expr int(round($bonus_width / $resolution))]
      set bonuscore_mult [expr int(round($bonuscore_step / $core_step))]
    }
  }
  if { [info exists flag(-unit_2h_tile)] } {
    set tile_number [lsearch -exact $all_tile_names $flag(-unit_2h_tile)]
    if { $tile_number == -1 } {
      set error 1
      eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' doesn't exist\""
    } else {
      set core2h_tile $flag(-unit_2h_tile)
      set core2h_item [lindex $all_tiles $tile_number]
      set core2h_width  [lindex $core2h_item 1]
      set core2h_height  [lindex $core2h_item 2]
      set core2h_step [expr int(round($core2h_width / $resolution))]
      set core2h_mult [expr int(round($core2h_step / $core_step))]
      if { (int(round($tile_height/$resolution)) * 2) != int(round($core2h_height/$resolution)) } {
        set error 1
        eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' is not double the height of the unit_tile\""
      }
      set tile_height [lindex $core_item 2]
    }
  }


  # exit if error
  if { $error } {
    eval $da_error "\"Problem specified tiles don't exist\""
    return 1
  }



  # get information on existing site_rows
  # use win_select_objects (rather than get_site_rows)
  # -- this is due to an early bug where get_site_rows didn't get unnamed rows
  if {[P_is_ICC]} {
    set design_bbox [get_attribute -quiet [get_die_area] bbox]
  } else {
    set design_bbox [get_attribute -quiet [current_block] boundary_bbox]
  }
  if { [llength $design_bbox] == 1 } { set design_bbox [lindex $design_bbox 0] }
  set design_bbox [join $design_bbox]
  change_selection -remove [get_selection]
  win_set_select_class {site_row}
  win_set_filter -class site -filter {site_row}
  win_select_objects -within $design_bbox -slct_targets global -slct_targets_operation clear -intersect
  set site_rows [sort_collection [sort_collection [filter_collection [get_selection] "object_class==\"site_row\""] bbox_llx] bbox_lly]
  change_selection $site_rows
  if { [sizeof_collection $site_rows] == 0 } {
    eval $da_warn "\"no site_row in design\""
    return 1
  }

  # record existing site_row information
  set existing_rows {}
  set existing_names {}
  set core2h_N_rows {}
  set core2h_S_rows {}
  set core_sites {}
  set bonuscore_sites {}
  set core2h_sites {}
  unset -nocomplain min_y
  foreach_in_collection site_row $site_rows {
    set site_space  [get_attribute -quiet $site_row site_space]
    set site_count  [get_attribute -quiet $site_row site_count]
    set site_type   [get_attribute -quiet $site_row site_type]
    if { ! [string equal $core_tile $site_type] } { continue }
    set origin      [get_attribute -quiet $site_row origin]
    if { [llength $origin] == 1 } { set origin [lindex $origin 0] }
    foreach { x y } $origin { break }
    if { (! [info exists min_y]) || ($y < $min_y) } {
      set min_y $y
    }
    set orientation [get_attribute -quiet $site_row orientation]
    set direction   [get_attribute -quiet $site_row direction]
    set name        [get_attribute -quiet $site_row name]
    switch -glob $orientation {
      *N { set flip_orient "FS" }
      *S { set flip_orient "N" }
      default { set flip_orient $orientation }
    }
    set add_row [list $site_space $site_count $site_type $origin $orientation $direction $name $flip_orient]
    lappend existing_rows $add_row
    lappend existing_names $name

    # core sites
    lappend core_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation $site_count]

    # bonuscore sites are original core sites with site_count divided by 4
    set x_length [expr $site_count * $tile_width]
    lappend bonuscore_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation [expr int(floor(($x_length/$bonus_width) + $resolution))]]

    #
    # compute rows for core2h
    # use polygon operation, build bbox for each site_row
    #   BUT ... stretch N rows up by tile_height, S rows down by tile_height
    #   core2h site_rows described by the intersection of N & S polygons
    #
    switch -glob $orientation {
      *N { set yll $y
           set yur [expr $y + $tile_height]
           set north 1
      }
      *S { set yll [expr $y - $tile_height]
           set yur $y
           set north 0
      }
      default { set yll 0.0
                set yur 0.0
                set north -1
      }
    }
    set xll $x
    set xur [expr $x + ($site_space * $site_count)]
    set bbox [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
    if { $north == 1 } {
      lappend core2h_N_rows $bbox
    } elseif { $north == 0 } {
      lappend core2h_S_rows $bbox
    }
  }
  if { [llength $core_sites] == 0 } {
    eval $da_error "\"No $core_tile site_rows found in design\""
    return 1
  }
  remove_site_row [get_selection]
  change_selection -remove [get_selection]

  # make a list of core2h sites from the intersection of N & S polygons
  foreach row2h [compute_polygons -boolean and $core2h_N_rows $core2h_S_rows] {
  # get the bounds of each polygon to figure out core2h sites
    set xll [lindex [lindex [lsort -real -index 0 -increasing $row2h] 0] 0]
    set yll [lindex [lindex [lsort -real -index 1 -increasing $row2h] 0] 1]
    set xur [lindex [lindex [lsort -real -index 0 -decreasing $row2h] 0] 0]
    if { int(round(($yll - $min_y)/$core2h_height)) % 2 } {
      set core_orient "N"
    } else {
      set core_orient "FS"
    }
    lappend core2h_sites [list [expr int(round($xll/$resolution))] [expr int(round($yll/$resolution))] $core_orient [expr int(floor((($xur-$xll)/$core2h_width) + $resolution))]]

  }

  # create DEF file
  write_def -rows_tracks_gcells -output core_[pid].def
  set f1 [open core_[pid].def  ]
  redirect -variable file_dump {set tmp [read $f1]}
  close $f1

  set f2 [open core_[pid].def   w]
  regsub -all "ROW STD_ROW_\[\^\n\]*\n" $tmp "" tmpnew1
  regsub -all "DIEAREA " $tmpnew1 "\#DIEAREA" tmpnew2
  regsub -all "END DESIGN.*" $tmpnew2 "" tmpnew
  puts $f2 "[string trimright $tmpnew]\n"
  # add core
  # DEF line looks like;
  #  ROW STD_ROW_1 core 0 2784 N DO 7080 BY 1 STEP 116 0 ;
  if { ! [info exists core_tile] } {
    set core_sites {}
  }
  set i 1
  foreach site_row [lsort -index 0 [lsort -index 1 $core_sites]] {
    foreach { x y orient step }  $site_row { break }
    puts $f2 "ROW STD_ROW_$i $core_tile $x $y $orient DO $step BY 1 STEP $core_step 0 ;"
    incr i
  }
  # add bonuscore
  # DEF line looks like;
  #  ROW STD_ROW_BONUSCORE_1 bonuscore 0 2784 N DO 7080 BY 1 STEP 464 0 ;
  if { ! [info exists bonuscore_tile] } {
    set bonuscore_sites {}
  }
  foreach site_row [lsort -index 0 [lsort -index 1 $bonuscore_sites]] {
    foreach { x y orient step }  $site_row { break }
    puts $f2 "ROW STD_ROW_BONUSCORE_$i $bonuscore_tile $x $y $orient DO $step BY 1 STEP $bonuscore_step 0 ;"
    incr i
  }
  # add core2h (if available)
  # DEF line looks like;
  #  ROW STD_ROW_CORE2H_1 core2h 0 2784 N DO 7080 BY 1 STEP 116 0 ;
  if { ! [info exists core2h_tile] } {
    set core2h_sites {}
  }
  foreach site_row [lsort -index 0 [lsort -index 1 $core2h_sites]] {
    foreach { x y orient step }  $site_row { break }
    puts $f2 "ROW STD_ROW_CORE2H_$i $core2h_tile $x $y $orient DO $step BY 1 STEP $core2h_step 0 ;"
    incr i
  }
  close $f2

  # load def
  read_def core_[pid].def
  file delete -force "core_[pid].def"


  return 0

}

define_proc_attributes P_add_bonuscore_core2h_rows \
  -info "Create site_rows for core2h and bonuscore" \
  -define_args {
    {-unit_tile "name of unit tile" unit_tile string required}
    {-bonus_tile "name of bonus tile" bonus_tile string optional}
    {-unit_2h_tile "name of 2x height tile" unit_2h_tile string optional}
}

#-------------------------------------------------------------------
# __start
# __author: jeheidem
# __proc:  P_get_techfile_info
# __description:  dump & read in contents of techfile for current_mw_lib
#                 ignores comment fields
# __proc returns:  a list of lists of technology information
#                  i.e.
#                  {{Technology {name "name-string"} {date "date-string"}
#                               {dielectric 3.45e-5} ...}
#                   {Color 19 {{name 19} {rgbDefined 1} ...}}
#                   {Stipple patternM1 {{width 8} {height 8}
#                                       {pattern {0 0 0 1 0 0 ...}  ...}}
#                   {Tile unit {{width 0.xx} {height x.xx}}}
#                   {Tile core {{width 0.xx} {height x.xx}}}
#                   {Layer poly {{layerNumber #} {maskName poly} {visible 1} ...}}
#                   {ContactCode via1 {{contactCodeNumber #} {cutLayer via1} ...}}
#                   .....}
# __required_args:  none
# __optional_args:
# __end
#-------------------------------------------------------------------
#
proc P_get_techfile_info {} {
  set func_name [lindex [info level [info level]] 0]

  # set up error outputs
  set puts "puts"
  set puts_nnl "puts -nonewline"
  set info_stack "\n#INFO-STACK==> $func_name"
  set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
  set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
  if { [llength [info commands da_error]] > 0 } { set da_error da_error
  } else { set da_error [eval $fmte ERROR] }
  if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
  } else { set da_warn [eval $fmt WARNING] }
  if { [llength [info commands da_info]] > 0 } { set da_info da_info
  } else { set da_info [eval $fmt INFO] }

  redirect /dev/null {catch {set mw_lib [current_mw_lib]}}
  if { (! [info exists mw_lib]) || ([llength $mw_lib] == 0) } {
  # no library is open
    return {}
  }
  write_mw_lib_files -technology -output tech_[pid].tf [current_mw_lib]

  set tfh [open tech_[pid].tf r]
  set tech_lines {}
  set start_comment -1
  while { ! [eof $tfh] } {
    gets $tfh line
    set new_line ""
    while { [string length $line] > 0 } {
      if { $start_comment >= 0 } {
        set stop_comment [string first "*/" $line $start_comment]
        if { $stop_comment < 0 } {
          set line ""
          set start_comment 0
          break
        } else {
          set line [string range $line [expr $stop_comment + 2] end]
          set start_comment -1
        }
      } else {
        set start_comment [string first "/*" $line]
        if { $start_comment > 0 } {
          append new_line [string range $line 0 [expr $start_comment - 1]]
          set line [string range $line [expr $start_comment + 2] end]
          set start_comment 0
        } elseif { $start_comment < 0 } {
          append new_line $line
          set line ""
        }
      }
      set new_line [string trim $new_line]
      if { [string length $new_line] > 0 } {
        lappend tech_lines $new_line
      }
    }
  }
  close $tfh

  set tech_info {}
  set in_section 0
  set line ""
  # have a techfile with all comments stripped
  foreach read_line $tech_lines {
    append line " $read_line"
    if { ! $in_section } {
      unset -nocomplain field type new_list end
      if { [regexp {^\s*(\S+)\s+"(\S+)"\s+\{\s*(\}?)$} $line all field type end] } {
        set new_list [list $field $type]
      } elseif { [regexp {^\s*(\S+)\s+(\d+)\s+\{\s*(\}?)$} $line all field type end] } {
        set new_list [list $field $type]
      } elseif { [regexp {^\s*(\S+)\s+\{\s*(\}?)$} $line all field end] } {
        set new_list [list $field]
      } else {
        continue
      }
      set in_section 1
    } else {
      if { [regexp {^\s*(\S+)\s*=\s*"([^\"]+)"\s*(\}?)$} $line all item value end] } {
        lappend new_list [list $item $value]
      } elseif { [regexp {^\s*(\S+)\s*=\s*\(([^\)]+)\)\s*(\}?)$} $line all item value_list end] } {
        set value [regsub -all {[\s,]+} [string trim $value_list] { }]
        lappend new_list [list $item $value]
      } elseif { [regexp {^\s*(\S+)\s*=\s*([^\s\(]+)\s*(\}?)$} $line all item value end] } {
        lappend new_list [list $item $value]
      } elseif { ! [regexp {^\s*(\})$} $line all end] } {
        continue
      }
    }
    if { [info exists end] && [string equal "\}" $end] } {
      lappend tech_info $new_list
      set in_section 0
    }
    set line ""

  }

  # remove the temporary techfile
  file delete -force "tech_[pid].tf"

  return $tech_info

}

################################################################################
# Procedure   : P_set_repeating_custom_tracks
# Input(s)    : -track_settings {list}
# Output(s)   : none
# Help line   : sets custom tracks based on track_settings
#                  list that describes track settings
# Description : set preferred directions, preferred
#               and non-preferred routing tracks.
#               The procedure will set tracks across the
#               entire floorplan and allows a either a
#               single repeating track or set of
#               (non-uniform) repeating tracks.
#               Non-preferred tracks can be explicitly set
#               or if not set then are derived from preferred
#               tracks above & below the current layer.
#               Tracks are built to avoid wires
#               that won't be contained in the floorplan area.
#
#               {list} format for -track_settings:
#                  => per layer list specifying:
#                   layer                string(layer_name)
#                   preferred-direction  string(horizontal or vertical)
#                   preferred-tracks     list(offsets,repeat)
#                   non-preferred-tracks list(offsets,repeat)
#                   {offsets} - (list of) number(s)
#                   {repeat}  - number (step value for tracks)
#
# Example(s)  : Suppose you are running script called "check_hier.tcl"
#               set my_tracks {
#                   { { layer metal1 }
#                          { preferred-direction vertical }
#                          { preferred-tracks { offsets 0 }
#                                             { repeat 0.116 } } }
#                      { { layer metal2 }
#                          { preferred-direction horizontal }
#                          { preferred-tracks { offsets { 0.029 0.145 0.464 0.580
#                                                         0.696 0.812 0.928
#                                                         1.247 1.363 1.479 } }
#                                             { repeat  1.566 } } }
#                      { { layer metal3 }
#                          { preferred-direction vertical }
#                          { preferred-tracks { offsets 0.116 }
#                                             { repeat 0.116 } } }
#                      { { layer metal4 }
#                          { preferred-direction horizontal } }
#                   }
#               P_set_repeating_custom_tracks -track_settings $my_tracks
#
# Notes(s)    :
#      1) arguments are given as lists (lists of lists with keyword directives)
#      2) it is not necessary to specify preferred-direction, values set
#             up in the design are used by default
#      3) offsets should be given from the bottom & left
#      4) tracks are only added if the entire metal width fits in the fub
#      5) non-preferred tracks by default will be derived from the
#           preferred tracks of the layers above & below the current layer
#      6) non-preferred tracks can be forced if needed using the
#           non-preferred-tracks directive
#      7) if two different sets of repeats are required for a particular
#           track setup, then they need to be given as 2 separate layer sets
#           i.e. (this example pushes preferred tracks from
#                         metal2 & metal4 to metal3 non-preferred tracks)
#
#               set my_tracks {
#                      { { layer metal3 }
#                          { non-preferred-tracks { offsets
#                                                    { 0.029 0.145 0.464 0.580
#                                                      0.696 0.812 0.928
#                                                      1.247 1.363 1.479 } }
#                                             { repeat  1.566 } } }
#                      { { layer metal3 }
#                          { non-preferred-tracks { offsets 0.087 }
#                                                 { repeat 0.174 } } }
#                   }
#               P_set_repeating_custom_tracks -track_settings $my_tracks
#
# -----------------------------------------------------------------------------
#


proc P_set_repeating_custom_tracks {args } {
  parse_proc_arguments -args $args flag
  set func_name [string range [lindex [info level [info level]] 0] 2 end]

  if { [info exists flag(-track_settings)] } {
    if { $flag(-track_settings) == "help" } {
      puts "need help"
      puts "Usage: $func_name # set custom tracks"
      puts "        -track_settings TrackInfoList"
      puts "   (TrackInfoList of type list)"
      puts "   TrackInfoList format:"
      puts "      {"
      puts "         { {layer LAYER_1}"
      puts "              {preferred-direction HORIZONTAL|VERTICAL}"
      puts "              {preferred-tracks"
      puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
      puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
      puts "              }"
      puts "              {non-preferred-tracks"
      puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
      puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
      puts "              }"
      puts "         }"
      puts "         { {layer LAYER_N}"
      puts "           {preferred-direction HORIZONTAL|VERTICAL}"
      puts "         }"
      puts "      }"
      puts "   - - - - - - - -"
      puts "   (optional) non-preferred-tracks"
      puts "        - if not given, then derived from preferred-tracks above/below"
      puts ""
      return
    }
    set track_settings $flag(-track_settings)
  }

  # set default offset reference to the lowerLeft unless 'origin' is specified
  set reference_origin 0
  if { [info exists flag(-offset_reference)] } {
    if { [string equal "origin" $flag(-offset_reference)] } {
      set reference_origin 1
    }
  }

  # record if tracks can land on the boundary
  set no_sharing_boundary [info exists flag(-no_tracks_on_boundary)]

  # All track settings are done HERE with track_settings

  # get length precision (the round about method for icc)
  redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
  regexp -line {^length.*} $unit_vars length_units
  set lengthPrecision [expr [lindex $length_units 2] + 0.0]
  # hard code length precision - not easily available in tcl
  # set lengthPrecision 1000.0

  # base on bounds of the block to set range of wiretracks
  set bound_llx [expr [get_attribute [current_design] die_area_llx] \
    / $lengthPrecision]
  set bound_lly [expr [get_attribute [current_design] die_area_lly] \
    / $lengthPrecision]
  set bound_urx [expr [get_attribute [current_design] die_area_urx] \
    / $lengthPrecision]
  set bound_ury [expr [get_attribute [current_design] die_area_ury] \
    / $lengthPrecision]

  # find metal routing layers
  set layer_pairs {}
  foreach_in_collection layer [get_layers] {
    set layer_name [get_attribute $layer name]
    if { [string match [get_layer_attribute -layer $layer_name isDefaultLayer] 0] } {
      continue
    }
    if { [string match metal* \
      [get_layer_attribute -layer $layer_name mask_name]] } {
      lappend layer_pairs [list [get_layer_attribute -layer $layer_name mask_name] $layer_name]
    }
  }
  set layer_pairs [lsort -index 0 -dictionary $layer_pairs]
  set layers {}
  foreach item $layer_pairs {
    lappend layers [lindex $item 1]
  }
  unset layer_pairs

  # get existing preferred directions
  set preferred_dir_list {}
  redirect -variable dump_preferred_dir { report_preferred_routing_direction }
  set next_match 0
  if { [regexp -start $next_match -indices -lineanchor \
    "Layer Name  \[^\n]*" \
    $dump_preferred_dir dump_indices] } {
  set new_str [string range $dump_preferred_dir [lindex $dump_indices 0] \
    [lindex $dump_indices 1]]
  set next_match [expr [lindex $dump_indices 1] + 2]
  regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_fields
  # find fields for layer_name & design
  set layer_index [lsearch [string tolower $dump_fields] layer_name]
  set design_index [lsearch [string tolower $dump_fields] design]
  set num_fields [llength $dump_fields]

  # now search for fields
  while { [regexp -start $next_match -indices -lineanchor \
    "\[^\n]*" \
    $dump_preferred_dir dump_indices] } {
  if { $layer_index < 0 || $design_index < 0 } {
  break
  }
  set new_str [string range $dump_preferred_dir \
    [lindex $dump_indices 0] \
    [lindex $dump_indices 1]]
  set next_match [expr [lindex $dump_indices 1] + 2]
  regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_string
  if { [llength $dump_string] < $num_fields } {
  unset dump_string new_str
  break
  }
  set prefer_layer [lindex $dump_string $layer_index]
  set prefer_dir   [string tolower [lindex $dump_string $design_index]]
  lappend preferred_dir_list [list $prefer_layer $prefer_dir]
  unset prefer_layer prefer_dir dump_string new_str
  }
  unset layer_index design_index num_fields
  }
  unset dump_preferred_dir next_match
  set preferred_dir_list [lsort -index 0 -dictionary $preferred_dir_list]


  # begin processing track settings for layer
  set error 0
  set tracks_actually_set {}
  set nprfr_adds {}
  set dir_updates {}
  foreach track_set $track_settings {
    unset -nocomplain layer_name preferred_dir \
      PT NPT unknown_opt comment_field err_type
    foreach item $track_set {
      if { $error } {
        break
      }
      if { [llength $item] < 2 } {
        continue
      }
      set chk_field [string tolower [lindex $item 0]]
      switch -- ${chk_field} {
        layer                { if { [info exists layer_name] } {
          set err_type layer
        } else {
          set layer_name [lindex $item 1]
        }
        }
        preferred-direction  { if { [info exists preferred_dir] } {
          set err_type preferred-direction
        } else {
          set preferred_dir [lindex $item 1]
        }
        }
        non-preferred-tracks { if { [info exists NPT] } {
          set err_type non-preferred-tracks
        } else {
          set NPT [lrange $item 1 end]
        }
        }
        preferred-tracks     { if { [info exists PT] } {
          set err_type preferred-tracks
        } else {
          set PT [lrange $item 1 end]
        }
        }
        comment              { set comment_field 1 }
        default        { set unknown_opt $item }
      }
      if { [info exists err_type] } {
        puts "ERROR - duplicate option for \"$err_type\" in 'track_settings' for \{ $track_set \}"
        set error 1
        break
      }
      if { [info exists comment_field] } {
        unset comment_field
        continue
      }
      if { [info exists unknown_opt] } {
        break
      }
    }
    if { $error } {
      break
    }
    if { [info exists unknown_opt] } {
      puts "WARNING - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $track_set \}"
      continue
    }
    if { ! [info exists layer_name] } {
      puts "ERROR - Required 'layer' option missing in 'track_settings' for \{ $track_set \}"
      set error 1
      break
    }
    if { [lsearch -exact $layers $layer_name] < 0 } {
      puts "ERROR - Unknown 'layer' \"$layer_name\" specified in 'track_settings' for \{ $track_set \}"
      puts "      - layer must be one of: $layers"
      set error 1
      break
    }
    if { [info exists preferred_dir] } {
      switch -- [string tolower ${preferred_dir}] {
        vertical    { set new_dir vertical }
        horizontal  { set new_dir horizontal }
        default     { set unknown_opt $item }
      }
      if { [info exists unknown_opt] } {
        puts "ERROR - bad preferred-direction \"$preferred_dir\" defined for layer \"$layer_name\" "
        set error 1
        break
      }
      if { [info exists ${layer_name}(dir)] && (! [string match $new_dir [expr $${layer_name}(dir)]]) } {
        puts "ERROR - preferred-direction defined as both horizontal & vertical for layer \"$layer_name\" "
        set error 1
        break
      }
      set ${layer_name}(dir) $new_dir
    }

    set track_items {}
    if { [info exists PT] } {
      lappend track_items [list PT $PT]
    }
    if { [info exists NPT] } {
      lappend track_items [list NPT $NPT]
    }
    unset -nocomplain comment_field PT_track_offsets PT_track_repeats NPT_track_offsets NPT_track_repeats
    foreach N_item $track_items {
      set N_dir [string toupper [lindex $N_item 0]]
      foreach item [lindex $N_item 1] {
        set chk_field [string tolower [lindex $item 0]]
        switch -- ${N_dir}_${chk_field} {
        NPT_offsets { if { [info exists NPT_track_offsets] } {
          set err_type "non-preferred-tracks offsets"
          } else {
          set NPT_track_offsets [lindex $item 1]
          }
        }
        NPT_repeat  { if { [info exists NPT_track_repeats ] } {
        set err_type "non-preferred-tracks repeat"
        } else {
        set NPT_track_repeats [lindex $item 1]
        }
        }
        NPT_comment { set comment_field 1 }
        PT_offsets  { if { [info exists PT_track_offsets] } {
        set err_type "preferred-tracks offsets"
        } else {
        set PT_track_offsets [lindex $item 1]
        }
        }
        PT_repeat   { if { [info exists PT_track_repeats ] } {
          set err_type "preferred-tracks repeat"
          } else {
          set PT_track_repeats [lindex $item 1]
          }
        }
        PT_comment  { set comment_field 1 }
        default     { set unknown_opt $item }
        }
        if { [info exists comment_field] } {
          unset comment_field
          continue
        }
        if { [info exists unknown_opt] } {
          break
        }
        if { [info exists err_type] } {
          if { ($N_dir == "PT") } {
            set type "preferred-tracks"
          } else {
           set type "non-preferred-tracks"
          }
          puts "ERROR - duplicate option for \"$err_type\" in $layer_name '${type}' for \{ $item \}"
          set error 1
          break
        }
      }
      if { [info exists unknown_opt] } {
        break
      }
    }
    if { $error } {
      break
    }
    if { [info exists unknown_opt] } {
      if { ($N_dir == "PT") } {
        set type "preferred-tracks"
      } else {
        set type "non-preferred-tracks"
      }
      puts "ERROR - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $layer_name $N_dir \}"
      set error 1
      break
    }
    if { [info exists PT_track_offsets] } {
      foreach t_item $PT_track_offsets {
        if { ! [string is double $t_item] } {
          set error 1
          break
        }
      }
      if { $error } {
        puts "ERROR - illegal \"preferred-tracks offsets\". Value must be real on $layer_name for $PT \}"
        break
      }
    }
    if { [info exists PT_track_repeats] && ((! [string is double $PT_track_repeats]) || ($PT_track_repeats < (1.0 / $lengthPrecision))) } {
      puts "ERROR - illegal \"preferred-tracks repeat\". Value must be positive real on $layer_name for $PT \}"
      set error 1
      break
    }
    if { [info exists NPT_track_offsets] } {
      foreach t_item $NPT_track_offsets {
        if { ! [string is double $t_item] } {
          set error 1
          break
        }
      }
      if { $error } {
        puts "ERROR - illegal \"non-preferred-tracks offsets\". Value must be real on $layer_name for $NPT \}"
        break
      }
    }
    if { [info exists NPT_track_repeats] && ((! [string is double $NPT_track_repeats]) || ($NPT_track_repeats < (1.0 / $lengthPrecision))) } {
      puts "ERROR - illegal \"non-preferred-tracks repeat\". Value must be positive real on $layer_name for $NPT \}"
      set error 1
      break
    }

    if { [info exists PT_track_offsets] && (! [info exists PT_track_repeats]) } {
      puts "ERROR - \"preferred-tracks\" missing \"repeat\" on $layer_name for $PT \}"
      set error 1
      break
    }
    if { [info exists PT_track_repeats] && (! [info exists PT_track_offsets]) } {
      puts "ERROR - \"preferred-tracks\" missing \"offsets\" on $layer_name for $PT \}"
      set error 1
      break
    }
    if { [info exists NPT_track_offsets] && (! [info exists NPT_track_repeats]) } {
      puts "ERROR - \"non-preferred-tracks\" missing \"repeat\" on $layer_name for $NPT \}"
      set error 1
      break
    }
    if { [info exists NPT_track_repeats] && (! [info exists NPT_track_offsets]) } {
      puts "ERROR - \"non-preferred-tracks\" missing \"offsets\" on $layer_name for $NPT \}"
      set error 1
      break
    }

    if { [info exists PT_track_repeats] } {
      if { ! [info exists ${layer_name}(PT)] } {
        set ${layer_name}(PT) {}
      }
      lappend ${layer_name}(PT) [list $PT_track_repeats $PT_track_offsets]
    }
    if { [info exists NPT_track_repeats] } {
      if { ! [info exists ${layer_name}(NPT)] } {
        set ${layer_name}(NPT) {}
      }
      lappend ${layer_name}(NPT) [list $NPT_track_repeats $NPT_track_offsets]
    }

  }

  foreach layer_name $layers {
    if { $error } {
      break
    }
    if { [info exists ${layer_name}(dir)] } {
      set preferred_dir [expr $${layer_name}(dir)]
    } elseif { ! ([info exists ${layer_name}(PT)] || [info exists ${layer_name}(PT)]) } {
    # no tracks or preferred_dir defined for the layer
      continue
    }
    unset -nocomplain act_dir
    set dir_index [lsearch -glob $preferred_dir_list "$layer_name *"]
    if { $dir_index >= 0 } {
      set act_dir [lindex [lindex $preferred_dir_list $dir_index] 1]
    }
    if { [info exists preferred_dir] } {
    # see if preferred_dir needs to be changed
      if { [info exists act_dir] } {
        if { ! [string match -nocase $act_dir $preferred_dir] } {
        # mismatched preferred direction
          puts "INFO - Changing $layer_name preferred direction to \"${preferred_dir}\""
          unset_preferred_routing_direction -layer $layer_name
          set_preferred_routing_direction -layers $layer_name -direction $preferred_dir
          set act_dir $preferred_dir
          set preferred_dir_list \
            [lreplace $preferred_dir_list $dir_index $dir_index \
            [list $layer_name $preferred_dir]]
          lappend dir_updates [list $layer_name $preferred_dir]
        }
      } else {
        puts "ERROR - $layer_name has no preferred direction"
        set error 1
        continue
      }
    } else {
      if { [info exists act_dir] && \
             ( [string match horizontal $act_dir] || \
           [string match vertical $act_dir] ) } {
        puts "INFO - $layer_name using $act_dir preferred direction"
        set preferred_dir $act_dir
      } else {
        puts "WARNING - $layer_name has no preferred direction"
        continue
      }
    }
  }

  foreach layer_dir $preferred_dir_list {
    if { $error } {
      break
    }
    set layer_name [lindex $layer_dir 0]
    if { ! [info exists ${layer_name}(PT) ] } {
    # no defined preferred tracks to add
      continue
    }
    set preferred_dir [lindex $layer_dir 1]
    # set layer_index [lsearch -exact $layers $layer_name]

    unset -nocomplain tracks_actually_set
    set tracks_actually_set {}

    if { [string match horizontal $preferred_dir] } {
      set horizontal 1
      set XY Y
      set bound_ll $bound_lly
      set bound_ur $bound_ury
    } else {
      set horizontal 0
      set XY X
      set bound_ll $bound_llx
      set bound_ur $bound_urx
    }

    # find start track (based on reference_origin) relative to lower-left
    if { $reference_origin } {
    # reference for offset is origin
      set start_ref 0
    } else {
    # reference for offset is lower-left
      set start_ref $bound_ll
    }

    set PT_list [expr $${layer_name}(PT)]

    # get default layer width
    set width [get_layer_attribute -layer $layer_name defaultWidth]
    # if no_sharing_boundary use width, else treat as if width=0
    #   (since only the track not the metal must fall within/touching boundary)
    if { ! $no_sharing_boundary } {
      set width 0
    }
    set removed_track 0

    foreach PT $PT_list {
      set PT_track_repeats [lindex $PT 0]
      set PT_track_offsets [lindex $PT 1]


      # figure out offsets and repeats for actual tracks
      set item_list {}
      foreach PT_offset $PT_track_offsets  {
      # find start track based on start_ref (wire width must fit in bounds)
        set offset_adjust [expr $PT_offset \
          - ($PT_track_repeats *floor($PT_offset / $PT_track_repeats))]
        set PT_start [expr $start_ref + $offset_adjust \
          + (($offset_adjust < (0.5 * $width))? $PT_track_repeats : 0)]
        set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $PT_start) \
          / $PT_track_repeats)) ]
        if { $tcnt > 0 } {
          set new_item [list $PT_start $tcnt]
          if { [lsearch -exact $item_list $new_item] < 0 } {
            lappend item_list $new_item
          }
        }
      }
      if { (! $removed_track) && ([llength $item_list] > 0) } {
        puts "INFO: Forcing preferred track to defined values on -layer $layer_name"
        remove_track -layer $layer_name -dir $XY
        set removed_track 1
      }
      foreach new_item $item_list  {
        set PT_start [lindex $new_item 0]
        set tcnt [lindex $new_item 1]
        set new_track "create_track -layer $layer_name -dir $XY -coord $PT_start \
          -space $PT_track_repeats -count $tcnt"
        eval $new_track
        lappend tracks_actually_set $new_track
      }
    }
    if { [llength $tracks_actually_set] > 0 } {
      set ${layer_name}(tracks) $tracks_actually_set
    }
  }

  # loop to add defined non-preferred tracks
  foreach layer_dir $preferred_dir_list {
    if { $error } {
      break
    }
    set layer_name [lindex $layer_dir 0]
    if { ! [info exists ${layer_name}(NPT)] } {
    # no defined non-preferred tracks to add
      continue
    }
    set preferred_dir [lindex $layer_dir 1]
    set layer_index [lsearch -exact $layers $layer_name]
    if { [string match horizontal $preferred_dir] } {
      set horizontal 0
      set XY X
      set bound_ur $bound_urx
    } else {
      set horizontal 1
      set XY Y
      set bound_ur $bound_ury
    }

    set NPT_list [expr $${layer_name}(NPT)]

    # get default layer width
    set width [get_layer_attribute -layer $layer_name defaultWidth]
    # if no_sharing_boundary use width, else treat as if width=0
    #   (since only the track not the metal must fall within/touching boundary)
    if { ! $no_sharing_boundary } {
      set width 0
    }
    set removed_track 0

    foreach NPT $NPT_list {
      set NPT_track_repeats [lindex $NPT 0]
      set NPT_track_offsets [lindex $NPT 1]

      # figure out offsets and repeats for actual tracks
      set item_list {}
      foreach NPT_offset $NPT_track_offsets  {
      # find start track based on start_ref (wire width must fit in bounds)
        set offset_adjust [expr $NPT_offset \
          - ($NPT_track_repeats \
          * floor($NPT_offset / $NPT_track_repeats))]
        set NPT_start [expr $start_ref + $offset_adjust \
          + (($offset_adjust < (0.5 * $width))? $NPT_track_repeats : 0)]
        set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $NPT_start) \
          / $NPT_track_repeats)) ]
        if { $tcnt > 0 } {
          set new_item [list $NPT_start $tcnt]
          if { [lsearch -exact $item_list $new_item] < 0 } {
            lappend item_list $new_item
          }
        }
      }
      if { (! $removed_track) && ([llength $item_list] > 0) } {
        puts "INFO: Forcing non-preferred track to defined values on -layer $layer_name"
        remove_track -layer $layer_name -dir $XY
        set removed_track 1
      }
      foreach new_item $item_list  {
        set NPT_start [lindex $new_item 0]
        set tcnt [lindex $new_item 1]
        set new_track "create_track -layer $layer_name -dir $XY -coord $NPT_start \
          -space $NPT_track_repeats -count $tcnt"
        eval $new_track
      }
    }
  }

  # loop to check if default non-preferred tracks are needed
  foreach layer_dir $preferred_dir_list {
    if { $error } {
      break
    }
    set layer_name [lindex $layer_dir 0]
    if { [info exists ${layer_name}(NPT)] } {
    # already added non-preferred tracks
      continue
    }
    set preferred_dir [lindex $layer_dir 1]
    set layer_index [lsearch -exact $layers $layer_name]
    if { $layer_index > 0 } {
      set lower_layer [lindex $layers [expr $layer_index - 1]]
    } else {
      set lower_layer ""
    }
    if { $layer_index < ([llength $layers] - 1) } {
      set upper_layer [lindex $layers [expr $layer_index + 1]]
    } else {
      set upper_layer ""
    }

    if { ! ([info exists ${upper_layer}(tracks)] || [info exists ${lower_layer}(tracks)]) } {
    # no preferred tracks defined on adjacent tracks
      continue
    }

    if { [string match horizontal $preferred_dir] } {
      set horizontal 0
      set XY X
    } else {
      set horizontal 1
      set XY Y
    }

    set np_list {}
    if { [llength $lower_layer] } {
      unset -nocomplain lower_tracks
      redirect -variable lower_tracks { report_track -layer $lower_layer -dir $XY }
      set next_match 0
      while { [regexp -start $next_match -indices \
                "$lower_layer \[^\n]*" \
              $lower_tracks np_indices] } {
        lappend np_list \
          [lreplace [lrange [string range $lower_tracks \
          [lindex $np_indices 0] \
          [lindex $np_indices 1]] \
          0 4] 0 0 $layer_name]
        set next_match [expr [lindex $np_indices 1] + 1]
      }
      unset -nocomplain lower_tracks np_indices next_match
    }
    if { [llength $upper_layer] } {
      unset -nocomplain upper_tracks
      redirect -variable upper_tracks { report_track -layer $upper_layer -dir $XY }
      set next_match 0
      while { [regexp -start $next_match -indices \
                "$upper_layer \[^\n]*" \
              $upper_tracks np_indices] } {
        lappend np_list \
          [lreplace [lrange [string range $upper_tracks \
          [lindex $np_indices 0] \
          [lindex $np_indices 1]] \
          0 4] 0 0 $layer_name]
        set next_match [expr [lindex $np_indices 1] + 1]
      }
      unset -nocomplain upper_tracks np_indices next_match
    }
    set np_list [lsort -unique $np_list]

    if { [llength $np_list] > 0 } {
      puts "INFO: Resetting non-preferred track to adjacent layer preferred tracks settings on -layer $layer_name"
      remove_track -layer $layer_name -dir $XY
    }
    foreach np_track $np_list {
      if { [llength $np_track] < 5 } {
        continue
      }
      set new_track "create_track -layer $layer_name -dir $XY -coord [lindex $np_track 2] \
        -space [lindex $np_track 4] -count [lindex $np_track 3]"
      eval $new_track
    }

  }

  if { $error } {
    puts "ERROR - $func_name stopped due to errors"
  }

}
define_proc_attributes P_set_repeating_custom_tracks -info "set custom tracks" \
  -define_args {{-track_settings "provide list or use '-track_settings help' for TrackInfoList format" TrackInfoList list required } \
                {-offset_reference "reference for track offsets {default=lowerLeft}" offset_reference one_of_string { optional value_help {values {lowerLeft origin}}}} \
              {-no_tracks_on_boundary "require tracks produce wires fully in the boundary" "" boolean optional} }

########################################################################################################
# Procedure   : P_check_boundary_contact
# Description : The procedure to determine if the Core Boundary contacts with any cell
#               which has start point coordinates as cell_llx, cell_lly
#               Used in halo insertion

proc P_check_boundary_contact {cell_llx cell_lly} {
  set func_name [lindex [info level [info level]] 0]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }
  set bbox [get_attribute [get_core_area] bbox]
  set bbox_x1 [lindex [lindex $bbox 0] 0]
  set bbox_y1 [lindex [lindex $bbox 0] 1]
  set bbox_x2 [lindex [lindex $bbox 1] 0]
  set bbox_y2 [lindex [lindex $bbox 1] 1]

  global diehalo_width
  global diehalo_height

  set flag 0
  set prs_flag 0

  # Checking if the cell that gets placed will be within the die boundary.
  # Uncomment line from 78-83 and comment line 85-90 if die-edge halo is considered within Core
  #  if {($cell_llx <= [expr $bbox_x1 + 0.54 - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + 1.68 - 0.001]) || ($cell_llx >= [expr $bbox_x2 - 0.54 - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - 1.68 - 0.001] )} {
  # set flag 1
  #   } else {
  #       set flag 0
  #   }
  #   return $flag

  if {($cell_llx <= [expr $bbox_x1 + $diehalo_width - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + $diehalo_height - 0.001]) || ($cell_llx >= [expr $bbox_x2 - $diehalo_width - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - $diehalo_height - 0.001] )} {
    set flag 1
  } else {
    set flag 0
  }
  return $flag
}

########################################################################################################
# Procedure   : P_get_abut_chain
# Description : This proc is used to get list of macros which are abutting each other
#               Used in halo insertion

proc P_get_abut_chain {abut_master} {
  global cellabutlist
  set cellabutlist [add_to_collection $cellabutlist $abut_master]
  set macro_bbox [list [get_attribute $abut_master boundary]]
  set overlapcells [remove_from_collection [get_cells -all -intersect $macro_bbox] $cellabutlist]
  foreach_in_collection ovcell $overlapcells {
    P_get_abut_chain $ovcell
  }
  return $cellabutlist
}

########################################################################################################
# Procedure   : P_get_abutted_cells
# Description : This proc is used to get macro cells which are abutting
#               Used in halo insertion

proc P_get_abutted_cells {input_master} {
  set macro_groups ""
  set fullabutlist ""
  global cellabutlist
  foreach_in_collection macrolist $input_master {
    if {[sizeof_collection [remove_from_collection $fullabutlist $macrolist -intersect]] == 0} {
      set cellabutlist ""
      set out_list [P_get_abut_chain $macrolist]
      set fullabutlist [add_to_collection $fullabutlist $out_list]
      lappend macro_groups [lsort -unique [get_object_name $out_list]]
    }
  }

  return $macro_groups
}

########################################################################################################
# Procedure   : P_get_abut_macro_chain
# Description : This proc is used to get list of macros which are abutting each other
#               Used in integration checks

proc P_get_abut_macro_chain {abut_master} {
  global cellabutlist
  set cellabutlist [add_to_collection $cellabutlist $abut_master]
  set macro_bbox [list [get_attribute $abut_master boundary]]
  set overlapcells [remove_from_collection [get_cells -all -intersect $macro_bbox -filter "mask_layout_type == macro"] $cellabutlist]
  foreach_in_collection ovcell $overlapcells {
    P_get_abut_macro_chain $ovcell
  }
  return $cellabutlist
}

########################################################################################################
# Procedure   : P_get_abutted_macro_cells
# Description : This proc is used to get macro cells which are abutting
#               Used in integration checks

proc P_get_abutted_macro_cells {input_master} {
  set macro_groups ""
  set fullabutlist ""
  global cellabutlist
  foreach_in_collection macrolist $input_master {
    if {[sizeof_collection [remove_from_collection $fullabutlist $macrolist -intersect]] == 0} {
      set cellabutlist ""
      set out_list [P_get_abut_macro_chain $macrolist]
      set fullabutlist [add_to_collection $fullabutlist $out_list]
      lappend macro_groups [lsort -unique [get_object_name $out_list]]
    }
  }

  return $macro_groups
}

#######################################################################################################
# Procedure   : P_get_boundary_polygon
# Description : This proc is used boundary polygon computation for halo insertion

proc P_get_boundary_polygon {list_macros} {
  set func_name [lindex [info level [info level]] 0]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }
  set result_polygon [list]
  while {[llength $list_macros] > 0} {
    set copy_macros $list_macros
    for { set i 0 } { $i < [llength $copy_macros] } { incr i } {
      if {[llength $result_polygon] > 0 } {
        set polygon [compute_polygons -boolean or "$result_polygon" [get_attribute [get_cells -all [lindex $copy_macros $i]] boundary]]
        if {[llength $polygon] == 1} {
          set result_polygon $polygon
          set list_macros [lsearch -inline -all -not -exact $list_macros [lindex $copy_macros $i]]
        }
      } else {
        set first_macro [lindex $copy_macros 0]
        set list_macros [lsearch -inline -all -not -exact $list_macros $first_macro]
        set result_polygon [get_attribute [get_cells -all $first_macro] boundary]
      }
    }
  }

  if {[llength $result_polygon] != 1} {
    set result_polygon [list $result_polygon];
  }

  return $result_polygon
}

#######################################################################################################
# Procedure   : P_lcount
# Description : This proc is used to get repeated elements from a list

proc P_lcount list {
  foreach x $list {lappend arr($x) {}}
  set res {}
  foreach name [array names arr] {
    if { [llength $arr($name)] == 2 } {
      set res $name
    }
  }
  return $res
}

#######################################################################################################
# Procedure   : P_place_halo
# creates and places a HALO cell at a specific location
# to improve run time, save orientation in list and run at the end
#
proc P_place_halo {cell inst x y orientation} {
  global halo_counter
  global halo_orient_N halo_orient_FN halo_orient_S halo_orient_FS
  create_cell $inst $cell > /dev/null
  set_cell_location $inst -coordinates "$x $y" -ignore_fixed
  #rotate_objects $inst -to $orientation -ignore_fixed > /dev/null
  #this command is slow, so create a list of cell first, then run at once
  if {$orientation == "N"} {
  lappend halo_orient_N "$inst"
} elseif {$orientation == "FN"} {
  lappend halo_orient_FN "$inst"
} elseif {$orientation == "S"} {
  lappend halo_orient_S "$inst"
} elseif {$orientation == "FS"} {
  lappend halo_orient_FS "$inst"
} else {
  P_msg_error "set orientation error"
}
incr halo_counter
#puts "==>INFORMATION: Placed $cell $inst $x $y $orientation"
}

#######################################################################################################
# Procedure   : P_find_direction
# This procedure just finds the direction of the boundary edge
# by looking at the coordinate of start point and end point
# returns "up", "down", "left", "right"
#
proc P_find_direction {start end} {
  set startx [lindex $start 0]
  set starty [lindex $start 1]
  set endx [lindex $end 0]
  set endy [lindex $end 1]
  if {$startx == $endx && $starty==$endy} {
    return "nochange"
  } elseif {$startx<$endx && $starty==$endy} {
    return "right"
  } elseif {$startx==$endx && $starty<$endy} {
    return "up"
  } elseif {$startx>$endx && $starty==$endy} {
    return "left"
  } elseif {$startx==$endx && $starty>$endy} {
    return "down"
  } else {
    P_msg_error "Cannot determine direction"
  }
}

#######################################################################################################
# Procedure   : P_ret_intersect_list
# Description : This proc returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo 
#               Used during halo insertion around voltage areas

proc P_ret_intersect_list {args} {
  parse_proc_arguments -args $args inputs
  set func_name [lindex [info level [info level]] 0]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }
  set vboundary $inputs(-input_boundary)
  set input_va_name $inputs(-input_va)

  set check_boundary_list [list ]
  set volt_boundary [lsort -unique -dict -increasing $vboundary]

  set die_boundary [lsort -unique -dict -increasing [get_attribute [get_die_area] boundary]]
  lappend check_boundary_list $die_boundary

  set intersect_macros [get_cells -all -intersect $vboundary -quiet -filter "name !~ *halo_va*"]
  foreach_in_collection  macro $intersect_macros {
    lappend check_boundary_list [lsort -unique -incr -dict [get_attribute $macro boundary]]
  }

  set ret_list ""
  set volt_count -1

  foreach volt_point $volt_boundary {
    incr volt_count
    foreach volt_x_val [lindex $volt_point 0] {
      foreach check_bound $check_boundary_list {
        set ch_count -1
        set x_val ""
        foreach check_point $check_bound {
          incr ch_count
          foreach check_x_val [lindex $check_point 0] {
            if {[lsearch $x_val $volt_x_val] > -1} {continue}
            if {$check_x_val == $volt_x_val} {
              lappend x_val $check_x_val
              set check_curr_y_val [lindex $check_point 1]
              set check_next_y_val [lindex [lindex $check_bound [expr $ch_count + 1]] 1]
              set volt_curr_y_val [lindex $volt_point 1]
              set volt_next_y_val [lindex [lindex $volt_boundary [expr $volt_count + 1]] 1]

              if {($check_curr_y_val <= $volt_curr_y_val) && ($check_next_y_val > $volt_curr_y_val)} {
                set ret_list "$ret_list x_$volt_x_val y1_$volt_curr_y_val y2_$check_next_y_val"
              } elseif {($check_curr_y_val < $volt_next_y_val) && ($check_next_y_val >= $volt_next_y_val)} {
                set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$volt_next_y_val"
              } elseif {($check_curr_y_val > $volt_curr_y_val) && ($check_next_y_val < $volt_next_y_val)}  {
                set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$check_next_y_val"
              }
            }
          }
        }
      }
    }
  }

  return $ret_list
}

define_proc_attributes P_ret_intersect_list \
  -info "Returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo" \
  -define_args {
    {"-input_boundary" "Voltage area boundary" "" list required}
    {"-input_va" "Voltage area name" "" string required}
}

#######################################################################################################
# Procedure   : P_check_exclusion
# Description : This proc returns the returns y1 y2 intersect points of boundary/macro/non-va-halo
#               Used during halo insertion around voltage areas

proc P_check_exclusion {args} {
  parse_proc_arguments -args $args inputs
  set x $inputs(-x)
  set y $inputs(-y)
  set ret 1

  foreach in_list $inputs(-list) {
    set match_index [lsearch -all $in_list x_$x]
    foreach x_index $match_index {
      if {$x_index > -1} {
        set y1 [lindex [split [lindex $in_list [expr $x_index + 1]] "_"] 1]
        set y2 [lindex [split [lindex $in_list [expr $x_index + 2]] "_"] 1]
        if {[expr $y >= $y1] && [expr $y < $y2]} {
          set ret 0
          return $ret
        }
      }
    }
  }

  return $ret

}

define_proc_attributes P_check_exclusion \
  -info "Returns y1 y2 intersect points" \
  -define_args {
    {"-list" "input list" "" string required}
    {"-x" "x coordinate to check" "" string required}
    {"-y" "y coordinate to check" "" string required}
}

####################################################################################################
# Procedure   : P_macro_route_guide_cmd
# Description : This proc is a PG pullback solution.
#               It creates route-guides for all IPs for all specified layers and pulls back the PG when power straps are created.
#               The route guide is removed when the proc is executed again for the next metal layer.

proc P_macro_route_guide_cmd {layer} {

  global INTEL_MACRO_EXCLUSION_LIST
  global INTEL_MACRO_RG_LIST
  global macro_top_layer

  #find out the top metal layer of the macros

  if {![info exists macro_top_layer]} {
    set gui_status [get_app_var gui_suppress_auto_layout]
    set_app_var gui_suppress_auto_layout true
    foreach name [lsort -unique [get_attribute [all_macro_cells] ref_name]] {
      close_mw_cel $name.FRAM 
      open_mw_cel $name.FRAM -readonly
      set macro_top_layer(${name}) [string map {m ""} [lindex [lsort -unique -decreasing [regexp -all -inline {m[0-9]+} [get_attribute [get_shapes -quiet] layer -quiet]]] 0]]
      close_mw_cel $name.FRAM
    }
    set_app_var gui_suppress_auto_layout $gui_status
  }

  remove_route_guide macroblkg*

  foreach_in_collection macro [all_macro_cells] {
    set macro_ref_name [get_attribute $macro ref_name]
    set macro_index ""
    set default_index ""
    set exclusion_list -1

    #Sets up exclusion list for macro references which should not have RGs for any layer
    #------------------------------------------------------------------------------------
    if {[info exists INTEL_MACRO_EXCLUSION_LIST] && $INTEL_MACRO_EXCLUSION_LIST != ""} {
      set exclusion_list [lsearch $INTEL_MACRO_EXCLUSION_LIST $macro_ref_name]
    }

    if {$exclusion_list >= 0} {
      P_msg_info "Route Guides not created for macro:$macro_ref_name as it is part of exclusion list..."
    } else {

    #Overrides default bloat values of current layer for specified macros
    #---------------------------------------------------------------------------------
      if {[info exists INTEL_MACRO_RG_LIST($macro_ref_name)]} {
        set macro_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST($macro_ref_name)] $layer]
        if {$macro_index != -1} {
          set x_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 1]]
          set y_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 2]]
        }
      }

      #Defaults bloat values for current layer if not overriden for a macro
      #-------------------------------------------------------------------------

      if {![info exists INTEL_MACRO_RG_LIST($macro_ref_name)] || $macro_index == -1} {
        if {[info exists INTEL_MACRO_RG_LIST(DEFAULT)]} {
          set default_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST(DEFAULT)] $layer]
          if {$default_index != -1} {
            set x_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 1]]
            set y_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 2]]
          }
        }
      }

      #No route guides will be created for current layer, if bloat values were neither provided in default or override list
      #----------------------------------------------------------------------------------------------------------------------

      if {![info exists INTEL_MACRO_RG_LIST(DEFAULT)] || $default_index == -1} {
        puts "==>ERROR: Neither \$INTEL_MACRO_RG_LIST($macro_ref_name) nor \$INTEL_MACRO_RG_LIST(DEFAULT) have been defined for layer $layer. Route Guides will not be created..."
        return
      }

      #Check to ensure that both bloats should either be NA or should be a double value.
      #----------------------------------------------------------------------------
      if {!(($x_bloat eq "NA") && ($y_bloat eq "NA")) && !([string is double $x_bloat] && [string is double $y_bloat])} {
        puts "==>ERROR: Bloat values specified incorrectly for $macro_ref_name. Either x_bloat and y_bloat should both be NA (or) a double value. Route Guides will not be created..."
        return
      }


      #Route Guides will not be created if both x and y bloats equal NA
      #-------------------------------------------------------------------
      if {($x_bloat eq "NA") && ($y_bloat eq "NA")} {
        continue
      }


      #Route Guides will be created around macros based on INTEL_MACRO_RG_LIST variable
      #-------------------------------------------------------------------------------------------

      set macro_name [get_attribute $macro full_name]
      set macro_bound [get_attribute $macro boundary]
      set rect_box [convert_from_polygon -format rectangle $macro_bound]
      set i 0
      foreach rect $rect_box {
        scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
        set macrobbox_bloat "[expr $b_llx - $x_bloat] [expr $b_lly - $y_bloat] [expr $b_urx + $x_bloat] [expr $b_ury + $y_bloat]"

        if {[expr [string map {m ""} $layer] <= $macro_top_layer($macro_ref_name)]} {
          create_route_guide -no_preroute_layers $layer \
            -name macroblkg_${macro_name}_${layer}_${i} \
            -coordinate $macrobbox_bloat
          incr i
        }
      }
    }
  }
}

#########################################################################################################
# Procedure   : P_strap_cmd
# Common procedure to create power straps
# step_at: the offset from which the start the first strap
# step: pitch
# pullback: distance to pull the end of strap away from bondary to isolate from neighbor partition

proc P_strap_cmd {layer direction net width start_at step pullback} {
  global bound_llx bound_lly bound_urx bound_ury
  set cmd "create_power_straps -layer $layer -nets $net -width $width \
    -start_at $start_at -step $step \
    -configure step_and_stop \
    -clip_at_top_cell_boundaries \
    -advanced_via_rules \
    -keep_floating_wire_pieces"
  if {$direction == "horizontal"} {
    set high_ends [expr $bound_urx - $pullback]
    set low_ends [expr $bound_llx + $pullback]
    set cmd "$cmd -direction horizontal \
      -start_high_ends coordinate -start_high_ends_coordinate [expr $bound_urx - $pullback] \
      -start_low_ends coordinate -start_low_ends_coordinate [expr $bound_llx + $pullback] \
      -stop $bound_ury"
  } else {
    set high_ends [expr $bound_ury - $pullback]
    set low_ends [expr $bound_lly + $pullback]
    set cmd "$cmd -direction vertical \
      -start_high_ends coordinate -start_high_ends_coordinate $high_ends \
      -start_low_ends coordinate -start_low_ends_coordinate $low_ends \
      -stop $bound_urx"
  }
  if {$pullback == 0} {
    set cmd "$cmd -extend_low_ends to_boundary_and_generate_pins \
      -extend_high_ends to_boundary_and_generate_pins"
  }
  set cmd [regsub -all {\s+} $cmd " "]; #clean up extra spaces
  puts "==>INFORMATION: Running \"$cmd\""
  eval $cmd
}

#########################################################################################################
# Procedure   : P_check_partition_dimension
# Check if the partition dimension is modular-grid multiple

proc P_check_partition_dimension {} {

  global INTEL_DESIGN_WIDTH INTEL_DESIGN_HEIGHT INTEL_FP_BOUNDARY
  global INTEL_FP_INPUT
  global INTEL_MD_GRID_X INTEL_MD_GRID_Y

  if {[info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH != "" && [info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT != ""} {
    P_msg_info "Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
    if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X) - round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X))]] != 0.0 } {
      P_msg_error "Block width is NOT n * $INTEL_MD_GRID_X, please adjust the design width setting INTEL_DESIGN_WIDTH."
      P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_X is [expr round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X)]"
    }
    if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y) - round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y))]] != 0.0 } {
      P_msg_error "Block height is NOT n * $INTEL_MD_GRID_Y, please adjust the design height setting INTEL_DESIGN_HEIGHT."
      P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_Y is [expr round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y)]"
    }
    P_msg_info "Done: Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
  } elseif {[info exists INTEL_FP_BOUNDARY] && $INTEL_FP_BOUNDARY != ""} {
    P_msg_info "Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
    redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $INTEL_FP_BOUNDARY $INTEL_FP_BOUNDARY]}}
    if { ! [info exists _bndry] } {
      P_msg_error "INTEL_FP_BOUNDARY is not valid.  May require additional set of {} braces"
    } elseif { $_bndry == 0 } {
      P_msg_error "INTEL_FP_BOUNDARY specified is not a valid polygon"
    } elseif { [llength $_bndry] == 0 } {
      P_msg_error "INTEL_FP_BOUNDARY specified has no defined area"
    } elseif { [llength $_bndry] != 1 } {
      P_msg_error "INTEL_FP_BOUNDARY specified is not a single polygon shape"
    } else {
      set _bndry [lindex $_bndry 0]
    }
    foreach xy $INTEL_FP_BOUNDARY {
      set x [lindex $xy 0]
      set y [lindex $xy 1]
      if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
        P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
        P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
      }
      if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
        P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
        P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
      }
    }
    P_msg_info "Done: Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
  } elseif { ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "DEF") || ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "FP_TCL") } {
    set fp_boundary [get_attribute [get_core_area] boundary]
    P_msg_info "Checking if coordinates of the die area are integer multiples of the modular grid."
    redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $fp_boundary $fp_boundary]}}
    if { ! [info exists _bndry] } {
      P_msg_error "The die area is not valid.  May require additional set of {} braces"
    } elseif { $_bndry == 0 } {
      P_msg_error "The die area specified is not a valid polygon"
    } elseif { [llength $_bndry] == 0 } {
      P_msg_error "The die area specified has no defined area"
    } elseif { [llength $_bndry] != 1 } {
      P_msg_error "The die area specified is not a single polygon shape"
    } else {
      set _bndry [lindex $_bndry 0]
    }
    foreach xy $fp_boundary {
      set x [lindex $xy 0]
      set y [lindex $xy 1]
      if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
        P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
        P_msg_error "Please adjust the die area."
      }
      if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
        P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
        P_msg_error "Please adjust the die area."
      }
    }
    P_msg_info "Done: Checking if coordinates of the die area are integer multiples of the modular grid."
  } else {
    P_msg_error "None of the following is set: INTEL_DESIGN_WIDTH/INTEL_DESIGN_HEIGHT, INTEL_FP_BOUNDARY, INTEL_FP_DEF or INTEL_FP_TCL"
  }
}

proc P_adv_polygon_size { args } {
  set func_name [lindex [info level [info level]] 0]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }

  if { [llength $args] == 0 } {
    parse_proc_arguments -args "-help" inputs
  }
  parse_proc_arguments -args $args inputs
  set func_name [string range [lindex [info level [info level]] 0] 2 end]

  namespace eval ::polygon_ops { }
  namespace eval ::polygon_ops::polygon_sets { }

  # return an expression if -list given or polygon is not a defined_set
  set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon)]) || [info exists inputs(-list)]]

  # get size argument, see if valid
  set size $inputs(size)

  # allow for separate x,y size
  # if only a single value, then x,y default to that value
  set xsize [lindex $size 0]
  set ysize [lindex $size end]
  if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
    error "$func_name: size value \"$size\" is not a float or pair of floats."
    unset size xsize ysize
  }

  set no_sizing 0
  set single_resize 1
  set directional_resize 0
  if { $xsize == $ysize } {
    set simple_size 1
    set size $xsize
    if { $xsize == 0 } {
      set no_sizing 1
    } else {
      redirect -variable resize_help {resize_polygon -help}
      set single_resize [regexp -- {points list of a polygon} $resize_help]
    }
  } else {
    set simple_size 0
    redirect -variable resize_help {resize_polygon -help}
    set single_resize [regexp -- {points list of a polygon} $resize_help]
    set directional_resize [regexp -- {-size_left} $resize_help]
  }

  # parse polygon information
  set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
  if {$bad_polygon != 0} {
    if { [string length "$inputs(polygon)"] > 50 } {
      regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
      set prnt_str "$prnt_str ..."
    } else {
      set prnt_str "$inputs(polygon)"
    }
    error "'${func_name}': polygon \"${prnt_str}\" is not a valid polygon."
    return {}
  }

  # see if extra_braces are used (is so, temporarily disable)
  if { [info exists ::mw_attr_value_extra_braces] } {
    set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
    set ::mw_attr_value_extra_braces false
  } else {
    set orig_mw_attr_value_extra_braces true
  }

  # suppress message MWUI-087 when downsizing removes a polygon
  set no_MWUI_087_suppress 0
  if { (! $single_resize) && (($xsize < 0) || ($ysize < 0)) } {
    redirect -variable suppress_chk_str {print_suppressed_messages}
    if { [lsearch -exact [split [regsub -all {[\{\},\s]+} $suppress_chk_str { }]] {MWUI-087}] == -1 } {
      set no_MWUI_087_suppress 1
      suppress_message {MWUI-087}
    }
  }

  # go through sizing scenarios
  if { $no_sizing || ([llength $polygon] < 1) } {
  # no sizing or no polygon - nothing to do
    set final $polygon
  } elseif { $simple_size && $single_resize } {
  # use simple sizing function
  set final {}
    foreach shape $polygon {
      foreach sized_poly [resize_polygon -size $size $shape] {
      # ensure a valid polygon was returned
      # - some Synopsys versions return '0' rather than {} if empty
        if { [llength $sized_poly] > 3 } {
          lappend final $sized_poly
        }
      }
    }
  } elseif { $simple_size } {
    set final [resize_polygon -size $size $polygon]
    if { $final == 0 } {
      set final {}
    }
  } elseif { $directional_resize } {
    if { (($xsize < 0) && ($ysize < 0)) || (($xsize > 0) && ($ysize > 0)) } {
      set final [resize_polygon -size_left $xsize -size_right $xsize -size_top $ysize -size_bottom $ysize $polygon]
    } elseif { $ysize < 0 } {
      set pre_final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
      if { $no_MWUI_087_suppress } {
        set no_MWUI_087_suppress 0
        unsuppress_message {MWUI-087}
      }
      if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
        set final {}
      } elseif { $xsize == 0 } {
        set final $pre_final
      } else {
        set final [resize_polygon -size_left $xsize -size_right $xsize $pre_final]
      }
    } elseif { $xsize < 0 } {
      set pre_final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
      if { $no_MWUI_087_suppress } {
        set no_MWUI_087_suppress 0
        unsuppress_message {MWUI-087}
      }
      if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
        set final {}
      } elseif { $ysize == 0 } {
        set final $pre_final
      } else {
        set final [resize_polygon -size_top $ysize -size_bottom $ysize $pre_final]
      }
    } elseif { $ysize == 0 } {
      set final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
    } elseif { $xsize == 0 } {
      set final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
    } else {
      set final $polygon
    }
    if { $final == 0 } {
      set final {}
    }
  } else {
  # first perform any necessary shrink
    if { ($xsize < 0) || ($ysize < 0) } {
    # to avoid issues with breaking apart during shrink,
    # the shrink is done as an inverse image using a grow
    #   expand_bound = (expand BOUND(polygon) by size)
    #   shrink_poly = expand_bound NOT
    #         (expand (poly_to_rects(expand_bound NOT polygon)) by shrink)
      set shrunk_poly {}

      # expand by 0.1 more than smallest negative value
      set ovrsize [expr ($xsize < $ysize) ? (0.1 - $xsize) : (0.1 - $ysize)]
      set rect_shrink_factor_x [expr ($xsize<0) ?  abs($xsize) : 0]
      set rect_shrink_factor_y [expr ($ysize<0) ?  abs($ysize) : 0]

      foreach shape $polygon {
      # get x extents using a list sort
        set x_sort [lsort -index 0 -increasing -real $shape]
        set xll [expr [lindex [lindex $x_sort 0] 0] - $ovrsize]
        set xur [expr [lindex [lindex $x_sort end] 0] + $ovrsize]

        # get y extents using a list sort
        set y_sort [lsort -index 1 -increasing -real $shape]
        set yll [expr [lindex [lindex $y_sort 0] 1] - $ovrsize]
        set yur [expr [lindex [lindex $y_sort end] 1] + $ovrsize]

        set expand_bound [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
        set inv_polygon [compute_polygons -boolean not $expand_bound $shape]

        # create inverse sized polygon
        set inv_sized_polygon {}
        foreach inv_shape $inv_polygon {
          foreach rect [convert_from_polygon -format polygon $inv_shape] {
          # get x extents using a list sort
            set x_sort [lsort -index 0 -increasing -real $rect]
            set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_shrink_factor_x]
            set xur [expr [lindex [lindex $x_sort end] 0] + $rect_shrink_factor_x]

            # get y extents using a list sort
            set y_sort [lsort -index 1 -increasing -real $rect]
            set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_shrink_factor_y]
            set yur [expr [lindex [lindex $y_sort end] 1] + $rect_shrink_factor_y]

            lappend inv_sized_polygon [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
          }
        }

        # merge inverse sized polygon
        # first see if compute_polygons works for lists of polygons
        unset -nocomplain merge_polygon
        redirect /dev/null {
          catch {set merge_polygon [compute_polygons -boolean or $inv_sized_polygon [lindex $inv_sized_polygon 0]]}
        }
        if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
        # compute_polygons took the list of polygons
          set inv_sized_polygon $merge_polygon
          unset -nocomplain merge_polygon
        } else {
          for { set i 0 } { $i < [llength $inv_sized_polygon] } {incr i} {
            for { set j [expr $i + 1] } { $j < [llength $inv_sized_polygon] } {incr j} {
              set new [compute_polygons -boolean or [lindex $inv_sized_polygon $i] [lindex $inv_sized_polygon $j]]
              if { [llength $new] > 1 } {
                continue
              }
              set inv_sized_polygon [lreplace [lreplace $inv_sized_polygon $i $i [lindex $new 0]] $j $j]
              incr i -1
              break
            }
          }
        }

        # re-invert the polygon
        # first see if compute_polygons works for lists of polygons
        unset -nocomplain re_inv_polygon
        redirect /dev/null {
          catch {set re_inv_polygon [compute_polygons -boolean not [list $expand_bound] $inv_sized_polygon]}
        }
        if { [info exists re_inv_polygon] && (! [string equal $re_inv_polygon "0"]) } {
        # compute_polygons took the list of polygons
          set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
        } else {
          set re_inv_polygon [list $expand_bound]
          foreach inv_shape $inv_sized_polygon {
            set new_shrink {}
            foreach re_shape $re_inv_polygon {
              foreach poly_not [compute_polygons -boolean not $re_shape $inv_shape] {
                lappend new_shrink $poly_not
              }
            }
            set re_inv_polygon $new_shrink
          }
          set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
        }
      }
    } else {
      set shrunk_poly $polygon
    }

    # then perform any necessary grow
    set final {}
    if { ($xsize > 0) || ($ysize > 0) } {
    # the grow is a directional grow on the rectangles of the polygon
      set rect_grow_factor_x [expr ($xsize>0) ?  $xsize : 0]
      set rect_grow_factor_y [expr ($ysize>0) ?  $ysize : 0]

      foreach shape $shrunk_poly {
        foreach rect [convert_from_polygon -format polygon $shape] {
        # get x extents using a list sort
          set x_sort [lsort -index 0 -increasing -real $rect]
          set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_grow_factor_x]
          set xur [expr [lindex [lindex $x_sort end] 0] + $rect_grow_factor_x]

          # get y extents using a list sort
          set y_sort [lsort -index 1 -increasing -real $rect]
          set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_grow_factor_y]
          set yur [expr [lindex [lindex $y_sort end] 1] + $rect_grow_factor_y]

          lappend final [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
        }
      }
    } else {
      set final $shrunk_poly
    }
  }

  if { $no_MWUI_087_suppress } {
    set no_MWUI_087_suppress 0
    unsuppress_message {MWUI-087}
  }

  # merge final polygons
  if { (! $no_sizing) && $single_resize } {
  # first see if compute_polygons works for lists of polygons
    unset -nocomplain merge_polygon
    redirect /dev/null {
      catch {set merge_polygon [compute_polygons -boolean or $final [lindex $final 0]]}
    }
    if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
    # compute_polygons took the list of polygons
      set final $merge_polygon
      unset -nocomplain merge_polygon
    } else {
    # compute_polygons didn't take the list of polygons
      for { set i 0 } { $i < [llength $final] } {incr i} {
        for { set j [expr $i + 1] } { $j < [llength $final] } {incr j} {
          set new [compute_polygons -boolean or [lindex $final $i] [lindex $final $j]]
          if { [llength $new] > 1 } {
            continue
          }
          set final [lreplace [lreplace $final $i $i [lindex $new 0]] $j $j]
          incr i -1
          break
        }
      }
    }
  }

  # return result or assign to polygon_set
  set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
  if { $return_expression } {
    return $final
  } else {
    set ::polygon_ops::polygon_sets::$inputs(polygon) $final
    return {}
  }

}

define_proc_attributes P_adv_polygon_size \
  -info "grow/shrink polygon" \
  -define_args {
    {polygon "polygon" polygon string required}
    {"size" "size {+grow / -shrink} float or list {x y} of float" "" string required}
  {"-list" "return polygon list" "" boolean optional}}
  #}}}




proc P_adv_polygon_check { args } {
  if { [llength $args] == 0 } {
    parse_proc_arguments -args "-help" inputs
  }
  parse_proc_arguments -args $args inputs
  set func_name [string range [lindex [info level [info level]] 0] 2 end]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }

  set option $inputs(option)
  namespace eval ::polygon_ops { }
  namespace eval ::polygon_ops::polygon_sets { }

  set poly_args {}
  set poly_cnt 1

  if { [string equal $option "identical"] } {
    if { [info exists inputs(other_polygon)] } {
      incr poly_cnt
    }
  } elseif { [string equal $option "polygon"] } {
    if { [info exists inputs(other_polygon)] &&  [string equal -nocase "$inputs(other_polygon)" "-list"]} {
      set option "return_expression"
    }
  }

  # parse polygon information
  # store as list for each polygon { name_or_NULL is_simple_polygon
  #                                  is_polygon is_rect_array
  #                                  is_compressed_set complex_polygon_list }
  #    where name_or_NULL = name of defined polygon set if valid, else {}
  #          is_simple_polygon    = 1 if a simple polygon, else 0
  #          is_polygon           = 1 if a polygon, else 0
  #          is_rect_array        = 1 if paired coordinates for rect, else 0
  #          is_compressed_set    = 1 if a compressed polygon set, else 0
  #          complex_polygon_list = polygon value as a complex polygon list
  set polygon_info {}
  for { set i 1 } { $i <= $poly_cnt } { incr i } {
    if { $i == 1 } {
      set source_polygon ::polygon_ops::polygon_sets::$inputs(polygon)
      set item $inputs(polygon)
    } else {
      set source_polygon ::polygon_ops::polygon_sets::$inputs(other_polygon)
      set item $inputs(other_polygon)
    }
    # check if the polygon is defined in a polygon set
    if { [info exists $source_polygon] } {
      set polygon_set [expr $$source_polygon]
      lappend polygon_info [list $item 0 1 0 0 $polygon_set]
      continue
    }

    # check to see if the cell is either a simple/complex polygon or rectArray
    #    or a compressed polygon set

    # First ensure that coordinates if paired are at consistent level
    # - first ensure that a double coordinate value is in the expected levels
    # - max levels to first double = 3
    # -    complex_polygon = { simple_polygon_1 ... simple_polygon_n }
    # -    simple_polygon  = { list_of_coordinates }
    # -    coordinate      = { x y }
    if { ! [string is double -strict [lindex [lindex [lindex $item 0] 0] 0]] } {
    # may be that this is an empty list
      if { [llength $item] == 0 } {
        lappend polygon_info [list {} 1 1 1 1 {}]
      } else {
        lappend polygon_info [list {} 0 0 0 0 {}]
      }
      continue
    }

    # while the length of list is one, strip the nesting level
    while { [llength $item] == 1 } {
      set item [lindex $item 0]
    }

    # - find up one level from the first double coordinate x or y value
    # - ensure that the level is always consistent
    set paired 1
    if { [string is double -strict [lindex $item 0]] } {
    # only a single level - this can only be a rectArray or compressedSet
      set is_simple_polygon 0
      set is_rectArray 1
      set is_compressedSet 1
      set is_polygon 0
      # all items can only be double floats and must be paired set of coords
      # this means the length must be a multiple of 4
      if { ([llength $item] % 4) == 0 } {
      # run a quick check to see if all numbers are double
        if { [catch { lsort -real $item } catch_result] != 0 } {
        # not a list of real/double numbers
          set paired 0
        }
        # normalize the level of the polygon
        set polygon [list $item]
      } else {
        set paired 0
      }
    } else {
      if { [string is double -strict [lindex [lindex $item 0] 0]] } {
      # this can only be a list of coordinate pairs
      # which can be either a compressedSet, rectArray, or simple polygon
        set is_simple_polygon 1
        set is_compressedSet 1
        set is_polygon 1
        # for rectArray, must have an even number of points
        set is_rectArray [expr ([llength $item] % 2) == 0]

        # check that the full set only consists of pairs
        # first check ensures that no members of item >2, second check finds any < 2
        # for checks members cannot be empty {}, i.e. they must contain a non-space char
        if { ([lsearch -glob $item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $item [list ?* ?*]] != -1) } {
        # not valid coordinate pairs
          set paired 0
        } elseif { [catch { lsort -real [join $item] } catch_result] != 0 } {
        # run a quick check to see if all numbers are double
        # not a list of real/double numbers
          set paired 0
        } elseif { [llength $item] > 4 } {
        # for this one case see if same start+end and common x or y
        # in this case then an empty set (must be at least 5 pairs)
          foreach {x1 y1} [lindex $item 0] { break }
          foreach {x2 y2} [lindex $item end] { break }
          if { ($x1 == $x2) && ($y1 == $y2) } {
            if { [llength [lsort -real -unique -index 0 $item]] eq 1 } {
            # fixed x, same start/stop, >= 5 points. ==> empty polygon
              lappend polygon_info [list {} 1 1 1 1 {}]
              continue
            } elseif { [llength [lsort -real -unique -index 1 $item]] eq 1 } {
            # fixed y, same start/stop, >= 5 points. ==> empty polygon
              lappend polygon_info [list {} 1 1 1 1 {}]
              continue
            }
          }
        }
        # normalize the level of the polygon
        set polygon [list $item]
      } else {
      # with the levels involved this can only be a complex polygon
        set is_simple_polygon 0
        set is_compressedSet 0
        set is_polygon 1
        set is_rectArray 0
        # check that all coordinates are paired sets of real/double
        # discard trivial shapes of <3 coordinates
        set polygon {}
        foreach shape $item {
          if { [llength $shape] < 3 } {
          # ignore trivial shapes
            continue
          }
          lappend polygon $shape
        }
        # check that the full set only consists of pairs
        # first check ensures that no members of joined item >2, second check finds any < 2
        # for checks members cannot be empty {}, i.e. they must contain a non-space char
        set joined_item [join $item]
        if { ([lsearch -glob $joined_item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $joined_item [list ?* ?*]] != -1) } {
        # not valid coordinate pairs
          set paired 0
        } elseif { [catch { lsort -real [join $joined_item] } catch_result] != 0 } {
        # run a quick check to see if all numbers are double
        # not a list of real/double numbers
          set paired 0
        }
        unset -nocomplain joined_item
      }

    }
    if { ! $paired } {
    # bad pairing of coordinates found, this is a bad polygon
      lappend polygon_info [list {} 0 0 0 0 {}]
      continue
    }


    # step through the actual shapes and check to see if a valid polygon
    set rectArray {}
    if { $is_rectArray } {
      foreach {xl yl xu yu} [join [join [join $polygon]]] {
        if { ($xl<$xu) && ($yl<$yu) } {
          lappend rectArray [list [list $xl $yl] [list $xl $yu] [list $xu $yu] [list $xu $yl] [list $xl $yl]]
        } else {
          set is_rectArray 0
          break
        }
      }
    }

    if { $is_compressedSet } {
      set compressedSet {}
      set partialSet {}
      # can only be a length of 1
      set joined_polygon [join [join [join $polygon]]]
      set shifted_polygon [join [list [lrange $joined_polygon 2 end] 0 0]]
      unset -nocomplain x0 y0
      foreach {x1 y1} $joined_polygon {x2 y2} $shifted_polygon {
        lappend partialSet [list $x1 $y1]
        if { [info exists x0] } {
          if { ($x0==$x1) && ($y0==$y1) } {
          # shape valid if both x & y have more than one value (there is size to the shape)
            if { ([llength [lsort -unique -real -index 0 $partialSet]] > 1) && ([llength [lsort -unique -real -index 1 $partialSet]] > 1) } {
              lappend compressedSet $partialSet
            }
            set partialSet {}
            unset -nocomplain x0 y0
            continue
          }
          if { ($x1!=$x2) && ($y1!=$y2) } {
            set is_simple_polygon 0
            set is_polygon 0
            set is_compressedSet 0
            break
          }
        } else {
          if { ($x1==$x2) && ($y1==$y2) } {
            continue
          }
          if { ($x1==$x2) || ($y1==$y2) } {
            set x0 $x1
            set y0 $y1
          } else {
            set is_simple_polygon 0
            set is_polygon 0
            set is_compressedSet 0
            break
          }
        }
      }
      if { [info exists x0] } {
      # didn't complete the final polygon shape
        set is_simple_polygon 0
        set is_polygon 0
        set is_compressedSet 0
      }
    } elseif { $is_polygon } {
      set new_polygon {}
      foreach shape $polygon {
      # check that first/last coordinate match
        foreach {x0 y0} [join [lindex $shape 0]] { break }
        foreach {xend yend} [join [lindex $shape end]] { break }
        if { ($x0!= $xend) || ($y0 != $yend) } {
          set is_simple_polygon 0
          set is_polygon 0
          break
        }
        set joined_shape [join [join $shape]]
        set joined_shape1 [lrange $joined_shape 0 end-2]
        set joined_shape2 [lrange $joined_shape 2 end]
        foreach {x1 y1} $joined_shape1 {x2 y2} $joined_shape2 {
          if { ($x1!=$x2) && ($y1!=$y2) } {
            set is_simple_polygon 0
            set is_polygon 0
            set is_compressedSet 0
            break
          }
        }
        if { ! $is_polygon } {
          break
        }
        # shape is valid if both x & y have more than one value (there is size to the shape)
        if { ([llength [lsort -unique -real -index 0 $shape]] > 1) && ([llength [lsort -unique -real -index 1 $shape]] > 1) } {
          lappend new_polygon $shape
        }
      }
      set polygon $new_polygon
    }

    if { $is_rectArray } {
      lappend polygon_info [list {} 0 0 1 0 $rectArray]
    } elseif { $is_polygon && (! $is_compressedSet) } {
      lappend polygon_info [list {} $is_simple_polygon 1 0 0 $polygon]
    } elseif { $is_compressedSet } {
      set is_simple_polygon [expr [llength $compressedSet] < 2]
      lappend polygon_info [list {} $is_simple_polygon $is_simple_polygon 0 [expr ! $is_simple_polygon] $compressedSet]
    } else {
      lappend polygon_info [list {} 0 0 0 0 {}]
    }
  }

  set is_polygon [expr [lindex [lindex $polygon_info 0] 2] || \
    [lindex [lindex $polygon_info 0] 3] || \
    [lindex [lindex $polygon_info 0] 4] || \
    ([llength [lindex [lindex $polygon_info 0] 0]] > 0)]
  switch -exact -- $option {
    simple      {
      set is_simple \
        [expr [lindex [lindex $polygon_info 0] 1]  && ([llength [lindex \
        [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
      return $is_simple
    }
    complex     {
      set is_complex \
        [expr (! [lindex [lindex $polygon_info 0] 1]) && ([llength [lindex \
        [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
      return $is_complex
    }
    defined_set {
      return [expr [llength [lindex [lindex $polygon_info 0] 0]] > 0]
    }
    rectArray   {
      return [expr [lindex [lindex $polygon_info 0] 3] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
    }
    compressed  {
      return [expr [lindex [lindex $polygon_info 0] 4] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
    }
    polygon     {
      return $is_polygon
    }
    default     {
      if { ! $is_polygon } {
        error "'${func_name} $option': polygon \"$inputs(polygon)\" is not a valid polygon."
        return
      }
      set is_polygon [expr \
        [lindex [lindex $polygon_info end] 2] || [lindex [lindex $polygon_info end] 3] || \
        [lindex [lindex $polygon_info end] 4] || ([llength [lindex [lindex $polygon_info end] 0]] > 0)]
      if { (! $is_polygon) && [string equal $option "identical"] && ([llength $polygon_info] > 1) } {
        error "'${func_name} $option': other_polygon \"$inputs(other_polygon)\" is not a valid polygon."
        return
      }
    }
  }

  # see if extra_braces are used (if so, temporarily disable)
  if { [info exists ::mw_attr_value_extra_braces] } {
    set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
    set ::mw_attr_value_extra_braces false
  } else {
    set orig_mw_attr_value_extra_braces true
  }

  # see if polygon lists are accepted or only simple polygons
  redirect -variable compute_help {compute_polygons -help}
  set simple_polygons [regexp -- {points list of } $compute_help]

  # simplify polygon structure
  set check_empty [string equal $option "empty"]
  if { [llength [lindex [lindex $polygon_info 0] 0]] == 0 } {
    set polygon [lindex [lindex $polygon_info 0] 5]

    # merge polygon
    # (see if compute_polygons works for lists of polygons - avail in icc)
    if { ! $simple_polygons } {
    # compute_polygons takes a list of polygons
      unset -nocomplain in_polygon
      redirect /dev/null {
        catch {set in_polygon [compute_polygons -boolean or $polygon [lindex $polygon 0]]}
      }
      if { [string equal $in_polygon "0"] } {
        set polygon {}
      } else {
        set polygon $in_polygon
      }
    } else {
    # compute_polygons doesn't take a list of more than 1 polygon
      for { set i 0 } { $i < [llength $polygon] } {incr i} {
        for { set j [expr $i + 1] } { $j < [llength $polygon] } {incr j} {
          set new [compute_polygons -boolean or [lindex $polygon $i] [lindex $polygon $j]]
          if { [llength $new] > 1 } {
            continue
          }
          set polygon [lreplace [lreplace $polygon $i $i [lindex $new 0]] $j $j]
          incr i -1
          break
        }
      }
    }
  } else {
    set polygon [lindex [lindex $polygon_info 0] 5]
  }

  if { $check_empty } {
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return [expr [llength $polygon] < 1]
  }

  if { [string equal $option "return_expression"] } {
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return $polygon
  }


  # determine if the polygon is now only a single rectangle
  if { [string equal $option "rectangle"] } {
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return [expr ([llength $polygon]==1) && ([llength [lindex $polygon 0]]==5)]
  }

  # ONLY CHECK remaining is "identical"

  # simplify other_polygon structure for performing "identical" check
  if { [llength [lindex [lindex $polygon_info end] 0]] == 0 } {
    set other_polygon [lindex [lindex $polygon_info end] 5]

    # merge other_polygon
    if { ! $simple_polygons } {
    # compute_polygons takes a list of polygons
      unset -nocomplain in_polygon
      redirect /dev/null {
        catch {set in_polygon [compute_polygons -boolean or $other_polygon [lindex $other_polygon 0]]}
      }
      if { [string equal $in_polygon "0"] } {
        set other_polygon {}
      } else {
        set other_polygon $in_polygon
      }
    } else {
    # compute_polygons doesn't take a list of more than 1 polygon
      for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
        for { set j [expr $i + 1] } { $j < [llength $other_polygon] } {incr j} {
          set new [compute_polygons -boolean or [lindex $other_polygon $i] [lindex $other_polygon $j]]
          if { [llength $new] > 1 } {
            continue
          }
          set other_polygon [lreplace [lreplace $other_polygon $i $i [lindex $new 0]] $j $j]
          incr i -1
          break
        }
      }
    }
  } else {
    set other_polygon [lindex [lindex $polygon_info end] 5]
  }

  # simple check is if one empty, then they both must be empty
  if { ([llength $polygon] == 0) && ([llength $other_polygon] == 0) } {
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return 1
  } elseif { ([llength $polygon] == 0) || ([llength $other_polygon] == 0) } {
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return 0
  }


  # first see if compute_polygons works for lists of polygons
  if { ! $simple_polygons } {
  # compute_polygons takes a list of polygons
    unset -nocomplain xor_polygon
    redirect /dev/null {
      catch {set xor_polygon [compute_polygons -boolean xor $polygon $other_polygon]}
    }
    if { $xor_polygon == "0" } {
      set xor_polygon {}
    }

    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return [expr [llength $xor_polygon] == 0]
  }

   # otherwise to be identical,
   # each piece of polygon must have a corresponding piece of other_polygon
  foreach shape $polygon {
    set poly_and {}
    set poly_xor $polygon
    for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
      set other_shape [lindex $other_polygon $i]
      set poly_and [compute_polygons -boolean and $shape $other_shape]
      if { [llength $poly_and] != 0 } {
        set poly_xor [compute_polygons -boolean xor $shape $other_shape]
        break
      }
    }
    if { [llength $poly_xor] != 0 } {
      set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
      return 0
    }
    set other_polygon [lreplace $other_polygon $i $i]
  }

  # polygon is identical if no remaining portions of other_polygon to match
  set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
  return [expr [llength $other_polygon] == 0]

}

define_proc_attributes P_adv_polygon_check \
  -info "check condition 'option' on polygon" \
  -define_args {
    {option "check option" option one_of_string { required value_help {values { simple complex defined_set rectArray compressed polygon empty rectangle identical }}}}
    {polygon "polygon" polygon string required}
  {other_polygon "second polygon -> only used for identical check" other_polygon string optional}}
  #}}}



proc P_adv_polygon_logic { args } {
  if { [llength $args] == 0 } {
    parse_proc_arguments -args "-help" inputs
  }
  parse_proc_arguments -args $args inputs
  set func_name [string range [lindex [info level [info level]] 0] 2 end]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }

  set operation $inputs(operation)
  namespace eval ::polygon_ops { }
  namespace eval ::polygon_ops::polygon_sets { }

  set copy_set   [string equal $operation "copy"]
  set or_set     [string equal $operation "or"]
  set and_set    [string equal $operation "and"]
  set not_set    [string equal $operation "not"]
  set xor_set    [string equal $operation "xor"]
  set select_set [string equal $operation "select"]

  # return an expression if -list given or polygon is not a defined_set
  set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon_a)])]
  if { $copy_set && $return_expression } {
    error "'$func_name copy': polygon \"$inputs(polygon_a)\" is not a defined_set."
  } else {
    set return_expression [expr $return_expression || [info exists inputs(-list)]]
  }

  # parse polygon information
  set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_a) -list} polygon]
  if {$bad_polygon != 0} {
    if { [string length "$inputs(polygon_a)"] > 50 } {
      regexp {(.*)\s\S+} [string range "$inputs(polygon_a)" 0 49] junk prnt_str
      set prnt_str "$prnt_str ..."
    } else {
      set prnt_str "$inputs(polygon_a)"
    }
    error "'${func_name} $operation': polygon_a \"${prnt_str}\" is not a valid polygon."
    return {}
  }
  set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_b) -list} other_polygon]
  if {$bad_polygon != 0} {
    if { [string length "$inputs(polygon_b)"] > 50 } {
      regexp {(.*)\s\S+} [string range "$inputs(polygon_b)" 0 49] junk prnt_str
      set prnt_str "$prnt_str ..."
    } else {
      set prnt_str "$inputs(polygon_b)"
    }
    error "'${func_name} $operation': polygon_b \"${prnt_str}\" is not a valid polygon."
    return {}
  }

  # return if copy
  if { $copy_set } {
    set ::polygon_ops::polygon_sets::$inputs(polygon_a) $other_polygon
    return {}
  }

  # do simple cases where either polygon is empty
  unset -nocomplain final_polygon
  if { [llength $polygon] == 0 } {
    if { $or_set } {
      set final_polygon $other_polygon
    } elseif { $and_set } {
      set final_polygon {}
    } elseif { $not_set } {
      set final_polygon {}
    } elseif { $xor_set } {
      set final_polygon $other_polygon
    } elseif { $select_set } {
      set final_polygon {}
    }
  } elseif { [llength $other_polygon] == 0 } {
    if { $or_set } {
      set final_polygon $polygon
    } elseif { $and_set } {
      set final_polygon {}
    } elseif { $not_set } {
      set final_polygon $polygon
    } elseif { $xor_set } {
      set final_polygon $polygon
    } elseif { $select_set } {
      set final_polygon {}
    }
  }
  if { [info exists final_polygon] } {
    if { $return_expression } {
      return $final_polygon
    } else {
      set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
      return {}
    }
  }

  # see if extra_braces are used (is so, temporarily disable)
  if { [info exists ::mw_attr_value_extra_braces] } {
    set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
    set ::mw_attr_value_extra_braces false
  } else {
    set orig_mw_attr_value_extra_braces true
  }

  # see if polygon lists are accepted or only simple polygons
  redirect -variable compute_polygons_help {compute_polygons -help}
  set simple_polygons [regexp -- {points list of } $compute_polygons_help]


  # first see if compute_polygons works for lists of polygons
  # can do all operations except select which requires 2 steps
  unset -nocomplain final_polygon
  if { $select_set } { set op "and" } else { set op $operation }
  unset -nocomplain or_polygon

  if { ! $simple_polygons } {
    redirect /dev/null {
      catch {set final_polygon [compute_polygons -boolean $op $polygon $other_polygon]}
    }
    if { (! [info exists final_polygon]) || [string equal $final_polygon "0"] } {
    # compute_polygons didn't take the list of polygons
      set final_polygon {}
    } elseif { $select_set } {
      if { [llength $final_polygon] < [llength $other_polygon] } {
        set other_polygon $final_polygon
      }
      unset -nocomplain final_polygon
    }
  }

  # perform OR operation if needed ("or" & "xor")
  set or_polygon {}
  if { [info exists final_polygon] } {
    set or_polygon $final_polygon
  } elseif { $or_set || $xor_set } {
    set or_polygon [concat $polygon $other_polygon]
    # merge or_polygon
    for { set i 0 } { $i < [llength $or_polygon] } {incr i} {
      for { set j [expr $i + 1] } { $j < [llength $or_polygon] } {incr j} {
        set new [compute_polygons -boolean or [lindex $or_polygon $i] [lindex $or_polygon $j]]
        if { [llength $new] > 1 } {
          continue
        }
        set or_polygon [lreplace [lreplace $or_polygon $i $i [lindex $new 0]] $j $j]
        incr i -1
        break
      }
    }
  }

  # perform AND operation if needed ("and" "not" "xor" "select")
  set and_polygon {}
  set select_polygon {}
  if { [info exists final_polygon] } {
    set and_polygon $final_polygon
  } elseif { $select_set && (! $simple_polygons) } {
    if { [llength $other_polygon] != 0 } {
    # evaluating select in subsets of from 20-50 tend to give best runtimes
      set incr_value 30
      for { set i 0 } { $i < [llength $polygon] } { incr i $incr_value } {
        set sub_range [lrange $polygon $i [expr $i + $incr_value]]
        set sub_range_and [compute_polygons -boolean and $sub_range $other_polygon]
        if { ($sub_range_and == "0") || ([llength $sub_range_and] == 0) } {
        # no intersection, skip this subset of polygons
          continue
        } elseif { [llength $sub_range] == 1 } {
          lappend select_polygon [lindex $sub_range 0]
          continue
        } elseif { [llength $sub_range_and] > [llength $other_polygon] } {
        # try to minimize the number of shapes being worked with
          set sub_range_and $other_polygon
        }
        foreach shape $sub_range {
          set shape_and [compute_polygons -boolean and $shape $sub_range_and]
          if { ($shape_and != "0") && ([llength $shape_and] != 0) } {
            lappend select_polygon $shape
          }
        }
      }
    }
  } elseif { $and_set || $not_set || $xor_set || $select_set } {
    foreach shape $polygon {
      set poly_and {}
      for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
        set other_shape [lindex $other_polygon $i]
        set poly_and [compute_polygons -boolean and $shape $other_shape]
        if { [llength $poly_and] != 0 } {
          if { $select_set } {
            lappend select_polygon $shape
            break
          } else {
            foreach and_item $poly_and {
              lappend and_polygon $and_item
            }
          }
        }
      }
    }
  } elseif { $or_set } {
    set and_polygon $or_polygon
  }

  # perform NOT operation if needed ("not" "xor")
  if { (! [info exists final_polygon]) && ($not_set || $xor_set) } {
    if { $not_set } {
      set final_polygon $polygon
      set not_polygon   $other_polygon
    } else {
      set final_polygon $or_polygon
      set not_polygon   $and_polygon
    }
    foreach other_shape $not_polygon {
      set new_final_polygon {}
      foreach shape $final_polygon {
        foreach not_poly [compute_polygons -boolean not $shape $other_shape] {
          lappend new_final_polygon $not_poly
        }
      }
      set final_polygon $new_final_polygon
    }
  } elseif { $or_set } {
    set final_polygon $or_polygon
  } elseif { $select_set } {
    set final_polygon $select_polygon
  } elseif { $and_set } {
    set final_polygon $and_polygon
  } elseif { ! [info exists final_polygon] } {
    set final_polygon {}
  }

  # return polygon or set value in defined_set
  set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
  if { $return_expression } {
    return $final_polygon
  } else {
    set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
    return {}
  }

}


define_proc_attributes P_adv_polygon_logic \
  -info "perform logic 'operation' between polygons" \
  -define_args {
    {operation "logic operation" operation one_of_string { required value_help {values { copy or and not xor select }}}}
    {polygon_a "polygon_a" polygon_a string required}
    {polygon_b "polygon_b" polygon_b string required}
  {"-list" "return polygon list" "" boolean optional}}
  #}}}

# Proc: P_create_polycheck_grid
# Description: Draws polycheck grid over design that will show up as DRC violations
# if the poly layer is misaligned in any areas. The polycheck is removed over macros/DICs

proc P_create_polycheck_grid { layer start width step stop {hard_macro_refs ""}} {

  set _bndry [get_attribute -quiet [get_die_area] boundary]
  set layer $layer
  remove_user_shape  [get_shapes -quiet -filter layer_name==$layer]

  set rect_box [convert_from_polygon  -format rectangle $_bndry]
  foreach rect $rect_box {
    scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
    set x [expr $start + $b_llx]
    while { $x < [expr $b_urx - $stop]} {
      create_user_shape -layer $layer -bbox [list $x $b_lly [expr $x + $width] $b_ury]
      set x [expr $x + $step + $width]
    }
  }

  # Remove user shapes over HIP/DIC
  set hard_macro_cells ""
  if {$hard_macro_refs == "" } {
    set hard_macro_cells  [all_macro_cells]
  } else {
    foreach cell $hard_macro_refs {
      set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
    }
  }

  if {[sizeof_collection $hard_macro_cells]>0} {
    cut_objects -by $hard_macro_cells [get_shapes -quiet -filter layer_name==$layer]
  }

}
define_proc_attributes P_create_polycheck_grid \
  -info "Creates polycheck grid over design" \
  -define_args { \
                 {layer "Polycheck layer name" layer string required} \
                 {start "Offset to start grid relative to boundary" start string required} \
                 {width "Path to overlay cell gds file" width string required} \
                 {step "Pitch between shapes" step string required} \
                 {stop "Offset to stop grid relative to boundary" stop string required} \
                 {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required} \
}

proc P_placement_blockage_move_or_unmove { {mode report_usage} } {
  global synopsys_program_name

  ###  move placement blockage out of bounds Or back  ###
  if {$mode=="report_usage"} {
    puts "  usage1 ->  set blockage_bbox_pairs \[P_placement_blockage_move_or_unmove move\]; ## to move blockage out of bounds ##";
    puts "  usage2 ->  P_placement_blockage_move_or_unmove \$blockage_bbox_pairs;           ## to restore blockage ##";
    return;
  }
  ###  mode=move - moves blockage and returns blockage_bbox_pairs variable | mode=$blockage_bbox_pairs - restores blockage  ###
  if {$synopsys_program_name == "icc2_shell"} {
    set oldSnapState [get_snap_setting -enabled]; set cnt 0;
    set_snap_setting -enabled false
  } else {
    set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
  }
  if {"$mode"=="move"} {
    set boundary [get_attribute -quiet [get_core_area] boundary]
    set boundary_llx [lindex [lindex [lsort -index 0 -real -increasing $boundary] 0] 0]
    set boundary_lly [lindex [lindex [lsort -index 1 -real -increasing $boundary] 0] 1]
    set hard_pb_llx [expr $boundary_llx - .01]; set hard_pb_lly [expr $boundary_lly - .01]
    set hard_placement_box [list [list $hard_pb_llx  $hard_pb_lly]  [list $boundary_llx $boundary_lly]]
    set blockage_bbox_pairs {}
    foreach_in_collection blkg_obj [remove_from_collection [get_placement_blockages -quiet -filter "name!~boundary_ws*"] [get_placement_blockages -quiet halo_adjacent_placement_blk_*]] {
      lappend blockage_bbox_pairs  [list $blkg_obj [get_attribute -quiet $blkg_obj bbox]]
      set_attribute -quiet $blkg_obj bbox $hard_placement_box
    }
    return $blockage_bbox_pairs;
  } else {
    foreach blkg_pair $mode {
      foreach {blkg_obj blkg_bbox} $blkg_pair { break }
      set_attribute -quiet $blkg_obj bbox $blkg_bbox
    }
  }
  if {$synopsys_program_name == "icc2_shell"} {
    set_snap_setting -enabled $oldSnapState; set flag 1;
  } else {
    set_object_snap_type -enabled $oldSnapState; set flag 1;
  }
}

##########################################################################
# Procedure   : P_insert_pre_place_cells_blockage
#
# Description : To insert the placement blockage at the intended pre-place cells
#               locations if option -as_blockage useage.
#               Otherwise, To insert the placement blockage everywhere except
#               pre-place cells locations
#
# Inputs      :
#
# Returns     :
#
# Note        :
#
##########################################################################
proc P_insert_pre_place_cells_blockage {args} {

  global INTEL_STDCELL_BONUS_GATEARRAY_TILE INTEL_STDCELL_TILE INTEL_TAP_CELL
  parse_proc_arguments -args $args flag
  set func_name [lindex [info level [info level]] 0]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }
  set x_start $flag(-x_start)
  set y_start $flag(-y_start)
  set x_increment $flag(-x_increment)
  set y_increment $flag(-y_increment)
  set width_prplace_cell $flag(-w_preplace_cell)
  set height_prplace_cell $flag(-h_preplace_cell)

  if { [info exists flag(-x_trim)] } {
    set x_trim $flag(-x_trim)
  } else {
    set x_trim 0
  }
  if { [info exists flag(-y_trim)] } {
    set y_trim $flag(-y_trim)
  } else {
    set y_trim 0
  }
  if { [info exists flag(-as_blockage)] } {
    set as_blockage 1
  } else {
    set as_blockage 0
  }
  if { [info exists flag(-ignore_hard_blockage)] } {
    set ignore_hard_blockage 1
  } else {
    set ignore_hard_blockage 0
  }
  if { [info exists flag(-no_flip)] } {
    set no_flip 1
  } else {
    set no_flip 0
  }

  if { [info exists flag(-stagger)] } {
    set stagger 1
  } else {
    set stagger 0
  }

  ### Derive tile widths
  set sample_site [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_TILE"]] 0]
  set stdcell_tile_height [expr [get_attribute [get_site_row $sample_site] bbox_ury] - [get_attribute [get_site_row $sample_site] bbox_lly]]
  set stdcell_tile_width [get_attribute [get_site_rows $sample_site] site_space]
  if { [info exists INTEL_STDCELL_BONUS_GATEARRAY_TILE] } {
    set stdcell_bonus_tile_width [get_attribute [get_site_rows [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_BONUS_GATEARRAY_TILE"]] 0]] site_space]
  }

  if { [info exists flag(-tile)] } {
    if { [regexp "bonuscore" $flag(-tile) ] } {
      set tile_width $stdcell_bonus_tile_width
    } else {
      set tile_width $stdcell_tile_width
    }
  } else {
    set tile_width $stdcell_tile_width
  }

  if { [info exists flag(-ignore_tap_cell)] } {
    set ignore_tap_cell 1
  } else {
    set ignore_tap_cell 0
  }

  ###Find the first ROW rotation
  scan [get_attribute [get_core_areas] bbox] "{%f %f} {%f %f}" core_llx core_lly core_urx core_ury
  set my_site_rows [get_site_rows -quiet -filter "bbox_lly == $core_lly && bbox_ury == [expr $core_lly + $stdcell_tile_height] \
    && site_type ==  $INTEL_STDCELL_TILE"]
  if {$my_site_rows ne ""} {
    set first_cell_orientation [lindex [get_attribute [get_site_rows [lindex $my_site_rows 0]] orientation] 0]
  } else {
    set first_cell_orientation "N"
  }

  set step_y [expr (floor ( [expr $y_increment / ( 2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
  set half_step_y  [expr $step_y / 2.0]
  if { $no_flip == 1 } {
  # Need to find the VSS row
    if { $first_cell_orientation == "N"} {
      set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
    }  else {
      set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
    }
  } else {
    if { $first_cell_orientation == "N"} {
      set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
    }  else {
      set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
    }
  }

  set step_x [expr (floor ( [expr $x_increment / $tile_width] )) *  $tile_width]
  set half_step_x  [expr $step_x / 2.0]
  set xstart [expr (floor ( [expr ($x_start) / $tile_width] )) *  $tile_width + $core_llx]

  remove_placement_blockage _tmp_pre_place_placement_blk_*
  if {[P_is_ICC2]} {
    set_snap_setting -enabled 0
  } else {
    set_object_snap_type -enabled 0
  }

  unset -nocomplain boundary
  set boundary [get_attribute -quiet [get_die_area] boundary]
  # to cover paranoid case of extra braces, remove a set if only 1 point
  if { [llength $boundary] == 1 } { set boundary [lindex $boundary 0] }

  unset -nocomplain all_locations_newpolygon
  unset -nocomplain all_blk_newpolygon
  set all_locations_newpolygon $boundary

  ### Find the original placement blockage
  set original_placement_blks [get_placement_blockages -type hard ]

  ### Find the Voltage area rings
  unset -nocomplain _va_boundary_polys
  unset -nocomplain _tmp_use_polys _tmp_use_polys2
  set _va_boundary_polys ""
  foreach_in_collection _va [get_voltage_areas] {
    set _tmp_use_polys [get_attribute [get_voltage_areas $_va] points]
    set _va_boundary_polys [P_adv_polygon_logic or $_va_boundary_polys \
      [P_adv_polygon_logic not $_tmp_use_polys [P_adv_polygon_size $_tmp_use_polys "-$stdcell_tile_height -$stdcell_tile_height"]]]
  }
  set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_va_boundary_polys]

  ### Find all is_fixed cells
  set _tmp_use_polys {}
  if { $ignore_tap_cell ==1 } {
    foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true && ref_name!=$INTEL_TAP_CELL"] \
      [all_macro_cells]] {
        lappend _tmp_use_polys [get_attribute $c boundary]
    }
  } else {
    foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true"] \
      [all_macro_cells]] {
        lappend _tmp_use_polys [get_attribute $c boundary]
    }
  }
  ### To prevent pre_place cells too close to EBB (might cause density violation)
  set _tmp_use_polys2 {}
  foreach_in_collection c [all_macro_cells] {
    foreach poly_shape [P_adv_polygon_size [get_attribute $c boundary] "[expr 3 * $stdcell_tile_width] 0.0"] {
      lappend _tmp_use_polys2 $poly_shape
    }
  }
  if { ![P_adv_polygon_check empty $_tmp_use_polys2]} {
    set _tmp_use_polys [P_adv_polygon_logic or $_tmp_use_polys $_tmp_use_polys2]
  }
  set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]

  ### Find all existing placement blockages
  set _tmp_use_polys {}
  if { $ignore_hard_blockage != 1 } {
    foreach_in_collection blk $original_placement_blks {
      if { [llength [convert_to_polygon [get_placement_blockage $blk]]] >= 5 } {
        lappend _tmp_use_polys [convert_to_polygon [get_placement_blockage $blk]]
      } elseif { [llength [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]] >= 5 } {
        lappend _tmp_use_polys [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]
      }
    }
    set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
  }

  set switch 0
  set i 0
  set _tmp_use_polys {}
  unset -nocomplain _tmp_area_array
  for {set y $ystart } {$y < $core_ury } {set y [expr $y+$step_y]} {
    if { $stagger == 1 } {
      if { $switch == 1 } {
        set newxstart [expr $xstart + $half_step_x]
        set switch 0
      } else {
        set newxstart $xstart
        set switch 1
      }
    } else {
      set newxstart $xstart
    }

    set core_urx_2 [expr $core_urx - $x_trim]
    for {set x $newxstart } {$x < $core_urx_2 } {set x [expr $x+$step_x]} {
      set x2 [expr $x + $half_step_x]
      if { $half_step_y < $height_prplace_cell } {
        set y2 [expr $y + $height_prplace_cell]
      } else {
        set y2 [expr $y + $half_step_y]
      }
      if {$y2 > [expr $core_ury - $y_trim] } { set y2  $core_ury }
      lappend _tmp_use_polys "{$x $y} {$x $y2} {$x2 $y2} {$x2 $y} {$x $y}"
      set _tmp_area_array($i) "{{$x $y} {$x2 $y2}}"
      incr i
    }
  }
  set all_blk_newpolygon [P_adv_polygon_logic and $all_locations_newpolygon $_tmp_use_polys]

  unset -nocomplain _tmp_use_polys _tmp_use_polys2 my_pgon all_blk_newpolygon_final
  set all_blk_newpolygon_final {}
  foreach _tmp_use_polys $all_blk_newpolygon  {
    unset -nocomplain newbox
    scan [P_adv_polygon_get bbox $_tmp_use_polys] "{%f %f} {%f %f}" _llx _lly _urx _ury
    for {set y $_lly } {$y < $_ury } {set y [expr $y+$stdcell_tile_height]} {
      if { $no_flip == 1 } {
        if { $first_cell_orientation == "N"} {
          set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
        }  else {
          set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
        }
      } else {
        if { $first_cell_orientation == "N"} {
          set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
        }  else {
          set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
        }
      }
      for {set x $_llx } {$x < $_urx } {set x [expr $x+$tile_width]} {
        set snap_x [expr ( ceil ( $x / $tile_width)) * $tile_width + $core_llx]
        set x2 [expr $snap_x + $width_prplace_cell]
        set y2 [expr $snap_y + $height_prplace_cell]
        set _tmp_use_polys2 "{$snap_x $snap_y} {$snap_x $y2} {$x2 $y2} {$x2 $snap_y} {$snap_x $snap_y}"
        set my_pgon [P_adv_polygon_logic and $_tmp_use_polys $_tmp_use_polys2]
        set area_diff [expr [P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)]
        if { [expr (abs ([P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)))] < 0.001 } {
          set all_blk_newpolygon_final [P_adv_polygon_logic or $all_blk_newpolygon_final $my_pgon]
          set x $_urx
          set y $_ury
        }
      }
    }
  }

  remove_placement_blockage _tmp_pre_place_placement_blk_*
  set count 0
  if { $as_blockage != 1 } {
    set all_blk_newpolygon_final [P_adv_polygon_logic not $boundary $all_blk_newpolygon_final]
    foreach my_pgon $all_blk_newpolygon_final {
      foreach box [convert_from_polygon -format rectangle $my_pgon] {
        create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
        incr count
      }
    }
  } else {
    foreach my_pgon $all_blk_newpolygon_final {
      foreach box [convert_from_polygon -format rectangle $my_pgon] {
        create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
        incr count
      }
    }
  }

  set rm_placement_blk_list ""
  foreach i [array names _tmp_area_array] {
    if {([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet]] > 1) ||  \
        ([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet]]  > 1) } {
      set _tmp_placement_blk_list [lsort -unique [get_object_name [add_to_collection \
        [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet ] \
        [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet ]]]]
      set _tmp_placement_blk_list_bb [lsort -command P_compare [get_attribute  [get_placement_blockages $_tmp_placement_blk_list -quiet ] bbox]]
      foreach box [lrange $_tmp_placement_blk_list_bb 1 [expr [llength $_tmp_placement_blk_list] - 1 ]] {
        lappend rm_placement_blk_list [get_object_name [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $box]]
      }
    }
  }
  foreach blk $rm_placement_blk_list {
    remove_placement_blockage $blk
  }

  set_snap_setting -enabled 1
}

define_proc_attributes P_insert_pre_place_cells_blockage \
  -info "insert the placement blockages at pre_place cells location or reverse locations" \
  -define_args {
    {-x_start "Left point of region which cell be pre-placed" x_start float required}
    {-y_start "Bottom point of region which cell be pre-placed" y_start float required}
    {-x_increment "X direction increment distance" x_increment float required}
    {-y_increment "Y direction increment distance" y_increment float required}
    {-x_trim "X direction distance away from core boundary" x_trim float optional}
    {-y_trim "Y direction  distance away from core boundary" y_trim float optional}
    {-w_preplace_cell "Width of the pre-placed cell" w_preplace_cell float required}
    {-h_preplace_cell "Height of the pre-placed cell" h_preplace_cell float required}
    {-as_blockage "Create placement blockage at Pre-place cells locations or reverse locations" "" boolean optional}
    {-ignore_hard_blockage "Ignore the existing hard placement blockage" "" boolean optional}
    {-no_flip "The rotation of pre-place cells as N" "" boolean optional}
    {-stagger "Preplace cells in the stagger pattern" "" boolean optional}
    {-tile "The tile name for the pre_place_cells" tile string optional}
    {-ignore_tap_cell "Ignore the existing tap cells" "" boolean optional}
}

###############################################################################
# Procedure   : P_compare
# Description :

proc P_compare {a b} {
  set a0 [lindex [lindex $a 0] 0]
  set b0 [lindex [lindex $b 0] 0]
  if {$a0 < $b0} {
    return -1
  } elseif {$a0 > $b0} {
    return 1
  }
  set a1 [lindex [lindex $a 0] 1]
  set b1 [lindex [lindex $b 0] 1]
  if {$a1 < $b1 } {
    return -1
  } elseif {$a1  > $b1} {
    return 1
  }
}

################################################################################
# Procedure   : P_adv_polygon_get #{{{
# Description :
#-------------------------------------------------------------------
# __start
# __author: jeheidem
# __proc:  P_adv_polygon_get
# __description:  get 'option' from polygon
#                 polygon can be polygon_set, simple polygon, complex polygon
#                 where polygon_set = defined by variable in
#                                         namespace ::polygon_ops::polygon_sets
#                       simple polygon = list of points with either X or Y
#                                        changing on each point (not both)
#                                        which ends at the starting point
#                       complex polygon = a list of simple polygons
#                       rectArray = a single list of coordinates for ll,ur
#                                   of rectangles forming a polygon.
#                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#                                   where each ll,ur is composed of {x y}
#                       compressed polygon = a simple polygon or single list
#                                            of a complex polygon,
#                                            i.e. join {complex_polygon}
#                 result --- (dependent on option: float or (list of) rectangle
#                       area       = return area of the polygon
#                       bound      = return bounding rectangle of the polygon
#                       rectangles = return list of rectangles of the polygon
# __required_args:  option (one of): area bbox bound rectangles
#                   polygon:         polygon_set, simple or complex polygon
# __optional_args:  -size
#                   if size, then post size the rectangles
#                   (i.e. using 'size' can create overlaps or gaps)
# __end
#-------------------------------------------------------------------
proc P_adv_polygon_get { args } {
  if { [llength $args] == 0 } {
    parse_proc_arguments -args "-help" inputs
  }
  parse_proc_arguments -args $args inputs
  set func_name [string range [lindex [info level [info level]] 0] 2 end]

  if { [get_app_var synopsys_program_name] != {icc_shell} } {
    P_msg_error "$func_name not supported in '[get_app_var synopsys_program_name]'!"
    return
  }
  set option $inputs(option)
  namespace eval ::polygon_ops { }
  namespace eval ::polygon_ops::polygon_sets { }

  # check size argument to see if valid
  if { [info exists inputs(-size)] } {
    set size $inputs(-size)
    # allow for separate x,y size
    # if only a single value, then x,y default to that value
    set xsize [lindex $size 0]
    set ysize [lindex $size end]
    if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
      error "$func_name: size value \"$size\" is not a float or pair of floats."
      unset size xsize ysize
    }
  }

  # parse polygon information
  set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
  if {$bad_polygon != 0} {
    if { [string length "$inputs(polygon)"] > 50 } {
      regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
      set prnt_str "$prnt_str ..."
    } else {
      set prnt_str "$inputs(polygon)"
    }
    error "'${func_name} $option': polygon \"${prnt_str}\" is not a valid polygon."
    return {}
  }

  # see if extra_braces are used (is so, temporarily disable)
  if { [info exists ::mw_attr_value_extra_braces] } {
    set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
    set ::mw_attr_value_extra_braces false
  } else {
    set orig_mw_attr_value_extra_braces true
  }

  # perform area calculation if "area" option, return result
  if { [string equal $option "area"] } {
    set area 0.0

    # see if polygon lists are accepted or only simple polygons
    redirect -variable get_polygon_area_help {get_polygon_area -help}
    set simple_polygons [regexp -- {points list of } $get_polygon_area_help]

    if { $simple_polygons } {
      foreach poly_segment $polygon {
        set area [expr $area + [get_polygon_area $poly_segment]]
      }
    } elseif { [llength $polygon] > 0 } {
      set area [expr $area + [get_polygon_area $polygon]]
    }
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    return $area
  }

  # perform bound check if "bound" option, return resulting rectangle
  if { [string equal $option "bbox"] || [string equal $option "bound"] } {
  # see if polygon is empty
    if { [llength $polygon] < 1 } {
      set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
      return {}
    }

    set joined_polygon [join $polygon]

    # get x extents using a list sort
    set x_sort [lsort -index 0 -increasing -real $joined_polygon]
    set xll [lindex [lindex $x_sort 0] 0]
    set xur [lindex [lindex $x_sort end] 0]

    # get y extents using a list sort
    set y_sort [lsort -index 1 -increasing -real $joined_polygon]
    set yll [lindex [lindex $y_sort 0] 1]
    set yur [lindex [lindex $y_sort end] 1]

    # optionally size the box
    if { [info exists xsize] && [info exists ysize] } {
      set xll [expr $xll - $xsize]
      set yll [expr $yll - $ysize]
      set xur [expr $xur + $xsize]
      set yur [expr $yur + $ysize]
      if { ($xll >= $xur) | ($yll >= $yur) } {
        set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
        return {}
      }
    }
    set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
    if { [string equal $option "bbox"] } {
      return [list [list $xll $yll] [list $xur $yur]]
    } else {
      return [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
    }
  }

  ### only option left is "rectangles"

  # see if polygon lists are accepted or only simple polygons
  redirect -variable convert_from_polygon_help {convert_from_polygon -help}
  set simple_polygons [regexp -- {points list of } $convert_from_polygon_help]

  # create list of rectangles
  if { $simple_polygons } {
    set rectangles {}
    foreach poly_segment $polygon {
      foreach rect [convert_from_polygon -format polygon $poly_segment] {
        lappend rectangles $rect
      }
    }
  } else {
    if { [llength $polygon] == 0 } {
      set rectangles {}
    } else {
      set rectangles [convert_from_polygon -format polygon $polygon]
    }
    if { $rectangles == "0" } {
      set rectangles {}
    }
  }

  # optionally size the box
  if { [info exists xsize] && [info exists ysize] } {
    set sized_rects {}
    foreach rect $rectangles {
      set x_sort [lsort -index 0 -increasing -real $rect]
      set xll [lindex [lindex $x_sort 0] 0]
      set xur [lindex [lindex $x_sort end] 0]
      set y_sort [lsort -index 1 -increasing -real $rect]
      set yll [lindex [lindex $y_sort 0] 1]
      set yur [lindex [lindex $y_sort end] 1]

      # apply sizing
      set xll [expr $xll - $xsize]
      set yll [expr $yll - $ysize]
      set xur [expr $xur + $xsize]
      set yur [expr $yur + $ysize]
      if { ($xll >= $xur) | ($yll >= $yur) } {
        continue
      }
      lappend  sized_rects [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
    }
    set rectangles $sized_rects
  }

  # return list of rectangles
  set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
  return $rectangles

}
define_proc_attributes P_adv_polygon_get \
  -info "get 'option' information from polygon" \
  -define_args {
    {option "get option" option one_of_string { required value_help {values { area bbox bound rectangles }}}}
    {polygon "polygon" polygon string required}
  {"-size" "size (+grow / -shrink)" "" string optional}}
  #}}}


###############################################################
#Procedure: P_create_offgrid_tracks
#Description:  create offgrid width based tracks over specified instances and pins
###############################################################
proc P_create_offgrid_tracks {args} {
  foreach glbl [info globals INTEL_*] {global $glbl}
  parse_proc_arguments -args $args inp

  set rg_name offgrid_keepout
  set skip_rg false 
  set pin *

  if {[info exists inp(-rg_tag)]} {
    set rg_name $inp(-rg_tag)
  }

  if {[info exist inp(-skip_rg)] && $inp(-skip_rg)} {
    set skip_rg true
  } 

  if {[info exists inp(-pins)]} {
    set pin $inp(-pins)
  }

  if {![info exists inp(-cells)] && ![info exists inp(-refs)]} {
    P_msg_info "No options specified. Skip creating any offgrid tracks."
    return 
  } 

  if {[info exists inp(-refs)]} {
    if {$inp(-refs)==""} {
      P_msg_info "Please provide valid list of references"
      return
    } else {
      set fil [join [regsub -all {\S+} $inp(-refs) {ref_name==&}] { || }]
    }
  }

  if {[info exists inp(-cells)]} {
    if {[sizeof_collection [get_cells $inp(-cells)]]==0} {P_msg_info "Please provide valid collection to filter references"; return}
    if {[info exists inp(-refs)]} {
      set inst [filter_collection $inp(-cells) "$fil"]

      if {[sizeof_collection [get_cells $inst]]<=0} {
        P_msg_info "Specified references not found in provided cell collection. Skipping..."; return
      } else { 
        P_msg_info "Processing [sizeof_collection [get_cells $inst]] cells of provided references to create offgrid pin tracks"
      }
    } else {
      set inst $inp(-cells)
      P_msg_info "Processing [sizeof_collection [get_cells $inst]] cells to create offgrid pin tracks"
    }
  } else {
    set inst [get_cells -physical_context * -filter $fil]
    if {[sizeof_collection [get_cells $inst]]<=0} {
      P_msg_info "Specified references not found in design. Skipping..."
      return
    } else {
      P_msg_info "Processing [sizeof_collection [get_cells $inst]] cells of provided references to create offgrid pin tracks"
    }
  }

  if {!$skip_rg} {
    if {[llength [get_routing_guides -quiet $rg_name*]]>0} {
      P_msg_warn "Route guides of specified tag $rg_name exist. Please either remove existing route guides or specify new tags"
      P_msg_warn "Skipped creating offgrid pin tracks!"
      return
    }
  }

  set cnt 1

  foreach_in_collection pinShp [get_shapes -of_objects [get_pins -physical_context -of_objects [get_cells $inst] -filter name=~$pin] -quiet] {
    set layer [get_attribute $pinShp layer]
    set layer_name [get_object_name $layer]

    set dir [P_get_layer_dir $layer]
    set xy [string tolower ${dir}]
    set bbox [get_attr $pinShp bbox]
    scan $bbox {{%f %f} {%f %f}} _llx _lly _urx _ury
    set l [set _ll[set xy]]
    set h [set _ur[set xy]]
    set width [expr $h - $l]
    set coord [expr $l + 0.5*${width}]
    if {$xy=="x"} {
      set x1 [expr $_llx-0.005] ; set y1 $_lly;
      set x2 $_llx              ; set y2 $_ury;
      set x3 $_urx              ; set y3 $_lly;
      set x4 [expr $_urx+0.005] ; set y4 $_ury;
    } else {
      set x1 $_llx ; set y1 [expr $_lly-0.005];
      set x2 $_urx ; set y2 $_lly;
      set x3 $_llx ; set y3 $_ury;
      set x4 $_urx ; set y4 [expr $_ury+0.005];
    }
    # added the "interconnect"condition because of Error: Layer 'v0' is not a routing layer. (DES-112)
    set layer_type [get_attr [get_layer $layer_name] layer_type]
    if {$layer_type == "interconnect"} {
      create_track -layer $layer -bbox ${bbox} -dir ${dir} -coord ${coord}
    }
    #    create_track -width $width -layer $layer -bbox ${bbox} -dir ${dir} -count 1 -coord ${coord}
    if {!$skip_rg} {
      create_routing_blockage -layers $layer -zero_spacing \
        -boundary [list [list $x1 $y1] [list $x2 $y2]] -name_prefix ${rg_name}_${layer}_${cnt}
      incr cnt
      create_routing_blockage -layers $layer -zero_spacing \
        -boundary [list [list $x3 $y3] [list $x4 $y4]] -name_prefix ${rg_name}_${layer}_${cnt}
      incr cnt
    }
  }
}

define_proc_attributes P_create_offgrid_tracks \
  -info "Creates tracks over pins of specified cells" \
  -define_args {
    {"-refs" "Specify a list all references for which you want off gird tracks created. If -cells is also 
      provided then offgrid pin tracks are created for the filtered collection" "" string optional}
    {"-cells" "Creates tracks over specified instances. If used along with -refs switch, the filtered collection 
      is used to create offgrid pin tracks" "" string optional}
    {"-pins" "Pins of cells over which to create tracks" "" string optional}
    {"-rg_tag" "Name of zero spacing route guide created around pins" "" string optional}
    {"-skip_rg" "Skip creating route guides around pins" "" boolean optional}
} 

# Check for violating tiny notches (2 inside corners at both ends of horizontal edges) in stdcell available area formed by merged macro cells and core area with horizontal width < $min_notch_width.
# Gaps (2 vertical edges without same horizontal edge connecting them) are ignored, even if horizontal space < $min_notch_width.  NOTE: See caveat below.
# Abutments among macro cells and with core area acceptable as long as no violating notch formed.
# Placement blockages are not considered for finding notches formed in stdcell available area.
# Vertical heights of notches (2 inside corners at both ends of vertical edges) are not checked.
# Violating notches reported are sorted in increasing order of y-coordinates, and in increasing order of x-coordinates among the same y-coordinate.
# Return number of violating notches, i.e. return 0 if no violating notch found.
# If in GUI, also highlight violating notches on Layout window.
proc P_check_macro_notch_min_width { min_notch_width } {
  set proc_name [namespace tail [lindex [info level 0] 0]]
  set litho_grid 0.001
  if { ![string is double -strict $min_notch_width] || $min_notch_width < [expr $litho_grid * 2] } {
    error "$proc_name: Invalid argument value '$min_notch_width' for minimum notch width!  Expect positive number >= [expr $litho_grid * 2]!"
    return
  }
  if { [sizeof_collection [set core_area [get_core_area]]] == 0 } {
    error "$proc_name: Unable to find core area in design!  Expect design floorplan has been created/initialized!"
    return
  }
  set core_bndry [get_attribute $core_area boundary]
  if { [sizeof_collection [set macro_cells [all_macro_cells]]] > 0 } {
    if { [sizeof_collection [set unplaced_macro_cells [filter_collection $macro_cells {is_placed == false}]]] > 0 } {
      error "$proc_name: Detect [sizeof_collection $unplaced_macro_cells] unplaced macro cells '[get_object_name $unplaced_macro_cells]'!  Expect all macro cells are placed!"
      return
    }
    set core_no_macro_poly_list [compute_polygons -boolean not $core_bndry [convert_to_polygon $macro_cells]]
    set chk_obj_msg "merged boundaries of core area & [sizeof_collection $macro_cells] macro cells"
  } else {
    set core_no_macro_poly_list $core_bndry
    set chk_obj_msg {boundary of core area only since no macro cell in design}
  }
  P_msg_info "$proc_name: Checking for violating notches of horizontal width < $min_notch_width formed by $chk_obj_msg ..."
  if { [set is_in_gui [get_app_var in_gui_session]] } {
    gui_remove_all_annotations -group macro_notch_min_width
  }
  set less_half_min_width [expr $min_notch_width * 0.5 - $litho_grid]
  array unset bad_notch_bbox_2_obj_desc
  # resize_polygon complains MWUI-087 warning if any polygon in list disappears due to shrinkage.
  suppress_message MWUI-087
  if { [llength [set bad_width_poly_list [compute_polygon -boolean not $core_no_macro_poly_list [resize_polygon -size_left $less_half_min_width -size_right $less_half_min_width [resize_polygon -size_left -$less_half_min_width -size_right -$less_half_min_width $core_no_macro_poly_list]]]]] > 0 } {
    set notch_height [expr [get_attribute $core_area tile_height] * 0.5]
    set more_half_notch_height [expr $notch_height * 0.5 + $litho_grid]
    set core_no_macro_no_more_notch_height_poly_list [resize_polygon -size_bottom -$litho_grid -size_top -$litho_grid [set core_no_macro_no_notch_height_poly_list [resize_polygon -size_bottom -$notch_height -size_top -$notch_height $core_no_macro_poly_list]]]
    foreach bad_poly [compute_polygons -boolean not $bad_width_poly_list $core_no_macro_no_notch_height_poly_list] {
      if { [llength [compute_polygons -boolean or $bad_poly $core_no_macro_no_more_notch_height_poly_list]] == [llength $core_no_macro_no_more_notch_height_poly_list] } {
        continue
      }
      set bad_obj_desc_list {}
      set core_no_bad_poly_list [compute_polygons -boolean not $core_bndry $bad_poly]
      if { [llength [compute_polygons -boolean not $core_bndry [compute_polygons -boolean and [resize_polygon -size_left -$less_half_min_width -size_right -$less_half_min_width [resize_polygon -size_left $less_half_min_width -size_right $less_half_min_width $core_no_bad_poly_list]] [resize_polygon -size_bottom -$more_half_notch_height -size_top -$more_half_notch_height [resize_polygon -size_bottom $more_half_notch_height -size_top $more_half_notch_height $core_no_bad_poly_list]]]]] > 0 } {
        lappend bad_obj_desc_list {core area}
      }
      if { [sizeof_collection [set bad_macro_cells [get_cells -quiet -all -intersect $bad_poly -filter {mask_layout_type == macro}]]] > 0 } {
        lappend bad_obj_desc_list "[sizeof_collection $bad_macro_cells] macro cells '[get_object_name $bad_macro_cells]'"
      }
      if { [llength $bad_poly] != 5 } {
        P_msg_error "$proc_name: Internal error: Detect non-rectangular violating notch of polygon '$bad_poly'!  Plese report this issue to ICF."
      }
      # ASSERT: Only 1 rectangle per $bad_poly.  Hence, no need to traverse using loop.
      set bad_notch_bbox_2_obj_desc([lindex [convert_from_polygon -format rectangle $bad_poly] 0]) [join $bad_obj_desc_list { & }]
    }
    foreach bad_bbox [lsort -index {0 1} -real [lsort -index {0 0} -real [array names bad_notch_bbox_2_obj_desc]]] {
      set bad_width [expr [lindex $bad_bbox 1 0] - [lindex $bad_bbox 0 0]]
      P_msg_error "$proc_name: Detect violating notch of horizontal width '$bad_width' at bbox '$bad_bbox' formed by boundaries of $bad_notch_bbox_2_obj_desc($bad_bbox)!  Expect notch width >= $min_notch_width!"
      if { $is_in_gui } {
        set hili_txt "Violating notch of width < $min_notch_width min width:\n Violating horizontal width = $bad_width\n Bbox = $bad_bbox\n Boundaries = $bad_notch_bbox_2_obj_desc($bad_bbox)"
        gui_add_annotation -group macro_notch_min_width -type rect -color orangered -width 3 -line_style DashLine -pattern DiagCrossPattern -info_tip $hili_txt -query_text $hili_txt $bad_bbox
      }
    }
    if { $is_in_gui } {
      set hili_gui_msg {, and highlighted with rectangular markers of orangered color & diagonalcross pattern on Layout window}
    } else {
      set hili_gui_msg {}
    }
    P_msg_error "$proc_name: Total [array size bad_notch_bbox_2_obj_desc] violating notches of horizontal width < $min_notch_width found$hili_gui_msg."
  } else {
    P_msg_info "$proc_name: No violating notch of horizontal width < $min_notch_width found."
  }
  unsuppress_message MWUI-087
  return [array size bad_notch_bbox_2_obj_desc]
}


# Create PG preroute route guides over macros before TPNS in UPF flow.
# Route guides of given layer for a macro are resized based on the bloat margins (x & y) of the layer from $INTEL_MACRO_RG_LIST($macro_reference_name) if defined or default to those of the layer from $INTEL_MACRO_RG_LIST(DEFAULT).
# Route guides of given layer for a macro are skipped if either of the bloat margins is "NA" in $INTEL_MACRO_RG_LIST($macro_reference_name) if defined or $INTEL_MACRO_RG_LIST(DEFAULT).
# Route guides of layers above the top-most layer of a macro are skipped even if defined in $INTEL_MACRO_RG_LIST($macro_reference_name) if defined or $INTEL_MACRO_RG_LIST(DEFAULT).
# Route guides of a macro are skipped if its reference name is among those defined in INTEL_MACRO_EXCLUSION_LIST.
# Route guides of top-most layer of a macro are created as donut-shape, i.e. only the bloat margins without covering the macro.
# Route guides of lower layers of a macro are created as full/cover-shape, i.e. covering the macro with the bloat margins.
proc P_create_upf_macro_pg_route_guide { {route_guide_prefix RG_} {verb_opt 0} } {
  set proc_name [namespace tail [lindex [info level 0] 0]]
  global INTEL_MACRO_EXCLUSION_LIST
  global INTEL_MACRO_RG_LIST
  global INTEL_UPF
  if { ![info exists INTEL_MACRO_RG_LIST] } {
    P_msg_error "$proc_name: Missing required var 'INTEL_MACRO_RG_LIST'!  Check 'project_setup.tcl' file!"
    return
  } elseif { ![info exists INTEL_MACRO_RG_LIST(DEFAULT)] } {
    P_msg_error "$proc_name: Missing required var 'INTEL_MACRO_RG_LIST(DEFAULT)'!  Check 'project_setup.tcl' file!"
    return
  }
  if { ![info exists INTEL_UPF] } {
    P_msg_error "$proc_name: Missing required var 'INTEL_UPF'!  Check 'project_setup.tcl' file!"
    return
  } elseif { !$INTEL_UPF } {
    P_msg_error "$proc_name: Detect value '$INTEL_UPF' defined for var 'INTEL_UPF'!  Expect value '1'!"
    return
  }
  if { ![shell_is_in_upf_mode] } {
    P_msg_error "$proc_name: Detect ICC session in non-UPF mode!  Restart ICC in UPF mode!"
    return
  }
  set err_num 0
  set valid_lyr_sort_list [get_object_name [sort_collection -dictionary [get_layers -filter {is_routing_layer == true && layer_type != via && mask_name =~ metal*} *] mask_name]]
  array unset def_mac_rg_lyr_2_margin
  foreach {lyr_name x_margin y_margin} $INTEL_MACRO_RG_LIST(DEFAULT) {
    if { [sizeof_collection [get_layers -quiet $lyr_name]] == 0 } {
      incr err_num
      P_msg_error "$proc_name: Detect invalid layer '$lyr_name' defined in INTEL_MACRO_RG_LIST(DEFAULT)!  Expect 1 from '$valid_lyr_sort_list'!"
      continue
    } elseif { [lsearch -exact $valid_lyr_sort_list $lyr_name] < 0 } {
      incr err_num
      P_msg_error "$proc_name: Detect non-route layer '$lyr_name' defined in INTEL_MACRO_RG_LIST(DEFAULT)!  Expect 1 from '$valid_lyr_sort_list'!"
      continue
    }
    set good_margin_num 0
    if { $x_margin == {NA} } {
    } elseif { ![string is double -strict $x_margin] } {
      incr err_num
      P_msg_error "$proc_name: Invalid x bloat margin '$x_margin' for layer '$lyr_name' defined in INTEL_MACRO_RG_LIST(DEFAULT)!  Expect number!"
    } else {
      incr good_margin_num
    }
    if { $y_margin == {NA} } {
    } elseif { ![string is double -strict $y_margin] } {
      incr err_num
      P_msg_error "$proc_name: Invalid y bloat margin '$y_margin' for layer '$lyr_name' defined in INTEL_MACRO_RG_LIST(DEFAULT)!  Expect number!"
    } else {
      incr good_margin_num
    }
    if { $good_margin_num >= 2 } {
      set def_mac_rg_lyr_2_margin($lyr_name) "$x_margin $y_margin"
    }
  }
  set all_macro_cells [sort_collection -dictionary [all_macro_cells] full_name]
  if { [sizeof_collection $all_macro_cells] == 0 } {
    P_msg_info "$proc_name: No macro cell found in design for creating PG route guide."
    return 0
  }
  if { [info exists INTEL_MACRO_EXCLUSION_LIST] && [llength $INTEL_MACRO_EXCLUSION_LIST] > 0 } {
    set sel_macro_cells [filter_collection $all_macro_cells "ref_name != [join $INTEL_MACRO_EXCLUSION_LIST { && ref_name != }]"]
    if { [sizeof_collection [set skip_macro_cells [remove_from_collection $all_macro_cells $sel_macro_cells]]] > 0 } {
      set skip_macro_ref_list [lsort -unique -dictionary [get_attribute -quiet $skip_macro_cells ref_name]]
      P_msg_warn "$proc_name: Skip [sizeof_collection $skip_macro_cells] macro cells '[get_object_name $skip_macro_cells]' of [llength $skip_macro_ref_list] references '$skip_macro_ref_list' which are excluded by INTEL_MACRO_EXCLUSION_LIST '$INTEL_MACRO_EXCLUSION_LIST'!"
    }
  } else {
    set sel_macro_cells $all_macro_cells
  }
  if { [sizeof_collection $sel_macro_cells] == 0 } {
    set all_macro_ref_list [lsort -unique -dictionary [get_attribute -quiet $all_macro_cells ref_name]]
    P_msg_warn "$proc_name: No macro cell selected among [sizeof_collection $all_macro_cells] macro cells of [llength $all_macro_ref_list] references in design due to all excluded by INTEL_MACRO_EXCLUSION_LIST '$INTEL_MACRO_EXCLUSION_LIST'!"
    return 0
  }
  set sel_macro_ref_list [lsort -unique -dictionary [get_attribute -quiet $sel_macro_cells ref_name]]
  if { [get_app_var in_gui_session] } {
    set orig_val(gui_suppress_auto_layout) [get_app_var gui_suppress_auto_layout]
    set_app_var gui_suppress_auto_layout true
  }
  array unset macro_ref_2_lyr_list
  array unset macro_ref_2_top_lyr_name
  foreach ref_name $sel_macro_ref_list {
    set cells [filter_collection $sel_macro_cells "ref_name == $ref_name"]
    # ASSERT: All macro instances of the same reference can be on single view only, either FRAM view or CEL view, not mixed.
    set ref_view [lsort -unique -dictionary [get_attribute $cells ref_view_name]]
    if { $ref_view != {FRAM} && $ref_view != {CEL} } {
      incr err_num
      P_msg_error "$proc_name: Unsupported view '$ref_view' for macro reference '$ref_name'!  Skip creating PG route guide for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'!"
      continue
    }
    # Unfortunately, get_mw_cels can't query MW cells from reference libraries.
    if { $verb_opt } {
      P_msg_info "$proc_name: Reading macro layers used from '$ref_name.$ref_view' view for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name' ..."
    }
    set mw_cel [open_mw_cel -readonly $ref_name.$ref_view]
    if { [sizeof_collection $mw_cel] == 0 } {
      incr err_num
      P_msg_error "$proc_name: Failed to open MW '$ref_name.$ref_view'!  Skip creating PG route guide for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'!"
      continue
    }
    # TODO: Find more efficient/faster way to query layers used.
    set ref_lyr_list [lsort -unique -dictionary [get_attribute [add_to_collection [get_terminals -quiet *] [get_shapes -quiet *]] layer]]
    if { $ref_view == {CEL} } {
      set ref_lyr_list [lsort -unique -dictionary "$ref_lyr_list [get_attribute [get_net_shapes -quiet *] layer]"]
    }
    set macro_ref_2_lyr_list($ref_name) [get_object_name [sort_collection -dictionary [get_layers -filter {is_routing_layer == true && layer_type != via && mask_name =~ metal*} $ref_lyr_list] mask_name]]
    close_mw_cel $ref_name.$ref_view
    if { $verb_opt } {
      P_msg_info "$proc_name: Found [llength $macro_ref_2_lyr_list($ref_name)] layers '$macro_ref_2_lyr_list($ref_name)' from '$ref_name.$ref_view' view for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'."
    }
    set macro_ref_2_top_lyr_name($ref_name) [lindex $macro_ref_2_lyr_list($ref_name) end]
  }
  if { [get_app_var in_gui_session] } {
    set_app_var gui_suppress_auto_layout $orig_val(gui_suppress_auto_layout)
  }
  array unset mac_rg_ref_lyr_2_margin
  foreach ref_name $sel_macro_ref_list {
    set cells [filter_collection $sel_macro_cells "ref_name == $ref_name"]
    set raw_lyr_list "$macro_ref_2_lyr_list($ref_name) [array names def_mac_rg_lyr_2_margin]"
    if { [info exists INTEL_MACRO_RG_LIST($ref_name)] } {
      foreach {lyr_name x_margin y_margin} $INTEL_MACRO_RG_LIST($ref_name) {
        if { [sizeof_collection [get_layers -quiet $lyr_name]] == 0 } {
          incr err_num
          P_msg_error "$proc_name: Detect invalid layer '$lyr_name' defined in INTEL_MACRO_RG_LIST($ref_name) for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'!  Expect 1 from '$valid_lyr_sort_list'!"
          continue
        } elseif { [lsearch -exact $valid_lyr_sort_list $lyr_name] < 0 } {
          incr err_num
          P_msg_error "$proc_name: Detect non-route layer '$lyr_name' defined in INTEL_MACRO_RG_LIST($ref_name) for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'!  Expect 1 from '$valid_lyr_sort_list'!"
          continue
        }
        set good_margin_num 0
        if { $x_margin == {NA} } {
        } elseif { ![string is double -strict $x_margin] } {
          incr err_num
          P_msg_error "$proc_name: Invalid x bloat margin '$x_margin' for layer '$lyr_name' defined in INTEL_MACRO_RG_LIST($ref_name) for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'!  Expect number!"
        } else {
          incr good_margin_num
        }
        if { $y_margin == {NA} } {
        } elseif { ![string is double -strict $y_margin] } {
          incr err_num
          P_msg_error "$proc_name: Invalid y bloat margin '$y_margin' for layer '$lyr_name' defined in INTEL_MACRO_RG_LIST($ref_name) for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'!  Expect number!"
        } else {
          incr good_margin_num
        }
        if { $good_margin_num >= 2 } {
          set mac_rg_ref_lyr_2_margin($ref_name,$lyr_name) "$x_margin $y_margin"
          lappend raw_lyr_list $lyr_name
        }
      }
    } elseif { $verb_opt } {
      P_msg_info "$proc_name: No macro-specific override INTEL_MACRO_RG_LIST($ref_name) found for PG route guide bloat margins.  Use default bloat margins from INTEL_MACRO_RG_LIST(DEFAULT) for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'."
    }
    set raw_lyr_sort_list [get_object_name [sort_collection -dictionary [get_layers -filter {is_routing_layer == true && layer_type != via && mask_name =~ metal*} [lsort -unique -dictionary $raw_lyr_list]] mask_name]]
    set top_lyr_idx [lsearch -exact $valid_lyr_sort_list $macro_ref_2_top_lyr_name($ref_name)]
    array unset mac_rg_ref_lyr_2_src
    foreach lyr_name [lrange $valid_lyr_sort_list [lsearch -exact $valid_lyr_sort_list [lindex $raw_lyr_sort_list 0]] [lsearch -exact $valid_lyr_sort_list [lindex $raw_lyr_sort_list end]]] {
      set lyr_idx [lsearch -exact $valid_lyr_sort_list $lyr_name]
      if { $lyr_idx < 0 } {
        incr err_num
        P_msg_error "$proc_name: Internal error: Detect invalid layer '$lyr_name' for macro reference '$ref_name'!  Plese report this issue to ICF."
        continue
      }
      if { [info exists mac_rg_ref_lyr_2_margin($ref_name,$lyr_name)] } {
        set mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) macro-specific
        set mac_rg_ref_lyr_2_src(var,$ref_name,$lyr_name) INTEL_MACRO_RG_LIST($ref_name)
      } elseif { [info exists def_mac_rg_lyr_2_margin($lyr_name)] } {
        set mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) default
        set mac_rg_ref_lyr_2_src(var,$ref_name,$lyr_name) INTEL_MACRO_RG_LIST(DEFAULT)
      } else {
        set mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) skip
        set mac_rg_ref_lyr_2_src(var,$ref_name,$lyr_name) {}
      }
      if { $lyr_idx > $top_lyr_idx } {
        unset -nocomplain mac_rg_ref_lyr_2_margin($ref_name,$lyr_name)
        P_msg_warn "$proc_name: Skip PG route guide layer '$lyr_name' defined in $mac_rg_ref_lyr_2_src(var,$ref_name,$lyr_name) due to above macro top layer '$macro_ref_2_top_lyr_name($ref_name)' for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'."
        continue
      } elseif { $lyr_idx == $top_lyr_idx } {
        set rg_mode donut
      } else {
        set rg_mode cover
      }
      if { $mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) == {skip} } {
        P_msg_info "$proc_name: Skip $rg_mode-shape PG route guide layer '$lyr_name' due to undefined in any INTEL_MACRO_RG_LIST() for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'."
        continue
      } elseif { $mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) == {default} } {
        set mac_rg_ref_lyr_2_margin($ref_name,$lyr_name) $def_mac_rg_lyr_2_margin($lyr_name)
      }
      P_msg_info "$proc_name: Use $mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) bloat margins '$mac_rg_ref_lyr_2_margin($ref_name,$lyr_name)' for $rg_mode-shape PG route guide layer '$lyr_name' from $mac_rg_ref_lyr_2_src(var,$ref_name,$lyr_name) for [sizeof_collection $cells] cells '[get_object_name $cells]' of macro reference '$ref_name'."
    }
  }
  if { $err_num > 0 } {
    P_msg_error "$proc_name: Abort due to $err_num errors above!"
    return
  }
  P_msg_info "$proc_name: Creating PG route guides for [sizeof_collection $sel_macro_cells] macro cells '[get_object_name $sel_macro_cells]' of [llength $sel_macro_ref_list] references '$sel_macro_ref_list' ..."
  remove_route_guide *Macro_Pg:*:*:*-*
  array unset mac_pg_mode_2_rgs
  array set mac_pg_mode_2_rgs {
    donut  {}
    cover  {}
  }
  foreach ref_name $sel_macro_ref_list {
    foreach_in_collection cell [filter_collection $sel_macro_cells "ref_name == $ref_name"] {
      set cell_name [get_object_name $cell]
      set cell_bndry [get_attribute $cell boundary]
      foreach lyr_name [lsort -dictionary [regsub -all -line "^$ref_name," [join [array names mac_rg_ref_lyr_2_margin $ref_name,*] "\n"] {}]] {
        lassign $mac_rg_ref_lyr_2_margin($ref_name,$lyr_name) x_margin y_margin
        if { $lyr_name == $macro_ref_2_top_lyr_name($ref_name) } {
          set rg_mode donut
          set rg_poly_list [compute_polygons -boolean not [resize_polygon -size_left $x_margin -size_bottom $y_margin -size_right $x_margin -size_top $y_margin $cell_bndry] $cell_bndry]
        } else {
          set rg_mode cover
          set rg_poly_list [resize_polygon -size_left $x_margin -size_bottom $y_margin -size_right $x_margin -size_top $y_margin $cell_bndry]
        }
        set rg_idx 0
        foreach poly $rg_poly_list {
          foreach bbox [convert_from_polygon -format rectangle $poly] {
            append_to_collection mac_pg_mode_2_rgs($rg_mode) [create_route_guide -name ${route_guide_prefix}Macro_Pg:$cell_name:$lyr_name:$rg_mode-$rg_idx -no_preroute_layers $lyr_name -coordinate $bbox]
            incr rg_idx
          }
        }
        if { $verb_opt } {
          P_msg_info "$proc_name:   Created $rg_idx PG route guides in $rg_mode shape of layer '$lyr_name' with $mac_rg_ref_lyr_2_src(type,$ref_name,$lyr_name) bloat margins '$x_margin $y_margin' from $mac_rg_ref_lyr_2_src(var,$ref_name,$lyr_name) for macro cell '$cell_name' of reference '$ref_name'."
        }
      }
    }
  }
  P_msg_info "$proc_name: Created total [sizeof_collection $mac_pg_mode_2_rgs(donut)] PG route guides in donut shape of top layers '[lsort -unique -dictionary [join [get_attribute -quiet $mac_pg_mode_2_rgs(donut) no_preroute_layers]]]' & [sizeof_collection $mac_pg_mode_2_rgs(cover)] PG route guides in cover shape of lower layers '[lsort -unique -dictionary [join [get_attribute -quiet $mac_pg_mode_2_rgs(cover) no_preroute_layers]]]' for [sizeof_collection $sel_macro_cells] macro cells '[get_object_name $sel_macro_cells]' of [llength $sel_macro_ref_list] references '$sel_macro_ref_list'."
  return [sizeof_collection [add_to_collection $mac_pg_mode_2_rgs(donut) $mac_pg_mode_2_rgs(cover)]]
}

# Remove PG preroute route guides over macros after TPNS in UPF flow, that were created by create_upf_macro_pg_route_guide proc.
# Also remove any PG strap of top-most layers of macros inside donut-shape route guides marked as {P/G Strap} if exists.
proc P_remove_upf_macro_pg_route_guide { {route_guide_prefix RG_} {verb_opt 0} } {
  set proc_name [namespace tail [lindex [info level 0] 0]]
  global INTEL_UPF
  if { ![info exists INTEL_UPF] } {
    P_msg_error "$proc_name: Missing required var 'INTEL_UPF'!  Check 'project_setup.tcl' file!"
    return
  } elseif { !$INTEL_UPF } {
    P_msg_error "$proc_name: Detect value '$INTEL_UPF' defined for var 'INTEL_UPF'!  Expect value '1'!"
    return
  }
  set rgs [get_route_guides -quiet *Macro_Pg:*:*:*-*]
  set rg_num [sizeof_collection $rgs]
  P_msg_info "$proc_name: Found $rg_num PG route guides of layers '[lsort -unique -dictionary [join [get_attribute -quiet $rgs no_preroute_layers]]]'."
  set donut_rgs [filter_collection $rgs {full_name =~ *Macro_Pg:*:*:donut-*}]
  set donut_rg_desc "[sizeof_collection $donut_rgs] PG route guides in donut shape of top layers '[lsort -unique -dictionary [join [get_attribute -quiet $donut_rgs no_preroute_layers]]]'"
  set cover_rgs [remove_from_collection $rgs $donut_rgs]
  set cover_rg_desc "[sizeof_collection $cover_rgs] PG route guides in cover shape of lower layers '[lsort -unique -dictionary [join [get_attribute -quiet $cover_rgs no_preroute_layers]]]'"
  set err_num 0
  if { [sizeof_collection $donut_rgs] > 0 } {
    set rg_cell_lyr_pair_list [lsort -unique -dictionary [regsub -all -line {^.*Macro_Pg:([^:]*:[^:]*):donut-\d*$} [join [get_object_name $donut_rgs] "\n"] {\1}]]
    foreach cell_name [lsort -unique -dictionary [regsub -all -line {^([^:]*):[^:]*$} [join $rg_cell_lyr_pair_list "\n"] {\1}]] {
      if { [sizeof_collection [set cell [get_cells -quiet -all -filter {mask_layout_type == macro} $cell_name]]] > 0 } {
        foreach lyr_name [lsort -unique -dictionary [regsub -all -line "^$cell_name:" [join [regexp -inline -all -line "^$cell_name:\[^:\]*$" [join $rg_cell_lyr_pair_list "\n"]] "\n"] {}]] {
          set pg_shps [get_net_shapes -quiet -touching [get_attribute $cell boundary] -filter "layer == $lyr_name && ( net_type == Ground || net_type == Power ) && route_type == \"P/G Strap\"" *]
          if { [sizeof_collection $pg_shps] > 0 } {
            set pg_shp_desc "[sizeof_collection $pg_shps] PG net shapes of layer '$lyr_name' & nets '[lsort -unique -dictionary [get_attribute $pg_shps owner_net]]' marked as '[lsort -unique -dictionary [get_attribute $pg_shps route_type]]'"
            remove_net_shape $pg_shps
            P_msg_info "$proc_name: Deleted $pg_shp_desc inside donut-shape PG route guides for macro cell '$cell_name' of reference '[get_attribute $cell ref_name]'."
          } elseif { $verb_opt } {
            P_msg_info "$proc_name: No PG net shape of layer '$lyr_name' marked as '{P/G Strap}' found inside donut-shape PG route guides to delete for macro cell '$cell_name' of reference '[get_attribute $cell ref_name]'."
          }
        }
      } else {
        set cell_rgs [filter_collection $donut_rgs "full_name =~ *Macro_Pg:$cell_name:*:donut-*"]
        incr err_num
        P_msg_error "$proc_name: Unable to find macro cell '$cell_name' for [sizeof_collection $cell_rgs] donut-shape PG route guides '[get_object_name $cell_rgs]'!  Skip deleting PG net shapes inside the route guides!"
      }
    }
  }
  remove_route_guide $rgs
  P_msg_info "$proc_name: Deleted $donut_rg_desc & $cover_rg_desc."
  return $rg_num
}

##########################
# Place-UPF Procedures
##########################

proc P_parse_pwrgrid_params {args} {
  parse_proc_arguments -args $args inputs

  set attribute $inputs(-attribute)
  set layer $inputs(-layer)
  set param_list $inputs(-params)

  set layer_index [lsearch [regexp -inline -all -- {\S+} $param_list] $layer]
  set width_val [lindex $param_list [expr $layer_index + 1]]
  set pitch_val [lindex $param_list [expr $layer_index + 2]]
  set offset_val [lindex $param_list [expr $layer_index + 3]]

  if {$attribute == "offset"} {
    return $offset_val
  } elseif {$attribute == "pitch"} {
    return $pitch_val
  } elseif {$attribute == "width"} {
    return $width_val
  }
}

define_proc_attributes P_parse_pwrgrid_params \
  -info "Parses powergrid parameters to determine offset and pitch values of various layers" \
  -define_args {
    {"-layer"  "Layer for which offset/pitch value is required" "" string required}
    {"-params" "INTEL_ parameter variable that contains layer, pitch and offset values" "" list required}
    {"-attribute" "Specify the attribute to be fetched" "" one_of_string {required value_help {values {offset pitch width}}}}
}

proc P_ret_aon_net {args} {
  parse_proc_arguments -args $args inputs

  set pwr_domain $inputs(-pwr_domain)
  redirect -variable rpt_pd {report_power_domain $pwr_domain}

  set switch_line [regexp -inline -lineanchor -linestop \
    {^Power Switch\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)} $rpt_pd]
  set switch_aon_vcc [lindex $switch_line 5]
  set primary_aon_vcc [lindex $switch_line 8]

  if {$switch_aon_vcc != ""} {
    return $switch_aon_vcc
  } elseif {$primary_aon_vcc != ""} {
    return $primary_aon_vcc
  } else {
    P_msg_error "P_ret_aon_net: Parsing report_power_domain failed. Aborting..."
    return
  }

}

define_proc_attributes P_ret_aon_net \
  -info "Returns the always on power net for the provided power domain" \
  -define_args {
    {"-pwr_domain" "Domain for which the always on power net should be returned" "" string required}
}

proc P_check_sec_pg_overlap {args} {
  parse_proc_arguments -args $args inputs
  set aon_net $inputs(-aon_net)
  set origin_x $inputs(-origin_x)
  set origin_y $inputs(-origin_y)
  set length $inputs(-length)
  set layer $inputs(-layer)
  set width $inputs(-width)

  set vcc_base [get_attribute [get_nets $aon_net -all] base_name]
  set direction [get_attribute [get_layer $layer] preferred_direction]

  if {$direction == "horizontal"} {
    set shape_bbox "{$origin_x [expr $origin_y - [expr $width /2]]} {[expr $origin_x + $length] [expr $origin_y + [expr $width / 2]]}"
  } else {
    set shape_bbox "{[expr $origin_x - [expr $width / 2]] $origin_y} {[expr $origin_x + [expr $width / 2]] [expr $origin_y + $length]}"
  }

  set overlap [get_net_shapes -intersect $shape_bbox -filter "layer == $layer && owner_net != $vcc_base" -quiet]

  if {[sizeof_collection $overlap] == 0} {
    set overlap [get_vias -intersect $shape_bbox -filter "layer =~ *$layer* && owner_net != $vcc_base" -quiet]
  }

  if {[sizeof_collection $overlap] == 0} {
    set overlap [get_route_guides -intersect $shape_bbox -filter "no_signal_layers == $layer || no_preroute_layers == $layer" -quiet]
  }

  if {[sizeof_collection $overlap] > 0} {
    return 1
  } else {
    return 0
  }
}

define_proc_attributes  P_check_sec_pg_overlap \
  -info "Checks to see if sec pg staples overlap with one another" \
  -define_args {
    {"-layer"  "Staple layer" "" string required}
    {"-aon_net"  "AON net name" "" string required}
    {"-origin_x"  "Staple shape llx" "" string required}
    {"-origin_y"  "Staple shape lly" "" string required}
    {"-length"  "Staple length" "" string required}
    {"-width"  "Staple width" "" string required}
}

##############################
# CTS-UPF Procedures
##############################

##########################################################################################################
# Procedure   : P_query_voltage_pgnet
# Description : This proc is to find out the primary pg net for each voltage area for stdcell PG hookup

proc P_query_voltage_pgnet {} {
  global INTEL_VA_PWR INTEL_AON_PWR
  global INTEL_VA_GND

  # determine if power domains are used in the design
  redirect /dev/null {set domains [get_power_domains -hierarchical ] }
  # get list of voltage_areas
  set va_list {}
  foreach_in_collection va [get_voltage_areas] {
    set va_name [get_attribute -quiet $va name]
    lappend va_list $va_name
  }
  unset -nocomplain  INTEL_VA_PWR INTEL_VA_GND INTEL_AON_PWR

  # determine power & ground nets based on whether domains are present
  if { ([info exists domains]) && ([sizeof_collection $domains] > 0) } {
  # power domains exist
  # determine power & ground supplies for each voltage_area

  # check power domains for corresponding voltage_area (then pwr/gnd nets)
    foreach_in_collection domain $domains {
      set domain_name [get_object_name $domain]
      redirect -variable rpt_pd  {report_power_domain $domain}
      set va_line [regexp -inline -lineanchor -linestop {^Voltage Area\s+:\s+(\S+)} $rpt_pd]

      if { ! [llength $va_line] } {
        continue
      } elseif { [string equal "N/A" [lindex $va_line 1]] } {
        continue
      } else {
        set voltage_area [lindex $va_line 1]
      }

      # ensure the voltage_area is defined
      if { [lsearch -exact $va_list $voltage_area] < 0 } { continue }

      # get supply info
      ##MU      set primary_line [regexp -inline -lineanchor -linestop {^\s+Primary\s+:\s+(\S+)(\s+\([^\)]*\))?\s*(\S+)} $rpt_pd]
      set primary_line [regexp -inline -lineanchor -linestop {^\s+Primary\s+:\s+(\S+)\s+(\[\S+\])\s+(\S+)} $rpt_pd]
      if { [llength $primary_line] >= 4 } {
        set INTEL_VA_PWR($voltage_area) [lindex $primary_line 1]
        set INTEL_VA_GND($voltage_area) [lindex $primary_line 3]
      }
      # get AON supply info (if switched)
      set switch_line [join [regexp -inline -lineanchor -linestop {^Power Switch\s+:.*} $rpt_pd]]
      if { [llength $switch_line] >= 4 } {
        set INTEL_AON_PWR($voltage_area) [lindex $switch_line 2]
      } else {
        set INTEL_AON_PWR($voltage_area) $INTEL_VA_PWR($voltage_area)
      }
    }
  }
}

#######################
# Route Procedures
#######################

proc P_bonus_array_blockage {oddeven mode} {
###  add bonus array placement blockage - decap or spacer cell  ###
## oddeven - even_blockage | odd_blockage | remove_blockage ## mode - decap | spacer | spacer_vcnv0
  set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
  set die_area [get_attribute -quiet [get_die_area] bbox];
  regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} $die_area match dllx dlly durx dury; set blkgname "spcrblkg_";
  if {[get_placement_blockages -quiet -filter "name=~${blkgname}_*"] != ""} {
    remove_placement_blockage -name ${blkgname}_*;  ## always remove previous blockage or get name collision ##
  }
  if {$oddeven=="odd_blockage" || $oddeven=="even_blockage"} {
    set offx 0.28
    if {$mode=="decap"} {
      set step 4.48
      set gap 0
      if {$oddeven=="odd_blockage"} {
        set startx [expr 0 + $offx + $step + $gap]
      } else {
        set startx [expr 0 + $offx]
      }
      while {$startx<$durx} {
        create_placement_blockage -bbox "$startx $dlly [expr $startx+$step+$gap] $dury" -name ${blkgname}_${cnt}
        set startx [expr $startx+2*$step+2*$gap];
        incr cnt
      }
    }

    regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} [get_attribute [index_collection  [get_site_rows -filter "site_type==$::INTEL_STDCELL_TILE"] 0] bbox] match llx lly urx ury
    set row_height [expr $ury-$lly]
    if {$oddeven=="even_blockage"} {
      set starty 0
    } else {
      set starty [expr 2*$row_height]
    }
    while {$starty<$dury} {
      create_placement_blockage -bbox "$dllx $starty $durx [expr $starty+2*$row_height]" -name ${blkgname}_${cnt}
      set starty [expr $starty+4*$row_height];
      incr cnt
    }

  }
  set_object_snap_type -enabled $oldSnapState; set flag 1;
}

#######################
# Focal opt Procedures
#######################

proc P_fix_min_cap args {
  global synopsys_program_name
  set DEBUG 0
  # Get arguments passed to this proc
  parse_proc_arguments -args $args results

  # Default values
  set report_timing_cmd "report_timing -slack_lesser_than 0"
  set _iterations 10
  set _threshold -100
  set _reports [list mincap]
  upvar report_timing_cmd _report_timing_cmd

  # Create variables from arguments with this format: $_<argument name>
  foreach _argname [array names results] {
    regsub -- {-} $_argname {_} _varname
    set $_varname $results($_argname)
  }

  # Initialize argument variables
  set iteration_cnt 0
  if {[info exists _report_timing] && $_report_timing == 1} {
    lappend _reports [list timing]
  }
  if {[info exists _fix_dont_touch] && $_fix_dont_touch == 1} {
    set _fix_dont_touch "true"
  } else {
    set _fix_dont_touch "false"
  }
  if {[info exists _fix_cts_fixed] && $_fix_cts_fixed == 1} {
    set _fix_cts_fixed "true"
  } else {
    set _fix_cts_fixed "false"
  }
  if {[info exists _fix_is_fixed] && $_fix_is_fixed == 1} {
    set _fix_is_fixed "true"
  } else {
    set _fix_is_fixed "false"
  }

  # Issue warning if user is in pt_shell
  if {$synopsys_program_name == "pt_shell"} {
    P_msg_warn "User is in pt_shell: Clock cells, fixed cells, and cells not explicitly marked as dont_touch will be modified"
  }

  # Begin iterations for min cap fixing
  P_msg_info "Beignning min cap fixing"
  while {$iteration_cnt < $_iterations} {
    incr iteration_cnt
    P_msg_info "Begin iteration $iteration_cnt"
    P_msg_info "Printing reports..."
    foreach report $_reports {
      if {$report == "mincap"} {
        report_constraint -all_violators -min_capacitance
      }
      if {$report == "timing"} {
        eval $_report_timing_cmd
      }
    }

    # Writing out violations
    P_msg_info "Getting violations..."
    redirect -file ./temp_mincap_rpt.txt {report_constraint -all_violators -min_capacitance -nosplit}
    set noviol 0
    # Grep violations from report
    set rc [catch {eval exec "grep VIOLATED ./temp_mincap_rpt.txt > ./temp_mincap.txt"} output]
    if {$rc == 0} {
      P_msg_info "Successfully grepped violations"
      sh rm ./temp_mincap_rpt.txt
    } else {
      if {[lindex $::errorCode 0] eq "CHILDSTATUS"} {
        if {[lindex $::errorCode 2] == 1} {
          P_msg_info "No violations found"
          # show output with "child process exited abnormally message
          P_msg_info "Exit status: $output"
          # Stop fixing violations
          set noviol 1
          sh rm ./temp_mincap_rpt.txt
          sh rm ./temp_mincap.txt
        } else {
          P_msg_error "grep error: $output"
        }
      } else {
        P_msg_error "error calling grep: $output"
      }
    }

    if {$noviol == 1} {
      set vcnt 0
      set nofixcnt 0
      # No violations found in the file - can skip
      break
    }

    # Parse violations
    P_msg_info "Parsing violations..."
    set fd [open "./temp_mincap.txt" "r"]
    # Violation Count
    set nofixcnt 0
    set vcnt 0
    while {[gets $fd line] > -1} {
    # Get Data
      set sline ""
      foreach item [split $line] {
        if {$item ne ""} { lappend sline $item }
      }

      # In ICC _name is a net, in PT _name is a pin
      set _name [lindex $sline 0]
      set _is_port [sizeof_collection [get_ports $_name -quiet]]
      if {$_is_port} {
        P_msg_info "Skipping net $_name because its driver is a port"
        incr nofixcnt
        continue
      }

      set _net_name $_name
      if {$synopsys_program_name == "pt_shell"} {
        set _net_name [get_object_name [get_nets -of_objects [get_pins $_name]]]
        set _driver [get_cells -of_objects [get_pins $_name]]
      } elseif {$synopsys_program_name == "icc_shell"} {
        set _driver [get_cells -of_objects [get_pins -of_objects [get_nets $_name] -filter "pin_direction==out" -leaf]]
      }

      set _net_dont_touch [get_attribute [get_net $_net_name] is_dont_touch -quiet]
      set _is_macro [get_attribute $_driver is_macro -quiet]
      set _cell_dont_touch [get_attribute $_driver is_dont_touch -quiet]
      set _cell_cts_fixed "false"
      if {$_fix_cts_fixed == "false" && [get_attribute $_driver cts_fixed -quiet] == "true"} {
        set _cell_cts_fixed "true"
      }
      set _cell_is_fixed "false"
      if {$_fix_is_fixed == "false" && [get_attribute $_driver is_fixed -quiet] == "true"} {
        set _cell_is_fixed "true"
      }

      if {$DEBUG} {
        puts "**DEBUG-MSG**> net: $_net_name"
        puts "**DEBUG-MSG**> driver: [get_object_name $_driver]"
      }

      # NO FIX CONDITIONS
      # Driver is a macro
      if {$_is_macro == "true"} {
        P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is a macro ([get_object_name $_driver])"
        incr nofixcnt
        continue
      }
      # Driver has cts_fixed==true attribute
      if {$_cell_cts_fixed == "true"} {
        P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is cts_fixed"
        incr nofixcnt
        continue
      }
      # Driver has is_fixed==true attribute
      if {$_cell_is_fixed == "true"} {
        P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is fixed"
        incr nofixcnt
        continue
      }
      # Driver is dont_touch
      if {$_fix_dont_touch == "false"} {
        if {$_net_dont_touch == "true"} {
          P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is dont_touch"
          incr nofixcnt
          continue
        } elseif {$_cell_dont_touch == "true"} {
          P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because driver [get_object_name $_driver] is dont_touch"
          incr nofixcnt
          continue
        }
      }
      # Output net is a dangling net
      if {[sizeof_collection [all_connected [get_nets $_net_name] -leaf]] <= 1} {
        P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is a dangling net.  Consider waiving this violation"
        incr nofixcnt
        continue
      }

      # Get slack
      if {$_net_dont_touch == "true"} {
        set slack_column 4
      } else {
        set slack_column 3
      }
      set _slack [lindex $sline $slack_column]

      # Don't fix if slack is greater than threshold
      if {[expr $_slack < $_threshold]} {
        P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its slack ($_slack) is greater than the threshold ($_threshold)"
        incr nofixcnt
        continue
      }

      set ref_name [get_attribute $_driver ref_name]
      set base [string replace $ref_name 9 [string length $ref_name]]
      if {$synopsys_program_name == "icc_shell"} { set _attr "name" } else { set _attr "base_name" }
      set libcells [get_attribute [get_lib_cells */$base*] $_attr]
      set libcells [lsort -dictionary -unique $libcells]
      # Find cells and downsize
      set prev ""
      for {set j 0} {[expr $j < [llength $libcells]]} {incr j} {
        set mylibcell [lindex $libcells $j]
        if {$mylibcell == $ref_name} {
          if {$prev == ""} {
            P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is already minimum size."
            incr nofixcnt
          } else {
            P_msg_info "Swapping cell [get_object_name $_driver] from $ref_name to $prev"
            size_cell $_driver $prev
            incr vcnt
          }
          continue
        } else {
          set prev $mylibcell
        }
      }
    }
    sh rm ./temp_mincap.txt
    P_msg_info "Iteration $iteration_cnt complete"
    if {$vcnt == 0} {
      break
    }
  }
  report_constraint -all_violators -min_capacitance
  P_msg_info "Min Cap Fixing complete after $iteration_cnt iterations"
  P_msg_info "$vcnt fixable violations remain"
  P_msg_info "$nofixcnt non-fixable violations remain"
}

#-----------------------------------#
#--- Proc Attributes & Arguments ---#
#-----------------------------------#
define_proc_attributes P_fix_min_cap -info "Fixes mincap violations by down-sizing cells" \
  -define_args { \
                 {-iterations "Max number of downsizing iterations" iterations int optional} \
                 {-threshold  "Slack threshold - violations worse than this  will not be fixed" threshold float optional} \
                 {-report_timing "Prints timing report before each iteration" "" boolean optional} \
                 {-fix_dont_touch "Fix dont_touch nets & instances" "" boolean optional} \
                 {-fix_cts_fixed "Fix cts_fixed cells (Mainly flops)" "" boolean optional} \
                 {-fix_is_fixed "Fix fixed-placement cells" "" boolean optional} \
}


##########################################################################
# Procedure   : P_abstract_to_design
#
# Description : Changes view from abstract to frame
# Inputs      :
#
# Returns     :
##########################################################################
proc P_abstract_to_design {} {
  define_user_attribute -classes cell -persistent -name abstract_cell -type boolean -quiet 

  set abstracts [get_cells -physical_context -filter "ref_view_name == abstract"]
  set_attribute $abstracts abstract_cell true

  set refs [lsort -unique [get_attribute $abstracts ref_name]]
  change_view -view design -reference $refs
}

##########################################################################
# Procedure   : P_abstract_to_frame 
#
# Description : Changes view from abstract to frame
# Inputs      :
#
# Returns     :
##########################################################################
proc P_abstract_to_frame {} {
  define_user_attribute -classes cell -persistent -name abstract_cell -type boolean -quiet 
  set cell_list [get_cells -physical_context -filter "ref_view_name == abstract"]
  set final_list {}
  foreach_in_collection m $cell_list {
    set macro [get_object_name $m]
    set lib_name [get_attribute [get_cells -physical_context  $macro] ref_lib_name]
    set block_name [get_attribute [get_cells -physical_context $macro ] ref_name  ]
    if { [get_blocks -all ${lib_name}:${block_name}.frame -quiet] != "" } {
	append_to_collection final_list $m
    }
  }

  set_attribute $final_list abstract_cell true
  set refs [lsort -unique [get_attribute $final_list ref_name]]
  change_view -view frame -reference $refs
}

##########################################################################
# Procedure   : P_frame_to_abstract 
#
# Description : Changes view from frame to abstract
# Inputs      :
#
# Returns     :
##########################################################################
proc P_frame_to_abstract {} { 
  set cell_list [get_cells -physical_context -filter "is_hard_macro==true || is_soft_macro==true && ref_view_name==frame"]
  set final_list {}
  foreach_in_collection m $cell_list {
    set macro [get_object_name $m]
    set lib_name [get_attribute [get_cells -physical_context  $macro] ref_lib_name]
    set block_name [get_attribute [get_cells -physical_context $macro ] ref_name  ]
    if { [get_blocks -all ${lib_name}:${block_name}.abstract -quiet] != "" } {
	append_to_collection final_list $m
    }
  }

  set refs [lsort -unique [get_attribute $final_list ref_name]]
  change_view -view abstract -reference $refs 
  link -force
}

#######################
# Focal opt Procedures
#######################

proc P_create_viazone_layer args {
  parse_proc_arguments -args $args results
  set layer_list $results(-via_layers)

  set die_boundary [get_attribute [get_die_area] boundary -quiet ]
  set macro_boundary [get_attribute [all_macro_cells] boundary -quiet]

  if {$macro_boundary == ""} {
    set rect_list [convert_from_polygon $die_boundary]
  } else {
    set rect_list [convert_from_polygon [compute_polygons -boolean not $die_boundary $macro_boundary]]
  }

  foreach rect $rect_list {
    scan $rect "{%f %f} {%f %f}" lx ly ux uy
    foreach layer $layer_list {
      create_user_shape -route_type user_enter -bbox "$lx $ly $ux $uy" -layer $layer -datatype 3
    }
  }

}

define_proc_attributes P_create_viazone_layer -info "Creates viazone layer on specified layers excluding macro boundaries" \
  -define_args { \
                 {-via_layers "List of via layers" "" list required} \
}           

#####################
# STA Procedures
#####################

#######################################################################
# Usage: P_report_xtalk_deltas
#
# This procedure reports xtalk delta delays
#######################################################################
suppress_message UIAT-4

proc P_report_xtalk_deltas {args} {
  global sh_dev_null

  set results(nets) {}
  set results(-sort) {}
  set results(-verbose) 0
  parse_proc_arguments -args $args results

  if {$results(nets) == ""} {
    set results(nets) [get_nets -hierarchical *]
  }

  set sort_type $results(-sort)

  set nets [get_nets $results(nets)]
  define_user_attribute -type float -class net dtrans_min_attr
  define_user_attribute -type float -class net dtrans_max_attr
  define_user_attribute -type float -class net delta_min_attr
  define_user_attribute -type float -class net delta_max_attr
  define_user_attribute -type float -class net abs_dtrans_attr
  define_user_attribute -type float -class net abs_delta_attr

  echo ""
  echo ""
  set header [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s" \
    "Net Name" "Abs Dtrans" "Min Dtrans" "Max Dtrans" "Abs Delta" "Min Delta" "Max Delta"]
  echo $header
  echo [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s" \
    "----------" "----------" "----------" "----------" "----------" "----------" "----------"]

  foreach_in_collection this_net $nets {
    set net_loads {}
    set net_drivers {}
    set this_net_name [get_attribute -quiet $this_net full_name]
    set connections [all_connected [get_nets $this_net_name]]
    foreach_in_collection this_connection $connections {
      if {[get_attribute -quiet $this_connection object_class] == "port"} {
        if {[get_attribute -quiet [get_ports $this_connection] direction] == "in"} {
          set net_drivers [add_to_collection $net_drivers [get_ports $this_connection]]
        }
        if {[get_attribute -quiet [get_ports $this_connection] direction] == "out"} {
          set net_loads [add_to_collection $net_loads [get_ports $this_connection]]
        }
      }
      if {[get_attribute -quiet $this_connection object_class] == "pin"} {
        if {[get_attribute -quiet [get_pins $this_connection] direction] == "in"} {
          set net_loads [add_to_collection $net_loads [get_pins $this_connection]]
        }
        if {[get_attribute -quiet [get_pins $this_connection] direction] == "out"} {
          set net_drivers [add_to_collection $net_drivers [get_pins $this_connection]]
        }
      }
    }

    set dtrans_min 0.00000
    set dtrans_max 0.00000
    set delta_min 0.00000
    set delta_max 0.00000
    set report ""
    foreach_in_collection this_load $net_loads {
      if {[get_attribute -quiet $this_load object_class] == "pin"} {
        if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]} {
          set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]
        }
        if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]} {
          set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]
        }
        if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]} {
          set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]
        }
        if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]} {
          set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]
        }
      }
      foreach_in_collection this_net_driver $net_drivers {
        set arcs [get_timing_arcs -from $this_net_driver -to $this_load]
        foreach_in_collection arc $arcs {
          if {$delta_min > [get_attribute -quiet $arc \
              annotated_delay_delta_min_rise]} {
            set delta_min [get_attribute -quiet $arc \
              annotated_delay_delta_min_rise]
          }
          if {$delta_min > [get_attribute -quiet $arc \
              annotated_delay_delta_min_fall]} {
            set delta_min [get_attribute -quiet $arc \
              annotated_delay_delta_min_fall]
          }
          if {$delta_max < [get_attribute -quiet $arc \
              annotated_delay_delta_max_rise]} {
            set delta_max [get_attribute -quiet $arc \
              annotated_delay_delta_max_rise]
          }
          if {$delta_max < [get_attribute -quiet $arc \
              annotated_delay_delta_max_fall]} {
            set delta_max [get_attribute -quiet $arc \
              annotated_delay_delta_max_fall]
          }
        }
      }
      if {$dtrans_min != ""} {
        set dtrans_min_nosign [expr abs($dtrans_min)]
      }
      if {$delta_min != ""} {
        set delta_min_nosign [expr abs($delta_min)]
      }
      set abs_dtrans $dtrans_max
      set abs_delta $delta_max
      if {$dtrans_min_nosign > $dtrans_max} {
        set abs_dtrans $dtrans_min_nosign
      }
      if {$delta_min_nosign > $delta_max} {
        set abs_delta $delta_min_nosign
      }
    }

    if {$dtrans_min == 0.00000 && $dtrans_max == 0.00000 && $delta_min == 0.00000 && \
        $delta_max == 0.00000 && !$results(-verbose)} {
      set_user_attribute -quiet -class net $this_net_name dtrans_min_attr 9999
      continue
    }
    set_user_attribute -quiet -class net $this_net_name dtrans_min_attr $dtrans_min
    set_user_attribute -quiet -class net $this_net_name dtrans_max_attr $dtrans_max
    set_user_attribute -quiet -class net $this_net_name delta_min_attr $delta_min
    set_user_attribute -quiet -class net $this_net_name delta_max_attr $delta_max
    set_user_attribute -quiet -class net $this_net_name abs_dtrans_attr $abs_dtrans
    set_user_attribute -quiet -class net $this_net_name abs_delta_attr $abs_delta
  }

  set temp [filter_collection $nets "dtrans_min_attr != 9999" ]
  set no_crosstalk true
  if {[sizeof_collection $temp] != 0} {
    set temp_sort $temp
    if {$sort_type == "dtrans"} {
      set temp_sort [sort_collection -descending $temp {abs_dtrans_attr}]
    }
    if {$sort_type == "delta"} {
      set temp_sort [sort_collection -descending $temp {abs_delta_attr}]
    }

    foreach_in_collection this_net_to_report $temp_sort {
      set dtrans_min [get_attribute -quiet $this_net_to_report dtrans_min_attr]
      set dtrans_max [get_attribute -quiet $this_net_to_report dtrans_max_attr]
      set delta_min  [get_attribute -quiet $this_net_to_report delta_min_attr]
      set delta_max  [get_attribute -quiet $this_net_to_report delta_max_attr]
      set abs_dtrans [get_attribute -quiet $this_net_to_report abs_dtrans_attr]
      set abs_delta  [get_attribute -quiet $this_net_to_report abs_delta_attr]
      set this_net_to_report_name [get_attribute -quiet $this_net_to_report full_name]
      set output [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s" \
        "$this_net_to_report_name" $abs_dtrans $dtrans_min $dtrans_max $abs_delta $delta_min $delta_max ]
      echo "$output"
    }
    set no_crosstalk false
  }
  if {$no_crosstalk == "true"} {
    echo "No crosstalk effects in this analysis."
  }
  echo "Analysis of [sizeof_collection $nets] net(s) complete."
}


define_proc_attributes P_report_xtalk_deltas \
  -info "reports delta delay and delta transition information for nets" \
  -define_args \
  {
    {-sort "dtrans to sort by absolute value of dtrans or delta to sort by absolute value of delta" "dtrans/delta" one_of_string {value_help {values {dtrans delta}} optional}}
    {-verbose "show all selected nets" "" boolean optional}
    {nets "nets to check" "nets" string optional}
}

#######################################################################
# Usage: P_restore_dmsa_session
#
# This procedure creates dmsa scenarios from a directory of saved sessions
#######################################################################

proc P_restore_dmsa_session {args} {
  parse_proc_arguments -args $args results

  if {[set dirs [glob -nocomplain -type f $results(dir_name)/*/*/lib_map]]
      eq {}} {
    echo "Error: no save_session directories found."
    return 0
  }

  foreach dir $dirs {
    set dir [file dirname $dir]
    set name [file tail $dir]
    regsub "\/$name" $dir "" scenario
    regsub "..\/" $scenario "" scenario
    echo "Defining scenario ${scenario}."

    create_scenario -name $scenario -image $dir
  }
}

define_proc_attributes P_restore_dmsa_session \
  -info "Restores PrimeTime sessions in DMSA" \
  -define_args \
  {
    {dir_name "Dir name to restore from" "dir_name" string required}
}

#######################################################################
# Usage: P_report_qor
#
# This procedure to emulate DC's report_qor in PT
#######################################################################

proc P_report_qor {args} {

  global sh_product_version
  global sh_dev_null
  global report_default_significant_digits
  global synopsys_program_name
  global pt_shell_mode

  set results(-help) "no help"
  set results(-significant_digits) "none"
  set results(-only_violated) "false"
  set results(-summary) "false"

  parse_proc_arguments -args $args results

  if {$results(-help)==""} {
    help -verbose report_qor
    return 1
  }

  if {$results(-significant_digits)=="none"} {
    set significant_digits $report_default_significant_digits
  } else {
    if {$results(-significant_digits) < 0 || $results(-significant_digits) > 13} {
      echo "Error: value '$results(-significant_digits)' not in range (0 to 13). (CMD-019)"
      return 0
    } else {
      set significant_digits $results(-significant_digits)
    }
  }

  proc P_count_levels {path} {
    set levels 0
    set endpoint [get_object_name [get_attribute -quiet $path endpoint]]
    foreach_in_collection point [get_attribute -quiet $path points] {
      set object [get_attribute -quiet $point object]
      if {[get_attribute -quiet $object object_class] == "pin"} {
        if {[get_attribute -quiet $object pin_direction] == "in"} {
          if {[get_attribute -quiet $object is_port] == "false"} {
            if {[get_attribute -quiet $object full_name] != $endpoint} {
              incr levels
            }
          }
        }
      }
    }
    return $levels
  }

  proc P_display_path_group {levels arrival slack cost count significant_digits scenario} {
    echo "  ---------------------------------------------"
    echo [format "  Levels of Logic:%29d$scenario" $levels]
    echo [format "  Critical Path Length:%24.${significant_digits}f$scenario" $arrival]
    if {[regexp {[^a-zA-Z]} $slack full]} {
      echo [format "  Critical Path Slack:%25.${significant_digits}f$scenario" $slack]
    } else {
      echo [format "  Critical Path Slack:            unconstrained$scenario"]
    }
    echo [format "  Total Negative Slack:%24.${significant_digits}f" $cost]
    echo [format "  No. of Violating Paths:%22d" $count]
    echo "  ---------------------------------------------"
  }

  proc P_display_cell_count_and_drcs {hier_cells_count nonhier_cells_count area hier_pins_count nonhier_pins_count cost count drc_list significant_digits scenario} {
    upvar $cost cost_local
    upvar $count count_local
    echo "\n\n  Cell Count"
    echo "  ---------------------------------------------"
    echo [format "  Hierarchical Cell Count:%21d$scenario" $hier_cells_count]
    echo [format "  Hierarchical Port Count:%21d$scenario" $hier_pins_count]
    echo [format "  Leaf Cell Count:%29d$scenario" $nonhier_cells_count]
    echo "  ---------------------------------------------"
    echo "\n\n  Area"
    echo "  ---------------------------------------------"
    echo [format "  Design Area:%33.6f$scenario" $area]
    if {[info exists cost_local(max_area)]} {
      echo [format "  Area Cost:%35.6f" $cost_local(max_area)]
    }
    echo "  ---------------------------------------------"
    echo "\n\n  Design Rule Violations"
    echo "  ---------------------------------------------"
    echo [format "  Total No. of Pins in Design:%17d$scenario" $nonhier_pins_count]
    foreach i $drc_list {
      if {$count_local($i) != 0} {
        set len [expr 38 - [string length $i]]
        echo [format "  $i Count:%${len}d" $count_local($i)]
      }
    }
    set total_cost 0
    foreach i $drc_list {
      if {$cost_local($i) != 0} {
        set len [expr 39 - [string length $i]]
        set total_cost [expr $total_cost + $cost_local($i)]
        echo [format "  $i Cost:%${len}.${significant_digits}f" $cost_local($i)]
      }
    }
    echo [format "  Total DRC Cost:%30.${significant_digits}f" $total_cost]
    echo "  ---------------------------------------------\n"
  }

  if {$synopsys_program_name != "pt_shell"} {
    echo "Error: This script only functions properly in PrimeTime."
    return 0
  }

  set constraint_text ""
  set drc_list ""
  set group_list ""

  if {$pt_shell_mode == "primetime" || $pt_shell_mode == "primetime_slave"} {

    set cost(unconstrained) 0
    set count(unconstrained) 0

    redirect $sh_dev_null {catch {set design [current_design]}}

    if { $design == "" } {
      echo "Error: Current design is not defined. (DES-001)"
      return 0
    }

    echo "\n****************************************"
    echo "Report : qor"
    echo "Design : [get_object_name $design]"
    echo "Version: $sh_product_version"
    echo "Date   : [date]"
    echo "****************************************\n"

    redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}

    foreach line [split $constraint_text "\n"] {
      switch -regexp $line {
        {^.* +([-\.0-9]+) +\(VIOLATED} {
          regexp {^.* +([-\.0-9]+) +\(VIOLATED} $line full slack
          set cost($group) [expr $cost($group) + $slack]
          incr count($group)
          continue
        }
        { *max_delay/setup.*'(.*)'} {
          regexp { *max_delay/setup.*'(.*)'} $line full group
          set cost($group) 0
          set count($group) 0
          continue
        }
        { *min_delay/hold.*'(.*)'} {
          regexp { *min_delay/hold.*'(.*)'} $line full group
          set group ${group}_min
          set cost($group) 0
          set count($group) 0
          continue
        }
        {^ *([a-zA-Z_]+) *$} {
          regexp {^ *([a-zA-Z_]+) *$} $line full group
          if {$group == "recovery" } {
            set group async_default
          }
          if {$group == "removal"} {
            set group async_default_min
          }
          if ![info exists cost($group)] {
            set cost($group) 0
            set count($group) 0
            if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
              lappend drc_list $group
            }
          }
          continue
        }
      }
    }

    set WNS 0.0; set TNS 0.0; set NVP 0;
    set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;

    foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group]] path_group] {
      set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
      if {$path_group == ""} {
        set path_group unconstrained
      }
      if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
        set path_group [string map {\* ""} $path_group]
      }
      if {![info exists cost($path_group)]} {
        set cost($path_group) 0
        set count($path_group) 0
      }

      set levels [P_count_levels $path]

      set slack [get_attribute -quiet $path slack]

      if {$slack < $WNS} { set WNS $slack }
      set TNS [expr $TNS + $cost(${path_group})]
      set NVP [expr $NVP + $count(${path_group})]

      if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
      echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
      P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits ""
    }

    echo ""

    foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group] -delay_type min] path_group] {
      redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
      if {$path_group == ""} {
        set path_group unconstrained
      }
      if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
        set path_group [string map {\* ""} $path_group]
      }
      if {![info exists cost(${path_group}_min)]} {
        set cost(${path_group}_min) 0
        set count(${path_group}_min) 0
      }

      set levels [P_count_levels $path]

      set slack [get_attribute -quiet $path slack]

      if {$slack < $WNS_min} { set WNS_min $slack }
      set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
      set NVP_min [expr $NVP_min + $count(${path_group}_min)]

      if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
      echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
      P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits ""
    }


    if {$results(-summary)} {
      puts "  Summary"
      puts "  ---------------------------------------------"
      puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
      puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
      puts "  ---------------------------------------------"
    }

    set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"]
    set nonhier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == false"]

    P_display_cell_count_and_drcs [sizeof_collection $hier_cells] \
      [sizeof_collection $nonhier_cells] \
      [get_attribute -quiet $design area] \
      [sizeof_collection [get_pins -quiet -of_objects $hier_cells]] \
      [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]] \
      cost \
      count \
      $drc_list \
      $significant_digits \
      ""

  } elseif {$pt_shell_mode == "primetime_master"} {

    global multi_scenario_message_verbosity_level

    set old_verbosity_level $multi_scenario_message_verbosity_level
    set multi_scenario_message_verbosity_level low

    if [info exists constraint_text] {
      unset constraint_text
    }

    if {$sh_product_version=="Z-2007.06"||$sh_product_version=="Z-2007.06-SP1"||$sh_product_version=="Z-2007.06-SP2"||$sh_product_version=="Z-2007.06-SP2-1"} {
      echo "Error: Aborting script execution! Due to a DMSA bug in Z-2007.06 versions prior to Z-2007.06-SP3 (STAR 9000188708),"
      echo "       this script will produce inconsistent and incorrect results. The bug is fixed in Z-2007.06-SP3 PrimeTime."
      echo "       To use this script in DMSA mode, please use Z-2007.06-SP3 or later PrimeTime instead."
      return 0
    }

    echo "\n****************************************"
    echo "Report : qor"
    echo "Design : multi-scenario design"
    echo "Version: $sh_product_version"
    echo "Date   : [date]"
    echo "****************************************\n"

    get_distributed_variables -pre_commands \
      {redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}} \
      constraint_text

    set max_paths [get_timing_paths -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
    set min_paths [get_timing_paths -delay_type min -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]

    set old_scenario_list [current_scenario]

    foreach_in_collection scenario $old_scenario_list {
      set first_scenario_name [get_object_name $scenario]
      break
    }

    current_scenario $first_scenario_name

    get_distributed_variables -pre_commands \
      {set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"]; \
       set nonhier_cells [get_cells -quiet -hieriarchical * -filter "is_hierarchical == false"]; \
       set hier_cells_count [sizeof_collection $hier_cells]; \
       set hier_pins_count [sizeof_collection [get_pins -quiet -of_objects $hier_cells]]; \
       set nonhier_cells_count [sizeof_collection $nonhier_cells]; \
       set nonhier_pins_count [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]]; \
       set area [get_attribute -quiet [current_design] area]; \
    } "hier_cells_count nonhier_cells_count hier_pins_count nonhier_pins_count area"

    current_scenario $old_scenario_list

    set multi_scenario_message_verbosity_level $old_verbosity_level
    set group ""
    foreach scenario [array names constraint_text] {
      foreach line [split $constraint_text($scenario) "\n"] {
        switch -regexp $line {
          {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} {
            regexp {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} $line full object slack
            set object [string trimright $object]
            if ![info exists slack_${group}($object)] {
              set slack_${group}($object) $slack
            } else {
              if [expr $slack < [set slack_${group}($object)]] {
                set slack_${group}($object) $slack
              }
              continue
            }
          }
          { *max_delay/setup.*'(.*)'} {
            regexp { *max_delay/setup.*'(.*)'} $line full group
            if ![info exists slack_$group] {
              array set slack_$group ""
              array set slack_$group ""
              set cost($group) 0
              set count($group) 0
              lappend group_list $group
            }
            continue
          }
          { *min_delay/hold.*'(.*)'} {
            regexp { *min_delay/hold.*'(.*)'} $line full group
            set group ${group}_min
            if ![info exists slack_$group] {
              array set slack_$group ""
              array set slack_$group ""
              set cost($group) 0
              set count($group) 0
              lappend group_list $group
            }
            continue
          }
          {^ *([a-zA-Z_]+) *$} {
            regexp {^ *([a-zA-Z_]+) *$} $line full group
            if {$group == "recovery"} {
              set group async_default
              if ![info exists slack_async_default] {
                lappend group_list async_default
              }
            }
            if {$group == "removal"} {
              set group async_default_min
              if ![info exists slack_async_default_min] {
                lappend group_list async_default_min
              }
            }
            if ![info exists slack_$group] {
              if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
                lappend drc_list $group
              }
              array set slack_$group ""
              array set slack_$group ""
              set cost($group) 0
              set count($group) 0
            }
            continue
          }
        }
      }
    }

    foreach group "$group_list $drc_list" {
      foreach object [array names slack_$group] {
        set cost($group) [expr $cost($group) + [set slack_${group}($object)]]
        incr count($group)
      }
    }

    set WNS 0.0; set TNS 0.0; set NVP 0;
    set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;

    foreach_in_collection path [sort_collection $max_paths path_group] {
      set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
      if {$path_group == ""} {
        set path_group unconstrained
      }
      if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
        set path_group [string map {\* ""} $path_group]
      }
      if {![info exists cost($path_group)]} {
        set cost($path_group) 0
        set count($path_group) 0
      }

      set levels [P_count_levels $path]

      set slack [get_attribute -quiet $path slack]
      set scenario_name [get_attribute $path scenario_name]

      if {$slack < $WNS} { set WNS $slack }
      set TNS [expr $TNS + $cost(${path_group})]
      set NVP [expr $NVP + $count(${path_group})]

      if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
      echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
      P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits " ($scenario_name)"
    }

    echo ""

    foreach_in_collection path [sort_collection $min_paths path_group] {
      redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
      if {$path_group == ""} {
        set path_group unconstrained
      }
      if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
        set path_group [string map {\* ""} $path_group]
      }
      if {![info exists cost(${path_group}_min)]} {
        set cost(${path_group}_min) 0
        set count(${path_group}_min) 0
      }

      set levels [P_count_levels $path]

      set slack [get_attribute -quiet $path slack]
      set scenario_name [get_attribute $path scenario_name]

      if {$slack < $WNS_min} { set WNS_min $slack }
      set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
      set NVP_min [expr $NVP_min + $count(${path_group}_min)]

      if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
      echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
      P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits " ($scenario_name)"
    }

    if {$results(-summary)} {
      puts "  Summary"
      puts "  ---------------------------------------------"
      puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
      puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
      puts "  ---------------------------------------------"
    }

    P_display_cell_count_and_drcs $hier_cells_count($first_scenario_name) \
      $nonhier_cells_count($first_scenario_name) \
      $area($first_scenario_name) \
      $hier_pins_count($first_scenario_name) \
      $nonhier_pins_count($first_scenario_name) \
      cost \
      count \
      $drc_list \
      $significant_digits \
      " ($first_scenario_name)"
  }

}

define_proc_attributes P_report_qor \
  -info "Report QoR" \
  -define_args {\
                {-physical "For compatibility with DC/ICC report_qor; ignored in PrimeTime" "" boolean optional}
              {-significant_digits "Precision level of report (range from 0 to 13)" "<digits>" int optional}
              {-only_violated "Show only violating path groups" "" boolean optional}
              {-summary "QoR Summary report" "" boolean optional}
}

###################################
# Reports and Outputs Procedures
###################################

########################################################################################################
# Procedure   : P_create_xyv_icc
# Description : This proc is used to create top level block's XYV file for RV LTE analysis
#               The xyv file contains rotation, flipping and coordinates information of top
#               level block and all instances within top level block

proc P_create_xyv_icc {args } {

  set topcell_name [get_attribute [current_design] name]
  if { $topcell_name == ""} {
    error "P_create_xyv_icc -ERROR- current design name for top level block is not defined\n"
  }

  parse_proc_arguments -args $args flag

  if {![info exists flag(-step)]} {
    error "P_create_xyv_icc -ERROR- Required APR step is not defined\n"
  } else {
    set step $flag(-step)
  set outputfile "outputs/${topcell_name}.${step}.xyv"}
  set fp [open $outputfile w]

  global mw_attr_value_extra_braces
  #set existing_value_of_extra_braces_var $mw_attr_value_extra_braces
  #set mw_attr_value_extra_braces false

  #############################################
  #xyv for top level block
  #############################################

  set top_xy_coords ""
  if {[P_is_ICC2]} {
    set top_boundary [get_attribute -name boundary -objects [current_block]]
  } else {
    set top_boundary [get_attribute [get_die_area] boundary]
  }
  for {set tcount 0} {$tcount < [expr [llength $top_boundary] - 1]} {incr tcount} {
    set top_firstval [lindex $top_boundary $tcount]
    set top_xmin [lindex $top_firstval 0]
    set top_ymin [lindex $top_firstval 1]
    set top_xmin_nm [expr int($top_xmin*1000)]
    set top_ymin_nm [expr int($top_ymin*1000)]
    append top_xy_coords " $top_xmin_nm $top_ymin_nm"
  }
  puts $fp "$topcell_name $topcell_name 0 0 0 0 $top_xy_coords"

  #############################################
  #xyv for all instances within top level block
  #############################################

  foreach_in_collection cell [get_flat_cells -all] {
    set inst_name [get_attribute $cell full_name]
    set cell_name [get_attribute $cell ref_name]
    set inst_origin_x [lindex [get_attribute $cell origin] 0]
    set inst_origin_y [lindex [get_attribute $cell origin] 1]
    set orientation [get_attribute $cell orientation]
    if {[P_is_ICC2]} {
      if { $orientation eq "R0"} {
        set inst_orient "0 0"
      } elseif {$orientation eq "MX"} {
        set inst_orient "1 0"
      } elseif {$orientation eq "MY"} {
        set inst_orient "2 0"
      } elseif {$orientation eq "R180" } {
        set inst_orient "0 2"
      } else {
        puts "P_create_xyv_icc -ERROR- Invalid orientation is found for instance: $inst_name cell: $cell_name"
      }
    } else {
      if { $orientation eq "N"} {
        set inst_orient "0 0"
      } elseif {$orientation eq "FS"} {
        set inst_orient "1 0"
      } elseif {$orientation eq "FN"} {
        set inst_orient "2 0"
      } elseif {$orientation eq "S" } {
        set inst_orient "0 2"
      } else {
        puts "P_create_xyv_icc -ERROR- Invalid orientation is found for instance: $inst_name cell: $cell_name"
      }
    }
    set inst_xy_coords ""
    set inst_boundary [get_attribute $cell boundary]
    for {set icount 0} {$icount < [expr [llength $inst_boundary] - 1]} {incr icount} {
      set inst_firstval [lindex $inst_boundary $icount]
      set inst_xmin [lindex $inst_firstval 0]
      set inst_ymin [lindex $inst_firstval 1]
      set inst_xmin_nm [expr int($inst_xmin*1000)]
      set inst_ymin_nm [expr int($inst_ymin*1000)]
      append inst_xy_coords " $inst_xmin_nm $inst_ymin_nm"
    }
    puts $fp "${topcell_name}/$inst_name $cell_name $inst_origin_x $inst_origin_y $inst_orient $inst_xy_coords"
  }

  close $fp

  #set mw_attr_value_extra_braces $existing_value_of_extra_braces_var

}

define_proc_attributes P_create_xyv_icc  \
  -info "Used to create top level block's XYV file for RV LTE analysis from ICC database" \
  -define_args {
    {-step "APR Step for which XYV file is created" string string required}
}

#########################################################
# Procedure: P_report_related_supply_net
# Description: Report related supply nets for given ports.

proc P_report_related_supply_net { ports } {
  echo "\n****************************************"
  echo "Report : related_supply_net"
  echo "Design : [current_design_name]"
  echo "Version: $::sh_product_version"
  echo "Date   : [sh date]"
  echo "****************************************\n"
  array set miss_num {
    power  0
    ground 0
  }
  foreach_in_collection port [sort_collection -dictionary $ports full_name] {
    array unset rsn
    redirect $::sh_dev_null {
      set rsn(power) [get_related_supply_net $port]
      set rsn(ground) [get_related_supply_net -ground $port]
    }
    foreach net_type {power ground} {
      if { [sizeof_collection $rsn($net_type)] == 0 } {
        incr miss_num($net_type)
      }
    }
    echo "Port [get_object_name $port] ([get_attribute $port direction]) : power = [get_object_name $rsn(power)] , ground = [get_object_name $rsn(ground)]"
  }
  if { $miss_num(power) > 0 || $miss_num(ground) > 0 } {
    echo "\nERROR: $miss_num(power) of [sizeof_collection $ports] ports missing related power net & $miss_num(ground) of [sizeof_collection $ports] ports missing related ground net!\n"
    return 0
  } else {
    echo {}
    return 1
  }
}

#########################################################
# Procedure: P_reports
# Description:  Writes out report files for SYN, APR, PV

proc P_reports {step} {
  set _start [clock seconds]
  global INTEL_DESIGN_NAME INTEL_UPF INTEL_REPORTS
  global INTEL_INSERT_SCAN INTEL_HARD_MACRO_NAME
  global INTEL_SLACK_LIMIT INTEL_MAX_PATHS INTEL_NWORST
  global synopsys_program_name

  if {[info exists INTEL_MAX_PATHS($step)]} {
    set tmax_paths $INTEL_MAX_PATHS($step)
  } else {
    set tmax_paths 1000
  }
  if {[info exists INTEL_SLACK_LIMIT($step)]} {
    set tslack_limit $INTEL_SLACK_LIMIT($step)
  } else {
    set tslack_limit 9999
  }
  if {[info exists INTEL_NWORST($step)]} {
    set tnworst $INTEL_NWORST($step)
  } else {
    set tnworst 1
  }

  set reports_path ./reports
  set report_timing_options "report_timing -nosplit -capacitance -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
  set check_timing_options "check_timing"


  set rpt_cmd ""
  if {$synopsys_program_name == "pt_shell"} {
    set report_timing_options "report_timing -nosplit -capacitance -crosstalk_delta -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
    set check_timing_options "check_timing -verbose"
  }

  set act_scenarios ""
  if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
    set act_scenarios [all_active_scenarios]
  } 

  if {[info exists INTEL_REPORTS($step)]} {
    foreach report $INTEL_REPORTS($step) {
    #         puts "==>INFORMATION: Generating $report report..."
      switch -exact -- $report {
        lib_files {
          puts "==>INFORMATION: Generating $report report..."
          # dump file paths of libraries and technology data.
          #   resulting file can be run through sha1sum for audit purposes.
          redirect -variable para_rpt { report_parasitic_parameters }
          redirect reports/$INTEL_DESIGN_NAME.$step.$report.txt {
            echo [join [get_attribute -objects [get_libs -quiet] -name source_file_name] "\n"]
            foreach {match subMatch} [regexp -inline -line -all { = (/.*) *$} $para_rpt] {
              echo $subMatch
            }
          }
        }
        area {
          puts "==>INFORMATION: Generating $report report..."
          set hard_macro_area 0.0
          set hard_macro_count 0
          if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
            foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
              foreach_in_collection inst_col [get_cells -hierarchical -filter ref_name==$hard_macro_name] {
                set area [get_attribute $inst_col area]
                set hard_macro_area [expr $hard_macro_area + $area]
                incr hard_macro_count
              }
            }
          }
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
            report_area
            echo "HARD MACRO COUNT= $hard_macro_count"
            echo "HARD MACRO AREA = $hard_macro_area sq. microns"
            report_reference -hierarchy -nosplit
          }
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        qor {
          puts "==>INFORMATION: Generating $report report..."
          if {[regexp {^pt_shell} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_report_qor}\n}\n"
          } else {
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_qor}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            if { $act_scenarios != "" } {
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt {report_qor -summary}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt reports/${INTEL_DESIGN_NAME}.${report}.summary.rpt
            }
          }
        }
        power {
          if {[regexp {^pt_shell} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_power -verbose -nosplit -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
              }
            } else {
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit }
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            }
          }
        }

        clocks {
          puts "==>INFORMATION: Generating $report report..."
          set report_file reports/$INTEL_DESIGN_NAME.$step.$report.rpt
          redirect $report_file { report_clocks -nosplit -skew -attributes }
          sh ln -fs [file tail $report_file] [regsub "\\.$step\\." $report_file .]
        }
        clock_timing {
          puts "==>INFORMATION: Generating $report report..."
          set report_file reports/$INTEL_DESIGN_NAME.$step.$report-transition.rpt
          redirect $report_file { report_clock_timing -type transition -nosplit -nworst 100 -setup }
          sh ln -fs [file tail $report_file] [regsub "\\.$step\\." $report_file .]
          set report_file reports/$INTEL_DESIGN_NAME.$step.$report-latency.rpt
          redirect $report_file { report_clock_timing -type latency -nosplit -nworst 100 -setup }
          sh ln -fs [file tail $report_file] [regsub "\\.$step\\." $report_file .]
        }
        congestion {
          if {[shell_is_in_topographical_mode] || [regexp {^icc} $synopsys_program_name]} {
          # reports estimated routing related congestion after topo mode synthesis.
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_congestion}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          } else {
            puts "==>WARNING: $report report is not supported in this mode."
          }
        }
        multi_vth {
          if {[regexp {^pt_shell} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
          } else {
            P_msg_info "Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        aocvm {
          if {[regexp {^pt_shell} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        lib_cell_purpose {
          puts "==>INFORMATION: Generating $report report..."
          set report_file reports/$INTEL_DESIGN_NAME.$step.$report.rpt
          redirect $report_file { report_lib_cell_purpose }
          sh ln -fs [file tail $report_file] [regsub "\\.$step\\." $report_file .]
        }
        high_fanout {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_net_fanout -high_fanout}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        logic_levels {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_get_logic_levels}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        max_delay {
          if {[regexp {^pt_shell} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.delay.rpt {report_constraint -all_violators -max_delay -nosplit -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.delay.rpt reports/${INTEL_DESIGN_NAME}.delay.rpt
            }
          }
        }
        max_cap {
          if {[regexp {^pt_shell} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.cap.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.cap.rpt reports/${INTEL_DESIGN_NAME}.cap.rpt
            }
          }
        }
        max_tran {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt {report_constraint -all_violators -max_transition -nosplit -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.tran.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tran.rpt reports/${INTEL_DESIGN_NAME}.tran.rpt
            }
          }
        }
        all_violators {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_constraint -all_violators -nosplit -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            }
          }
        }
        timing_setup {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type max}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type max -scenarios $scenario"}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type max"}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            }
          }
        }
        timing_hold {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type min}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type min -scenarios $scenario"}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type min"}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            }
          }
        }
        timing_setup_zeroRC {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  set_zero_interconnect_delay_mode true\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay min}\n set_zero_interconnect_delay_mode false\n}\n"
          } else {
            if {[P_is_ICC]} {
              if { $act_scenarios != "" } {
                foreach scenario [all_active_scenarios] {
                  puts "==>INFORMATION: Generating $report report..."
                  set_zero_interconnect_delay_mode true
                  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -scenarios $scenario"}
                  sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
                  set_zero_interconnect_delay_mode false
                }
              } else {
                puts "==>INFORMATION: Generating $report report..."
                set_zero_interconnect_delay_mode true
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options"}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
                set_zero_interconnect_delay_mode false
              }
            } else {
              if { $act_scenarios != "" } {
                foreach scenario [all_active_scenarios] {
                  puts "==>INFORMATION: Generating $report report..."
                  set_app_options -name time.delay_calculation_style -value zero_interconnect 
                  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -scenarios $scenario"}
                  sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
                  set_app_options -name time.delay_calculation_style -value auto 
                }
              } else {
                puts "==>INFORMATION: Generating $report report..."
                set_app_options -name time.delay_calculation_style -value zero_interconnect 
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options"}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
                set_app_options -name time.delay_calculation_style -value auto
              }
            }
          }
        }
        timing_setup_groups {
          puts "==>INFORMATION: Generating $report report..."
          foreach_in_collection group [get_path_groups] {
            set group_name [get_object_name ${group}]
            regsub -all {\*} $group_name "" group_rpt_name
            regsub -all {\/} $group_rpt_name "-" group_rpt_name
            if {[regexp {^pt} $synopsys_program_name]} {
              set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {$report_timing_options -group $group_name}}\n"
            } else {
              if { $act_scenarios != "" } {
                foreach scenario [all_active_scenarios] {
                  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name -scenarios $scenario"}
                  sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
                }
              } else {
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name"}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_setup_${group_rpt_name}.rpt
              }
            }
          }
        }
        timing_hold_groups {
          puts "==>INFORMATION: Generating $report report..."
          foreach_in_collection group [get_path_groups] {
            set group_name [get_object_name ${group}]
            regsub -all {\*} $group_name "" group_rpt_name
            regsub -all {\/} $group_rpt_name "-" group_rpt_name
            if {[regexp {^pt} $synopsys_program_name]} {
              set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {$report_timing_options -delay_type min -group $group_name}}\n"
            } else {
              if { $act_scenarios != "" } {
                foreach scenario [all_active_scenarios] {
                  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name -scenarios $scenario"}
                  sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
                }
              } else {
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name"}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_hold_${group_rpt_name}.rpt
              }
            }
          }
        }
        timing_loops {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {$report_timing_options -loops}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {eval "$report_timing_options -loops"}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt reports/${INTEL_DESIGN_NAME}.max.timingloops.rpt
          }
        }
        timing_histogram {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -range_maximum 0}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_histogram.rpt {report_timing_histogram -bin_range 25 -scenarios $scenario}
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -bin_range 25}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt reports/${INTEL_DESIGN_NAME}.timing_histogram.rpt
            }
          }
        }
        clock {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock -skew -attributes -nosplit -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            }
          }
        }
        physical {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_design -all}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        clock_tree {
          if { $act_scenarios != "" } {
            foreach scenario [all_active_scenarios] {
              puts "==>INFORMATION: Generating $report report..."
              redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_qor -scenarios $scenario}
              redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup -scenarios $scenario}
              redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup -scenario $scenario }
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
            }
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_qor }
            redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup }
            redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup  }
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        clock_gating {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_gating -ungated -style}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        check_timing {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$check_timing_options}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval $check_timing_options}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        min_pulse_width {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}\n}\n"
          } else {
            if { $act_scenarios != "" } {
              foreach scenario [all_active_scenarios] {
                puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
                redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_min_pulse_width -all_violators -scenarios $scenario}
                sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
              }
            } else {
              puts "==>INFORMATION: Generating $report report..."
              redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}
              sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
            }
          }
        }
        check_zrt_routability {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_zrt_routability -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        drc {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_drc -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
          sh ln -fs ${INTEL_DESIGN_NAME}_${step}_${report}.err reports/${INTEL_DESIGN_NAME}_${report}.err
        }
        lvs {
          puts "==>INFORMATION: Generating $report report..."
          if {$synopsys_program_name == "icc2_shell"} {
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_lvs -max_error 200 -checks {short open}}
          } else {  
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_lvs -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err -max_error 200 -check_short_locator -check_open_locator}
          }
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        check_design {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_design}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        error_info {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}\n}\n"
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt  
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        saif {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_saif -hier -missing -annotated_flag -type gate}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        check_mv_design {
          if { ![info exists INTEL_UPF] } {
            P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
          } elseif { !$INTEL_UPF } {
            P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
          } elseif {$synopsys_program_name == "icc2_shell"} {
            P_msg_info "Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_mv_design}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          } else {
            P_msg_info "Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_mv_design -verbose}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        check_placement_constraints {
          puts "==>INFORMATION: Generating $report report..."
          set report_file reports/$INTEL_DESIGN_NAME.$step.$report.rpt
          redirect $report_file { check_placement_constraints }
          sh ln -fs [file tail $report_file] [regsub "\\.$step\\." $report_file .]
        }
        upf {
          if { ![info exists INTEL_UPF] } {
            P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
          } elseif { !$INTEL_UPF } {
            P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
          } elseif {$synopsys_program_name == "icc2_shell"} {
          # TODO
          } else {
            P_msg_info "Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
              eval report_power_domain [get_power_domains -quiet -hierarchical *]
              eval report_supply_port [get_supply_ports -quiet -hierarchical *]
              eval report_supply_net -include_exception [get_supply_nets -quiet -hierarchical *]
              eval report_power_switch -verbose [get_power_switches -quiet -hierarchical *]
              # Somehow, ICC report_isolation_cell needs associate_mv_cells -isolation_cells.
              report_isolation_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
              # Somehow, ICC report_level_shifter needs domain names instead of domain objects.
              if { $::synopsys_program_name == {icc_shell} } {
                report_level_shifter -verbose -domain [get_object_name [get_power_domains -quiet -hierarchical *]]
              } else {
                report_level_shifter -verbose -domain [get_power_domains -quiet -hierarchical *]
              }
              report_retention_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
              P_report_related_supply_net [get_ports *]
            }
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        check_legality {
          puts "==>INFORMATION: Generating $report report..."
          redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_legality -verbose}
          sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
        }
        threshold_voltage_group {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          }
        }
        vars {

          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {\n    echo \"##### Environment Variables #####\"\n     printenv\n   echo \" \"\n   echo \"##### Flow Related Variables #####\"\n    printvar\n}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {
              echo "##### Environment Variables #####"
              printenv
              echo " "
              echo "##### Flow Related Variables #####"
              printvar
            }
            ################
            # dump file paths of libraries and technology data.
            #   resulting file can be run through sha1sum for audit purposes.
            # libraries
            set libs [get_libs *]
            foreach_in_collection lib $libs {
              set file [get_attribute $lib extended_name]
              set l [split $file ":"]
              lappend names [lindex $l 0]
            }
            set names [lsort -unique $names]
            set f [open "$reports_path/${INTEL_DESIGN_NAME}.${step}.files" "w"]
            foreach n $names {
              puts $f $n
            }
            if {[regexp {icc} $synopsys_program_name] || ([regexp {dc} $synopsys_program_name] && [shell_is_in_topographical_mode])} {
              if {$synopsys_program_name == "icc2_shell"} {
              # tlu files
                set all_tlu_files ""
                redirect -variable tlu_files {report_parasitic_parameters}
                foreach line [split $tlu_files "\n"] {
                  regsub -all {\s+} $line {} line
                  if {[regexp {tluplus=} $line]} {
                    set new_file [lindex [split $line "="] 1]
                    if {[lsearch $all_tlu_files $new_file] == -1} {
                      puts $f $new_file
                      set all_tlu_files "$all_tlu_files $new_file"
                    }
                  }
                }
              } else {
                redirect -variable tlu_files {report_tlu_plus_files}

                foreach line [split $tlu_files "\n"] {
                  regsub -all {\s+} $line {} line
                  if {[regexp {file:} $line]} {
                    puts $f [lindex [split $line ":"] 1]
                  }
                }
              }
              # techfile - ??
            }
            close $f
          }
        }
        flow_vars {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {\n   echo \"#### INTEL_* flow varaibles #####\"\n   printvar INTEL_*\n}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {
              echo "#### INTEL_* flow varaibles #####"
              printvar INTEL_*
            }
          }
        }
        dft_drc {
          if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {dft_drc -coverage_estimate}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          } else {
            puts "==>WARNING: $report report is not supported, since scan was not inserted."
          }
        }
        dft_signal {
          if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_dft_signal}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          } else {
            puts "==>WARNING: $report report is not supported, since scan was not inserted."
          }
        }
        scanpath {
          if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_scan_path}
            sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
          } else {
            puts "==>WARNING: $report report is not supported, since scan was not inserted."
          }
        }
        parasitic_not_annotated_check {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n   redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {report_annotated_parasitics -internal_nets -boundary_nets -list_not_annotated}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {
              report_annotated_parasitics \
                -internal_nets \
                -boundary_nets \
                -list_not_annotated \
            }
          }
        }
        pin_margin   {
          puts "==>INFORMATION: Generating $report report..."
          set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_margin.pv.rpt
          redirect $output_file {echo [format "%-50s %-7s %-7s %-7s %-7s %-4s %-15s" #pin_name max_rise max_fall min_rise min_fall direction cell ]}
          redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
          foreach_in_collection pin [get_pins -hierarchical * -filter "is_hierarchical == false && is_clock_pin == false"] {
            set temp [format "%-50s %7.2f %7.2f %7.2f %7.2f %-4s %-15s" [get_attribute -quiet -class pin $pin full_name] \
              [get_attribute -quiet -class pin $pin max_rise_slack] \
              [get_attribute -quiet -class pin $pin max_fall_slack] \
              [get_attribute -quiet -class pin $pin min_rise_slack] \
              [get_attribute -quiet -class pin $pin min_fall_slack] \
              [get_attribute -quiet -class pin $pin direction] \
              [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]

            redirect -append $output_file { echo $temp}
          }
        }
        pin_attribute {
          puts "==>INFORMATION: Generating $report report..."
          set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_pin_attribute.pv.rpt
          redirect $output_file {echo [format "%60s %14s" #RISE_TRAN FALL_TRAN]}
          redirect -append $output_file {echo [format "%-50s %-6s %-6s %-6s %-6s %-4s %-15s" #pin_name max  min  max  min  arr_window  cell]}
          redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
          foreach_in_collection pin [get_pins -hierarchical * ] {
            set temp [format "%-50s %5.2f %5.2f %5.2f %5.2f %-50s %-15s" [get_attribute -quiet -class pin $pin full_name] \
              [get_attribute -quiet -class pin $pin actual_rise_transition_max] \
              [get_attribute -quiet -class pin $pin actual_rise_transition_min] \
              [get_attribute -quiet -class pin $pin actual_fall_transition_max] \
              [get_attribute -quiet -class pin $pin actual_fall_transition_min] \
              [get_attribute -quiet -class pin $pin arrival_window] \
              [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
            redirect -append $output_file { echo $temp }
          }
        }
        net_attribute {
          puts "==>INFORMATION: Generating $report report..."
          set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_net_attribute.pv.rpt
          redirect output_file {echo [format "%40s " #CAPACITANCE_MAX# ]}
          redirect -append $output_file {echo [format "%-20s %-7s %-7s %-7s %-7s %-4s %-15s" #net wire pin Total R_max lth_H  lth_V]}
          redirect -append $output_file {echo "#------------------------------------------------------------------------------------------------"}
          foreach_in_collection hn [get_nets -hierarchical * ] {
            set tmp_val [get_attribute -quiet -class net $hn x_coordinate_max]
            if {[info exists tmp_val] && $tmp_val == ""} {
              set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-5s %-5s" [get_attribute -quiet -class net $hn full_name] \
                [get_attribute -quiet -class net $hn wire_capacitance_max] \
                [get_attribute -quiet -class net $hn pin_capacitance_max] \
                [get_attribute -quiet -class net $hn total_capacitance_max] \
                [get_attribute -quiet -class net $hn net_resistance_max] \
                --- ---]
            } else {
              set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-9.2s %-9.2s" [get_attribute -quiet -class net $hn full_name] \
                [get_attribute -quiet -class net $hn wire_capacitance_max] \
                [get_attribute -quiet -class net $hn pin_capacitance_max] \
                [get_attribute -quiet -class net $hn total_capacitance_max] \
                [get_attribute -quiet -class net $hn net_resistance_max] \
                [expr {[get_attribute -quiet -class net $hn x_coordinate_max] - [get_attribute -quiet -class net $hn x_coordinate_min]}] \
                [expr {[get_attribute -quiet -class net $hn y_coordinate_max] - [get_attribute -quiet -class net $hn y_coordinate_min]}]]
            }
            redirect -append $output_file { echo $temp }
          }
        }
        noise_all_vio {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators -slack_type height -nosplit}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators \
                                                                                 -verbose \
                                                                                 -slack_type height \
                                                                               -nosplit }
          }
        }
        noise_below {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below \
                                                                               -verbose \
                                                                               -slack_type height \
                                                                               -nworst 10000 \
                                                                             -nosplit }
          }
        }
        noise_above {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above \
                                                                               -verbose \
                                                                               -slack_type height \
                                                                               -nworst 10000 \
                                                                             -nosplit }
          }
        }
        check_noise {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity} -beyond_rail -verbose}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity} \
                                                                             -verbose }
          }
        }
        max_analysis_coverage {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage -status_details untested -check_type \"setup recovery clock_gating_setup out_setup\" -exclude_untested \"user_disabled false_paths constant_disabled\" -sort_by name -nosplit}\n}\n"
          } else {
            puts "==>INFORMATION: Generating $report report..."
            redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage \
                                                                                         -status_details untested \
                                                                                         -check_type "setup recovery clock_gating_setup out_setup" \
                                                                                         -exclude_untested "user_disabled false_paths" \
                                                                                         -sort_by name \
                                                                                       -nosplit }
          }
        }
        switching_activity {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.switching_activity.rpt {report_switching_activity}\n}\n"
          }
        }

        hier_switching_activity {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"  redirect $reports_path/${INTEL_DESIGN_NAME}.hier.switching_activity.rpt { report_switching_activity -hierarchy}\n}\n"
          }
        }
        missing_power_tables {
          if {[regexp {^pt} $synopsys_program_name]} {
            set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.no_power_table.rpt {check_power -verbose  -override_defaults missing_table }\n}\n"
          }
        }
        utilization {
          puts "==>INFORMATION: Generating $report report..."
          set report_file reports/$INTEL_DESIGN_NAME.$step.$report.rpt
          redirect $report_file { report_utilization -verbose }
          sh ln -fs [file tail $report_file] [regsub "\\.$step\\." $report_file .]
        }
        default {
          puts "==>WARNING: The defined report \"$report\" is not configured at $step in the default flow."
        }
      }
    }
  } else {
    puts "==>WARNING: No reports are defined at $step step in the default flow."
  }

  if {[regexp {^pt} $synopsys_program_name]} {
    set rpt_cmd "parallel_execute -commands_only {\n $rpt_cmd }"
    echo $rpt_cmd
    eval $rpt_cmd
  }
  set _end [clock seconds]
  P_msg_info "Runtime for reports: [expr ($_end - $_start)/60.0] minutes"

}

### procedure get_logic_levels takes in the output of "get_timing_path"
proc P_get_logic_levels {args} {
  parse_proc_arguments -args $args results
  if {[info exists results(-paths)] && $results(-paths) != ""} {
    set paths $results(-paths)
  } elseif {[info exists results(-gtp_options)] && $results(-gtp_options) != ""} {
    set paths [eval get_timing_paths $results(-gtp_options)]
  } else {
    set paths [get_timing_paths -max_paths 25]
  }
  puts "\nPrining logic levels per start/end point\n"
  puts "Startpoint, Endpoint, # of logic cells, slack"
  puts "============================================="
  foreach_in_collection path $paths {
    set slack [get_attribute $path slack]
    set startpoint [get_object_name [get_attribute $path startpoint]]
    set endpoint [get_object_name [get_attribute $path endpoint]]
    set points [get_attribute $path points]
    set cells {}
    foreach_in_collection point $points {
      set obj [get_attribute $point object]
      set obj_class [get_attribute $obj object_class]
      set dir [get_attribute $obj direction]
      if {$dir == "in" && $obj_class == "pin" } {
        set cells [add_to_collection $cells [get_cells -of_objects $obj -filter "@is_combinational == true"]]
      }
    }
    puts "$startpoint, $endpoint, [sizeof_collection $cells], $slack"
  }
}

define_proc_attributes P_get_logic_levels \
  -info "Prints logic levels in a start/end point pair" \
  -define_args {
    {-paths "output of get_timing_paths command" timing_paths string optional}
    {-gtp_options "options to be used by get_timing_paths command" get_timing_path_options string optional}
}

## procedure to create PG terminals on the entire strap of top metal layer to ensure correct FRAM creation
proc P_create_pg_terminals {} {
  global INTEL_MAX_PG_LAYER
  global INTEL_TERM_LENGTH

  set pports [get_ports -all -filter "port_type=~*Power* || port_type=~*Ground*"]

  # Remove existing terminals
  set top_layer [string map {m ""} $INTEL_MAX_PG_LAYER]
  set filter_exp "layer!=tm1 && layer!=c4b"
  for {set i [expr $top_layer + 1]} {[expr $i <= 12]} {incr i} {
    set filter_exp "$filter_exp && layer!=m${i}"
  }
  remove_terminal [get_terminals -of_objects $pports -filter "$filter_exp"]

  # Create new terminals
  set all_pg_nets [get_net_shapes -of_objects [get_nets -all -of_objects $pports] -filter "route_type==pg_strap"]
  set top_layer_nets [filter_collection $all_pg_nets "layer==$INTEL_MAX_PG_LAYER"]
  set other_nets [remove_from_collection $all_pg_nets $top_layer_nets]

  # Terminals half DR in size
  foreach {metal stub} $INTEL_TERM_LENGTH {
    set stub_size($metal) [expr $stub / 2]
  }

  # Get vertical/horizontal edges
  set boundary [get_attribute [get_die_area] boundary]
  set vert_edges ""
  set horz_edges ""
  set first 1
  foreach point $boundary {
    if {$first} {
      set first 0
    } else {
    #  puts "point:$point, prev:$prev"
      if {[lindex $point 0] == [lindex $prev 0]} {
      # X didn't change, vertical edge
        lappend vert_edges [format "%.3f" [lindex $point 0]]
      } else {
        lappend horz_edges [format "%.3f" [lindex $point 1]]
      }
    }
    set prev $point
  }

  set first_layer 5
  for {set i 5} {[expr $i < [string map {m ""} $INTEL_MAX_PG_LAYER]]} {incr i} {
  # Create terminal stubs
    set layer "m${i}"
    P_msg_info "Creating terminals on layer $layer"
    foreach_in_collection net_shape [filter_collection $other_nets "layer==$layer"] {
      scan [get_attribute $net_shape bbox] "{%f %f} {%f %f}" llx lly urx ury
      if {[get_attribute [get_layer $layer] preferred_direction] == "horizontal"} {
      # L/R sides
        if {[lsearch $vert_edges [format "%.3f" $llx]] > -1} {
          set bbox1 [list $llx $lly [expr $llx + $stub_size($layer)] $ury]
          create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
        }
        if {[lsearch $vert_edges [format "%.3f" $urx]] > -1} {
          set bbox2 [list [expr $urx - $stub_size($layer)] $lly $urx $ury]
          create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
        }
      } else {
      # T/B sides
        if {[lsearch $horz_edges [format "%.3f" $lly]] > -1} {
          set bbox1 [list $llx $lly $urx [expr $lly + $stub_size($layer)]]
          create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
        }
        if {[lsearch $horz_edges [format "%.3f" $ury]] > -1} {
          set bbox2 [list $llx [expr $ury - $stub_size($layer)] $urx $ury]
          create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
        }
      }
      #      create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
      #      create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
    }
  }

  # Terminals of top metal layers
  P_msg_info "Creating terminals on layer $INTEL_MAX_PG_LAYER"
  foreach_in_collection net_shape $top_layer_nets {
    create_terminal -bbox [get_attribute $net_shape bbox] -layer $INTEL_MAX_PG_LAYER -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
  }

  proc P_poly2bbox {polygon} {
    return [join [list [lindex $polygon 0] [lindex $polygon 2]] " "]
  }

  foreach_in_collection pin_shape [get_pin_shapes -of_objects [get_pins -all -of_objects [all_macro_cells ] -filter "pin_type=~*Power* || pin_type=~*Ground*" -quiet] -filter "layer==$INTEL_MAX_PG_LAYER" -quiet] {
    set port [get_ports -all -of_objects [get_nets -all [get_attribute [get_pins -all -of_objects $pin_shape -quiet] net_name -quiet] -quiet] -quiet]
    if {[sizeof_collection $port] > 0} {
      set points [get_attribute $pin_shape points]
      set plength [llength $points]
      if {[expr $plength % 5] == 0} {
        for {set pi 0} {[expr $pi < $plength]} {set pi [expr $pi + 5]} {
          set ppoints [lrange $points $pi [expr $pi + 4]]
          create_terminal -bbox [P_poly2bbox $ppoints] -layer $INTEL_MAX_PG_LAYER -port $port -no_snap
        }
      }
    }
  }
}

proc P_outputs_linkname {} {
  global synopsys_program_name
  if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
    set ::output_linkname syn
  } else {
    set ::output_linkname apr
  }
}

proc P_outputs_verilog {step} {
  global INTEL_DESIGN_NAME
  global synopsys_program_name
  global output_linkname
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.vg
  if {$synopsys_program_name == "icc2_shell"} {
    write_verilog -exclude {scalar_wire_declarations leaf_module_declarations supply_statements} -compress gzip $output_file
    set suffix .gz
  } else {
    if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
      write_file -format verilog -hierarchy -output $output_file
    } else {
      write_verilog -diode_ports -no_physical_only_cells -no_core_filler_cells -no_tap_cells -unconnected_ports $output_file
    }
    set suffix {}
  }
  puts "==>INFORMATION: Output file: $output_file$suffix"
  sh ln -fs [file tail $output_file$suffix] [regsub "\\.$step\\." $output_file$suffix ".$output_linkname."]
}

proc P_outputs_verilog_pg {step} {
  global INTEL_DESIGN_NAME
  global synopsys_program_name
  global output_linkname
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}_lvs.vg
  if {$synopsys_program_name == "icc_shell"} {
      write_verilog -pg -diode_ports -unconnected_ports -output_net_name_for_tie $output_file
  } elseif {$synopsys_program_name == "icc2_shell"} {
	  write_verilog -include {pg_netlist pg_objects} $output_file
  }
  puts "==>INFORMATION: Output file: ${output_file}"
  sh ln -fs ${INTEL_DESIGN_NAME}.${step}_lvs.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}_lvs.vg
}

proc P_outputs_upf {step} {
  global INTEL_DESIGN_NAME
  global output_linkname
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.upf
  save_upf $output_file
  P_msg_info "Output file: ${output_file}"
  sh ln -fs ${INTEL_DESIGN_NAME}.${step}.upf outputs/${INTEL_DESIGN_NAME}.${output_linkname}.upf
}


proc P_outputs_spef {step} {
  global synopsys_program_name
  global INTEL_DESIGN_NAME
  global output_linkname
  P_outputs_linkname
  if {($synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell")  && [shell_is_in_topographical_mode]} {
    write_parasitics -format distributed -output ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
    if {[file exists ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz]} {
      sh rm ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz
    }
    sh gzip ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
    sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.gz
  } elseif {$synopsys_program_name == "icc_shell"} {
    global INTEL_DESIGN_NAME
    extract_rc -coupling_cap
    set output_file outputs/${INTEL_DESIGN_NAME}.${step}.spef
    write_parasitics -format SPEF -compress -output $output_file
    puts "==>INFORMATION: Output file: ${output_file}.max.gz ${output_file}.min.gz"
    sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.max.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.max.gz
    sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.min.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.min.gz
  } elseif {$synopsys_program_name == "icc2_shell"} {
    if {$step == "fill"} {
      set_parasitic_parameters -corners WORST -late_spec max_mfill_tluplus -early_spec max_mfill_tluplus
      set_parasitic_parameters -corners BEST -late_spec min_mfill_tluplus -early_spec min_mfill_tluplus
      set_extraction_options -real_metalfill_extraction floating
    }
    global INTEL_DESIGN_NAME
    update_timing
    # write_parasitics automatically append .spef file extension.
    set output_file outputs/${INTEL_DESIGN_NAME}.${step}
    write_parasitics -output $output_file
    puts "==>INFORMATION: Output file: $output_file.*.spef"
    foreach f [glob $output_file.*.spef] {
      sh ln -fs [file tail $f] [regsub "\\.$step\\." $f ".$output_linkname."]
    }
  }
}

proc P_outputs_def {step} {
  global INTEL_DESIGN_NAME
  global output_linkname
  global synopsys_program_name
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
  if {($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode]) || $synopsys_program_name == "de_shell" } {
    write_def -output $output_file -placed
    set suffix {}
  } elseif {$synopsys_program_name == "icc_shell" } {
    write_def -compressed -output $output_file
    set suffix .gz
  } elseif {$synopsys_program_name == "icc2_shell" } {
    write_def -exclude {non_mask_purpose fills} -version 5.8 -compress gzip $output_file
    set suffix .gz
  }
  puts "==>INFORMATION: Output file: $output_file$suffix"
  sh ln -fs [file tail $output_file$suffix] [regsub "\\.$step\\." $output_file$suffix ".$output_linkname."]
}

proc P_outputs_techlef {step} {
  global INTEL_DESIGN_NAME
  global output_linkname
  global synopsys_program_name

  P_outputs_linkname
  if {$synopsys_program_name == "icc2_shell"} {
    if { [sizeof_collection [get_blocks [get_attribute -objects [current_block] -name name].frame]] > 0 } {
    # Write out LEF from frame view.
    write_lef -include cell -properties {} ./outputs/$INTEL_DESIGN_NAME.$step.lef
      write_lef -include cell ./outputs/$INTEL_DESIGN_NAME.$step.prop.lef
      write_lef -include tech ./outputs/$INTEL_DESIGN_NAME.$step.tech.lef
      foreach f [glob ./outputs/$INTEL_DESIGN_NAME.$step.*lef] {
        puts "==>INFORMATION: Output file: $f"
        sh ln -fs [file tail $f] [regsub "\\.$step\\." $f ".$output_linkname."]
      }
    } else {
      P_msg_error "Missing '[get_attribute -objects [current_block] -name name].frame' to output LEF!"
    }
  } else {
    set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tech.lef
    set libpath [file dirname [ get_attribute [current_mw_lib] path]]
    set libname [get_attribute [current_mw_lib] name]
    set f_out [open write_lef.tcl "w"]
    puts $f_out "write_lef -output_version 5.5 -lib_name $libpath/$libname -ignore_tech_signal_em -ignore_tech_antenna_rule -ignore_cell_geom $output_file"
    puts $f_out "exit"
    close $f_out
    if {[catch {sh which Milkyway} id] } {
      puts "==>WARNING: Milkyway tool not set, techlef cannot be generated"
    } else {
      exec Milkyway -nullDisplay -nogui -tcl -file ./write_lef.tcl -logd logs/mw -cmdd logs/mw >& /dev/null
    }
    sh rm ./write_lef.tcl
    sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tech.lef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.tech.lef
  }
}

proc P_syn_output_def {step} {
  global INTEL_DESIGN_NAME
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
  write_def -pins -components -output outputs/${INTEL_DESIGN_NAME}.${step}.def
}

proc P_outputs_fp {step} {
  global INTEL_DESIGN_NAME
  global synopsys_program_name

  if {$synopsys_program_name == "icc2_shell"}  {
    write_floorplan -nosplit -force -compress gzip -output outputs/$INTEL_DESIGN_NAME.$step
    puts "==>INFORMATION: Output dir: outputs/$INTEL_DESIGN_NAME.$step"
  } else {
  ### All floorplan contents
    set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tcl
    write_floorplan -all $output_file
    puts "==>INFORMATION: Output file: ${output_file}"

    ### Hard macro placements only
    if {[sizeof_collection [all_macro_cells]] != 0} {
      set output_file outputs/${INTEL_DESIGN_NAME}.${step}.macro_placement.tcl
      write_floorplan -placement { hard_macro }  -no_placement_blockage -no_bound \
        -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary \
        $output_file
      puts "==>INFORMATION: Output file: ${output_file}"
    }

    ### IO placements only
    set output_file outputs/${INTEL_DESIGN_NAME}.${step}.io_placement.tcl
    write_floorplan -placement { terminal }  -no_placement_blockage -no_bound \
      -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary \
      $output_file
    puts "==>INFORMATION: Output file: ${output_file}"
  }
}

proc P_outputs_sdc {step} {
  global INTEL_DESIGN_NAME
  global output_linkname
  global synopsys_program_name

  P_outputs_linkname
  if {$synopsys_program_name == "icc2_shell"}  {
    foreach_in_collection scen [all_scenarios] {
      current_scenario $scen
      set output_file outputs/$INTEL_DESIGN_NAME.$step.[get_object_name [current_corner]].[get_object_name [current_mode]].[get_object_name $scen].sdc
      write_sdc -nosplit -compress gzip -output $output_file
      set suffix .gz
      puts "==>INFORMATION: Output file: $output_file$suffix"
      sh ln -fs [file tail $output_file$suffix] [regsub "\\.$step\\." $output_file$suffix ".$output_linkname."]
    }
    return
  }

  set act_scenarios ""
  if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
    set act_scenarios [all_active_scenarios]
  }
  if { $act_scenarios == ""} {
    set output_file outputs/${INTEL_DESIGN_NAME}.${step}.sdc.orig
    write_sdc -nosplit $output_file
    puts "==>INFORMATION: Output file: ${output_file}"
    if { [file exists $output_file ] } {
      set org_sdc [ open $output_file ]
      set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.sdc w]
      while { [ gets $org_sdc line ] != -1 } {
        if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
          set new_line [concat #$line]
          puts $mod_sdc "$new_line"
        } else {
          puts $mod_sdc "$line"
        }
      }
      close $org_sdc
      close $mod_sdc
    }
    puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.sdc"
    sh ln -fs ${INTEL_DESIGN_NAME}.${step}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.sdc

  } else {
    foreach scenario [all_active_scenarios] {
      set output_file outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc.orig
      write_sdc -nosplit $output_file
      puts "==>INFORMATION: Output file: ${output_file}"

      #Modify SDC for PV usage
      if { [file exists $output_file ] } {
        set org_sdc [ open $output_file ]
        set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc w]
        while { [ gets $org_sdc line ] != -1 } {
          if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
            set new_line [concat #$line]
            puts $mod_sdc "$new_line"
          } else {
            puts $mod_sdc "$line"
          }
        }
        close $org_sdc
        close $mod_sdc
      }
      puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc"
      sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.${scenario}.sdc
    }
  }
}


proc P_outputs_saif {step} {
  global INTEL_DESIGN_NAME
  global INTEL_SAIF
  global synopsys_program_name
  if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
    saif_map -end
    saif_map -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap
    if {[info exists INTEL_SAIF] && $INTEL_SAIF == 1} {
      saif_map -type ptpx -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap.ptpx

    }
    set_vsdc -off
  }
}

proc P_outputs_scandef {step} {
  global INTEL_INSERT_SCAN
  global INTEL_DESIGN_NAME
  global output_linkname
  global synopsys_program_name
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.scandef
  if {[info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN == 1} {
    if {$synopsys_program_name == "icc2_shell"} {
      write_def -include scanchains $output_file
    } else {
      write_scan_def -output $output_file
    }
    puts "==>INFORMATION: Output file: $output_file"
    sh ln -fs [file tail $output_file] [regsub "\\.$step\\." $output_file ".$output_linkname."]
  }
}

proc P_outputs_extraction_nlib {step} {
  global INTEL_DESIGN_NAME
  global INTEL_MW_LIB

  save_lib -version K-2015.06 -as ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_extraction[P_save_extension]
}

proc P_outputs_oas {step} {
  global INTEL_DESIGN_NAME
  global INTEL_GDS_OUT_LAYER_MAP
  global output_linkname
  global synopsys_program_name
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
  if {$synopsys_program_name == "icc2_shell"} {
    set len_prec [get_attribute -objects [get_techs -of_objects [current_lib]] -name length_precision]
    write_oasis -hierarchy all -layer_map $INTEL_GDS_OUT_LAYER_MAP -keep_data_type -units $len_prec -compress 9 -flat_vias $output_file
  } else {
    set_write_stream_options -reset
    set_write_stream_options \
      -map_fill_data \
      -output_first_same_name_cell \
      -skip_global_route_contact \
      -contact_prefix X \
      -child_depth 1000 \
      -output_filling fill \
      -output_outdated_fill \
      -output_pin {text geometry} \
      -keep_data_type \
      -map_layer $INTEL_GDS_OUT_LAYER_MAP \
      -output_instance_name_as_property 112 \
      -max_name_length 128 \
      -output_net text
    write_stream -cells $INTEL_DESIGN_NAME -format oasis $output_file
  }
  puts "==>INFORMATION: Output file: $output_file"
  sh ln -fs [file tail $output_file] [regsub "\\.$step\\." $output_file ".$output_linkname."]
}


#proc P_outputs_oas {step} {
#   global INTEL_DESIGN_NAME
#   global fdk_asic_flows_dir
#
#   if {$step == "fill"} {
#      set output_file outputs/${INTEL_DESIGN_NAME}.apr.oas
#      set gds_file outputs/${INTEL_DESIGN_NAME}.apr.gds.gz
#      echo "Need GDS file to create OAS. Creating GDS..."
#      P_outputs_gds apr
#   } else {
#      set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#      set gds_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#      echo "Need GDS file to create OAS. Creating GDS..."
#      P_outputs_gds $step
#   }
#
#   puts "==>INFORMATION: Generating OAS database using Calibre"
#   set gds2oas_script $fdk_asic_flows_dir/apr/layout_merge_calibre.tcl
#   set status [catch {sh calibredrv -64 $gds2oas_script convert $gds_file $output_file oas} msg]
#   echo "$msg";
#   puts "==>INFORMATION: Generated OAS database"
#}


proc P_outputs_gds {step} {
  global INTEL_DESIGN_NAME
  global INTEL_GDS_OUT_LAYER_MAP
  global output_linkname
  global synopsys_program_name
  P_outputs_linkname
  set output_file outputs/${INTEL_DESIGN_NAME}.${step}.gds
  if {$synopsys_program_name == "icc2_shell"} {
    set len_prec [get_attribute -objects [get_techs -of_objects [current_lib]] -name length_precision]
    write_gds -hierarchy all -layer_map $INTEL_GDS_OUT_LAYER_MAP -keep_data_type -units $len_prec -long_names -compress $output_file
  } else {
    set_write_stream_options -reset
    set_write_stream_options \
      -map_fill_data \
      -child_depth 1000 \
      -output_filling fill \
      -output_outdated_fill \
      -output_pin {text geometry} \
      -keep_data_type \
      -map_layer $INTEL_GDS_OUT_LAYER_MAP \
      -output_instance_name_as_property 112 \
      -max_name_length 128 \
      -output_net text \
      -compressed
    write_stream -cells $INTEL_DESIGN_NAME -format gds $output_file
  }
  set suffix .gz
  puts "==>INFORMATION: Output file: $output_file$suffix"
  sh ln -fs [file tail $output_file$suffix] [regsub "\\.$step\\." $output_file$suffix ".$output_linkname."]
}

proc P_outputs_fram {step} {
  global INTEL_DESIGN_NAME
  global synopsys_program_name

  if {$synopsys_program_name == "icc2_shell"} {
    create_frame -block_all used_layers -merge_metal_blockage true

    # Annotate I/O port antenna properties to frame view.
    set_app_options -name route.detail.antenna -value true
    derive_hier_antenna_property -design_name $INTEL_DESIGN_NAME

    return
  }
}

proc P_outputs_abstract {step} {
  global INTEL_DESIGN_NAME
  puts "==>INFORMATION: Output view: abstract"
  if { [sizeof_collection [get_cells -quiet -physical_context -filter {design_type == module}]] > 0 } {
    set_app_options -name abstract.allow_all_level_abstract -value true
  }
  create_abstract -read_only
  current_block $INTEL_DESIGN_NAME 
}

proc P_outputs_lteloc {step} {
  global INTEL_DESIGN_NAME

  set output_file ./outputs/${INTEL_DESIGN_NAME}.${step}.xyv
  P_create_xyv_icc -step $step
  P_msg_info "Output file: ${output_file}"
}

proc P_outputs {step} {
  global INTEL_DESIGN_NAME INTEL_UPF INTEL_SPG INTEL_INSERT_SCAN INTEL_SCAN_REPLACE_FLOPS
  global INTEL_OUTPUTS
  global INTEL_GDS_OUT_LAYER_MAP
  global output_linkname

  if {[info exists INTEL_OUTPUTS($step)]} {
    set step_name $step
    foreach v $INTEL_OUTPUTS($step) {
    #         puts "==>INFORMATION: Writing an output $v"
      switch -exact -- $v {
        verilog {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_verilog $step_name
        }
        verilog_pg {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_verilog_pg $step_name
        }
        upf {
          if { ![info exists INTEL_UPF] } {
            P_msg_warn "Skip generating output $v because INTEL_UPF var not exist!"
          } elseif { !$INTEL_UPF } {
            P_msg_warn "Skip generating output $v because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
          } else {
            P_msg_info "Generating an output $v"
            P_outputs_upf $step_name
          }
        }
        spef {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_spef $step_name
        }
        def {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_def $step_name
        }
        techlef {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_techlef $step_name
        }
        syn_def {
          if  { [shell_is_in_topographical_mode] && $INTEL_SPG == 1 } {
            puts "==>INFORMATION: Generating an output $v"
            P_syn_output_def $step_name
          } else {
            P_msg_warn "Skip generating def file as spg option is turned off"
          }
        }
        fp {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_fp $step_name
        }
        sdc {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_sdc $step_name
        }
        saif {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_saif $step_name
        }
        layer_constraints {
          report_net_routing_layer_constraints > ./outputs/${INTEL_DESIGN_NAME}.${step}.layer_constraints.txt
        }
        scandef {
          if {$INTEL_SCAN_REPLACE_FLOPS==1 && $INTEL_INSERT_SCAN==1} {
            puts "==>INFORMATION: Generating an output $v"
            P_outputs_scandef $step_name
          } else {
            puts "==>INFORMATION : either INTEL_INSERT_SCAN or INTEL_SCAN_REPLACE_FLOPS are turned off , No scnadef will be generated"
          }
        }
        oas {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_oas $step_name
        }
        extraction_nlib {
          puts "==>INFORMATION: Generating extraction nlib $v"
          P_outputs_extraction_nlib $step_name
        }
        gds {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_gds $step_name
        }
        lteloc {
          puts "==>INFORMATION: Generating an output $v"
          P_outputs_lteloc $step_name
        }
        fram {
          P_msg_info "Generating an output $v"
          P_outputs_fram $step_name
        }
        abstract {
          P_msg_info "Generating an output $v"
          P_outputs_abstract $step_name
        }

        default {
          puts "==>WARNING: The defined output is not configured at $step in the default flow"
        }
      }
    }
  } else {
    puts "==>WARNING: No outputs are defined at $step step in the default flow"
  }
}

##############################################################################
## Define procedure: P_check_place_overlap
## This proc checks for overlapped cells
## Usage: P_check_place_overlap
##############################################################################
proc P_check_place_overlap {} {
  P_msg_info " Checking for cell overlap "
  set legalize_support_phys_only_cell true
  redirect -file ./temp_check_legality_v0.txt {check_legality -verbose}
  #takes care the CTS spacer cells
  sh grep -v "cts_fill" ./temp_check_legality_v0.txt 1> ./temp_check_legality.txt

  #check if no cells overlap ( count the number of lines in the ./temp_overlap.txt )
  set fd [open "./temp_check_legality.txt" "r"]
  set count 0;
  set pattern "overlaps with cell"
  while {[gets $fd line] > -1 } {
    set isMatch [string match *$pattern* $line]
    if { $isMatch != 0 } {
      incr count 1
    }
  }
  close $fd

  echo $count


  if { $count == 0 } {
    P_msg_info " There is no overlapped cells "
  } else {
  #there is some overlap cells, now post process that cells
    sh grep "overlaps with cell" ./temp_check_legality.txt 1> ./temp_overlap.txt
    #create awk script for log file post processing
    set fd [open "./temp_post_process.awk" "w"]
    puts $fd "{ if (NF == 9 || NF == 8)"
    puts $fd "   print \$3;"
    puts $fd " else if (NF == 10) "
    puts $fd "   print \$5;"
    puts $fd "}"
    close $fd
    #run awk script
    sh awk -f ./temp_post_process.awk ./temp_overlap.txt  > ./temp_overlap_cell.txt
    #post-process the overlapped cells
    set list_overlap {}
    set fd [open "./temp_overlap_cell.txt" "r"]
    while {[gets $fd line] > -1} {
    lappend list_overlap $line
    }
    close $fd
    #print cell_type and cell name of overlapped cells
    foreach cell_overlap $list_overlap {
    set cell_name [get_attribute $cell_overlap full_name]
    set cell_type [get_attribute $cell_overlap ref_name]
    P_msg_error "Overlap Cell in place: $cell_type : $cell_name"
    }
    #remove all temporary files
    sh rm ./temp_check_legality_v0.txt
    sh rm ./temp_check_legality.txt
    sh rm ./temp_overlap.txt
    sh rm ./temp_overlap_cell.txt
    sh rm ./temp_post_process.awk
  }
  P_msg_info " Done: Checking for cell overlap "
}

##################################################################
# Procedure   : P_check_cells
# Description : This proc checks if specified cells are used in the list of instances.
#               when given a list of reference cell names and a list of instances,
#               if the instance cell matches any cell in the reference cell list,
#               it flags it as a warning or error depending on the flag.
# Usage: P_check_cells <ref_list> <inst_list> <msg> <flag>
# Example: P_check_cells $ref_list $inst_list $msg $flag
# $ref_list : list of cells to check
# $inst_list : collection of instance to check
# $msg: message prefix
# $flag: indicates to print as warning or error (P_msg_warn or P_msg_err)
###################################################################

proc P_check_cells {ref_list inst_list msg flag} {
  P_msg_info "Checking cells in the design..."
  #collection of instances to check
  set coll_of_insts $inst_list
  #flag message depending on the flag value: Error or Warning
  if { $flag == "err" } {
    set flag_local "P_msg_error"
  } elseif { $flag == "warn" } {
    set flag_local "P_msg_warn"
  } else {
    set flag_local "P_msg_info"
  }
  set dont_use_list [list]

  foreach cell $ref_list {
    if {$cell ne ""} {
      set pattern "(ref_name=~[join $cell {) || (ref_name =~} ])"
      lappend dont_use_list $pattern
    }
  }
  set dont_use_expr [join $dont_use_list || ]
  set ic_cntr  0
  foreach_in_collection c [get_cells $inst_list -filter "is_hierarchical==false && $dont_use_expr"  -quiet] {
    set c_name [get_attribute $c full_name]
    $flag_local "$c_name is a $msg [get_attribute $c ref_name]"
    incr ic_cntr
  }

  if {!$ic_cntr} {
    P_msg_info "No dont_use cells found in your design"
  } else {
    $flag_local "$ic_cntr dont_use cells found in your design"
  }

  P_msg_info "Done: Checking cells in the design..."
}

define_proc_attributes P_check_cells \
  -info "Procedure to check if ref cells are used in the list of instances"


###########################################################################################
# check if there are any shorts or opens or floating on power/ground nets
# The script parse the verify_lvs reports
# if there are any shorts/opens/floatings on PG, this script will issue an error message
# if user see error message, user may look more detail on the verify_lvs reports
###########################################################################################

proc P_check_power_ground_nets {} {
  P_msg_info "Check if there are any shorts or opens on power/ground nets"

  #set DEBUG 1
  set DEBUG 0
  global INTEL_POWER_NET INTEL_GROUND_NET

  set icc_pg_nets "$INTEL_GROUND_NET $INTEL_POWER_NET"
  redirect -file ./temp_verify_lvs_pg.txt {verify_lvs  -nets $icc_pg_nets -check_short_locator -check_open_locator}

  set fd [open "./temp_verify_lvs_pg.txt" "r"]
  set err_count 0; set war_count 0;
  set pattern1 "Total Floating Nets are 1"
  set pattern2 "Total Floating Nets are 2"
  set pattern3 "Total SHORT Nets are 1"
  set pattern4 "Total SHORT Nets are 2"
  set pattern5 "Total OPEN Nets are 1"
  set pattern6 "Total OPEN Nets are 2"

  while {[gets $fd line] > -1} {
    set isMatch1 [string match *$pattern1* $line]
    set isMatch2 [string match *$pattern2* $line]
    set isMatch3 [string match *$pattern3* $line]
    set isMatch4 [string match *$pattern4* $line]
    set isMatch5 [string match *$pattern5* $line]
    set isMatch6 [string match *$pattern5* $line]
    set errMatch [expr $isMatch3 || $isMatch4 || $isMatch5 || $isMatch6]
    set warMatch [expr $isMatch1 || $isMatch2]
    if { $errMatch != 0 } {
      incr err_count 1;
    }
    if { $warMatch != 0 } {
      incr war_count 1;
    }
  }
  close $fd

  if {$DEBUG} {puts $err_count}

  if { $err_count > 0 } {
    P_msg_error " Power/Ground net has short/open\n \
      Please review the verify_lvs reports for more information"
  }
  if { $war_count > 0 } {
    P_msg_warn " Power/Ground net has floating\n \
      Please review the verify_lvs reports for more information"
  }

  #unset temporary variables
  unset -nocomplain pattern1 pattern2 pattern3 pattern4 pattern5 pattern6 isMatch1 isMatch2 isMatch4 isMatch5 isMatch6 anyMatch count icc_pg_nets fd
  #remove all temporary files
  sh rm ./temp_verify_lvs_pg.txt
  P_msg_info "Done: Check if there are any shorts or opens on power/ground nets"

}


##########################################
# Gather track data to be used for port width checks 
##########################################
proc P_gather_track_data {} {
  global INTEL_METAL_LAYERS tracks; catch {unset tracks};
  #MU  scan [get_attr [get_die_area] bbox] {{%f %f} {%f %f}} _lx _ly _ux _uy
  scan [get_attr [current_block] boundary_bbox] {{%f %f} {%f %f}} _lx _ly _ux _uy

  #gather track data
  foreach layer $INTEL_METAL_LAYERS { echo "$layer";
                                      redirect -variable tracks_tmp {report_track -layer $layer -dir [P_get_layer_dir $layer]}
                                      set tracks_tmp [split $tracks_tmp "\n"]
                                      set cnt 1; #use as track counter
                                      if {[P_get_layer_dir $layer]==Y} {set DS $_uy} else {set DS $_ux}
                                      foreach line $tracks_tmp {
                                        if {[regexp {^m} $line]} {
                                          regsub -all {\}\{} $line "" line;
                                          regexp {^(m[0-9]+)\s+\S\s+(\S+)\s+\S+\s+(\S+)\s+\S+,\s*width=([0-9]*\.?[0-9]+)(,\S+)?} $line match lay loc pitch width ju
                                          for {set k 0} {$k<=[expr round([expr $DS/$pitch])]} {incr k} {
                                            dict set tracks $lay $cnt coord [expr $loc+($k*$pitch)]
                                            dict set tracks $lay $cnt pitch $pitch
                                            dict set tracks $lay $cnt width $width
                                            incr cnt
                                          }
                                          #incr cnt
                                        }
                                      }
  }
}

#######################################
#Get layer direction
#######################################
proc P_get_layer_dir {layer} {
  set dir [get_attribute [get_layers $layer] routing_direction]
  if {$dir eq "horizontal"} {
    return "Y"
  } else {
    return "X"
  }
}

############################################################
# Query track widths. Given layer and coordinate, proc returns
# width associated with that layer on that track
############################################################
proc P_query_track_width {layer coord} {
  global INTEL_tracks
  for {set i 1} {$i<=[dict size [dict get $INTEL_tracks $layer]]} {incr i} {
    echo $i
    if {[expr [dict get $INTEL_tracks $layer $i coord]]==$coord} {
      return "[format {%0.3f} [dict get $INTEL_tracks $layer $i width]]"
    }
  }
  return "mismatch"
}

#######################################
# Create AABB region for M2
#######################################
proc P_create_aabb_region {} {
  set layer_number 112
  set datatype 20
  set layer m2AABBRegionID
  set x_bloat 0.162
  set y_bloat 0.000

  P_msg_info "Removing existing AABB region ID"
  if {[get_shapes -quiet -filter "layer_name==$layer"] != "" } {
    remove_objects [get_shapes -quiet -filter "layer_name==$layer"]
  }
  P_msg_info "Creating AABB Region IDs layer:dt - ${layer_number}:${datatype}"

  set die [get_attribute -quiet [get_core_area] boundary]

  set m [get_cells -quiet -hier -filter "is_hard_macro==true || is_soft_macro==true"]
  #append_to_collection m [get_cells -hier -quiet *halo* ]
  append_to_collection m [remove_from_collection [get_cells -hier -quiet *halo* ] [get_cells -hier -quiet *halo_va*]]

  if {$m != ""} {
    set core [compute_polygons -operation not -objects1 $die -objects2 $m]
  } else {
    set core $die
  }

  set core [resize_polygon -size "$x_bloat $y_bloat" -objects $core]
  create_shape -shape_type poly -boundary [get_attribute $core poly_rects.point_list] -layer ${layer}:${datatype}

}

###########################################################
# Proc to remove via ladders inserted over cells in domain
###########################################################
proc P_remove_via_ladders {cells {tag "_sec_hookup_"}} {
  global INTEL_UPF_POWER_NETS
  if {[sizeof_collection $cells]==0} {P_msg_info "No cells specified"; return 0}
  foreach_in_collection cell $cells {
    set v 0;set s 0;set pg 0;
    set cell_name [get_object_name $cell]
    set domain [get_object_name [get_power_domain -of_objects $cell]]
    set aon_pwr [P_ret_aon_net -pwr_domain $domain]
    # Get the flat net name for hier designs
    if { [llength [split $aon_pwr "/"]] > 0 } {
      if { [lsearch $INTEL_UPF_POWER_NETS [lindex [split $aon_pwr "/"] end]] > -1 } {
        set aon_pwr [lindex [split $aon_pwr "/"] end]
      }
    }
    set bbox [list [get_attribute $cell bbox]]
    set _vias [get_objects_by_location -class via -within $bbox -filter {is_via_ladder==true} -quiet]
    set _net_shp [get_objects_by_location -class shape -within $bbox -filter {is_via_ladder==true} -quiet]
    set _pg_via [get_objects_by_location -class via -within $bbox -filter ${tag}==true -quiet]
    append_to_collection _vias [get_objects_by_location -class via -intersect $bbox -filter {is_via_ladder==true} -quiet]
    append_to_collection _net_shp [get_objects_by_location -class shape -intersect $bbox -filter {is_via_ladder==true} -quiet]
    if { [sizeof_collection $_vias]>0} {remove_via $_vias;set v 1}
    if { [sizeof_collection $_net_shp]>0} {remove_shapes $_net_shp; set s 1}
    if { [sizeof_collection $_pg_via]>0} {remove_via $_pg_via; set pg 1}
    if {$v==1 && $s==1 && $pg==1} {
      P_msg_info "Removed ladder connections over $cell_name"
    } elseif {$v==1 && $s==1 && $pg==0} {
      P_msg_info "Removed ladder shapes and vias over ${cell_name}. No preroute via found"
    } else {
      P_msg_info "No shapes to remove over $cell_name";
    }
  }
}

###########################################################
# Proc to check if cells have via ladders and re-insert them if they are missing
###########################################################
proc P_check_and_insert_ladders {args} {
  foreach glbl [info globals INTEL_*] {global $glbl}
  parse_proc_arguments -args $args inputs

  #Get cells to insert/check ladders/PRVs over
  if {[info exists inputs(-cells)]} {
    set cells [get_cells $inputs(-cells)]
  } else {
    P_msg_info "No cells specified. Skipping..."
    return
  }

  #initialize check vars
  set prv 1
  set ladd 1
  #Check if only PRV existence/insertion is needed
  if {[info exists inputs(-prv_connect)]} {set ladd 0; set prv 1}
  #check if only ladder insertion is to be done 
  if {[info exists inputs(-ladder_only)]} {set ladd 1; set prv 0}

  #check for PRV tag
  set tag "_sec_hookup_"
  if {[info exists inputs(-tag)]} {set tag $inputs(-tag)}

  P_msg_info "Number of cells to check for ladders/prv [sizeof_coll $cells]"
  if {[sizeof_collection [get_cells -hier -filter {is_placed==false} -quiet]]>0} {
    P_msg_info "Cells not placed, cannot insert ladders. Please place cells before inserting via ladders"
    return
  }

  set reinsert_ladders ""
  set reinsert_prv ""
  foreach_in_collection cell $cells {
    set cell_name [get_object_name $cell]
    set bbox [get_attr $cell bbox]
    set _vias ""; 
    set _pg_vias "";
    set _vias [get_objects_by_location -class via -within $bbox -filter {is_via_ladder==true} -quiet]
    set _pg_via [get_objects_by_location -class via -within $bbox -filter ${tag}==true -quiet]
    if {[sizeof_collection $_pg_via]>0} {
      P_msg_info "PG connection exists over $cell_name. Please run P_remove_via_ladder on cell before inserting"
      continue
    } else {
      append_to_collection reinsert_prv $cell
    }
    if {[sizeof_collection $_vias]==0} {
      append_to_collection reinsert_ladders $cell
    }
  }

  if {$ladd && ([sizeof_collection $reinsert_ladders]>0)} {
    P_msg_info "Found cells with missing ladders -"
    foreach_in_collection cell $reinsert_ladders {
      P_msg_info "[get_object_name $cell] missing via ladder!"
    }
    P_msg_info "Retry inserting ladders"
    insert_via_ladders -verbose true -clean false -allow_drc true -allow_patching true
  } elseif {$ladd && ([sizeof_coll $reinsert_ladders]==0)} {
  #foreach_in_collection cell $cells {
    P_msg_info "No missing via ladders found"
    #}
  }

  set cell_list ""
  array set prv_arr {}
  if {$prv && $ladd} { 
    append_to_collection -unique cell_list $reinsert_ladders 
    append_to_collection -unique cell_list $reinsert_prv
  } elseif {$prv && !$ladd} {
    append_to_collection -unique cell_list $reinsert_prv
  }

  foreach_in_collection cell $cell_list {
    set cell_name [get_object_name [get_cells $cell]]
    set domain [get_object_name [get_power_domain -of_objects $cell]]
    set aon_pwr [P_ret_aon_net -pwr_domain $domain]
    # Get the flat net name for hier designs
    if { [llength [split $aon_pwr "/"]] > 0 } {
      if { [lsearch $INTEL_UPF_POWER_NETS [lindex [split $aon_pwr "/"] end]] > -1 } {
        set aon_pwr [lindex [split $aon_pwr "/"] end]
      }
    }
    set bbox [list [get_attribute [get_cells $cell] bbox]]
    set _vias [get_objects_by_location -class via -within $bbox -filter {is_via_ladder==true} -quiet]
    set _net_shp [get_objects_by_location -class shape -within $bbox -filter {is_via_ladder==true} -quiet]
    #set _pg_via [get_vias -touching $bbox -filter ${tag}==true -quiet]
    append_to_collection _vias [get_objects_by_location -class via -intersect  $bbox -filter {is_via_ladder==true} -quiet]
    append_to_collection _net_shp [get_objects_by_location -class shape -intersect $bbox -filter {is_via_ladder==true} -quiet]
    #check if ladders were inserted before inserting preroute vias
    if {[sizeof_collection $_net_shp]==0} {P_msg_info "No via ladder exists for $cell_name. Cannot insert prv"; continue}
    set _top [lindex [lsort -decreasing -unique -dictionary [get_attr $_net_shp layer.name]] 0]
    set n [string map {m ""} $_top]
    #P1222.8 use m4 and m5 for PG via connection
    set ulayer m[expr $n+1]
    set llayer m$n
    set prv_arr($llayer,$ulayer,$domain,$aon_pwr,$tag) "1"
  }

  foreach elem [array names prv_arr] {
    lassign [split $elem ","] llayer ulayer domain aon_pwr tag
    ## Get bbox of voltage area for use in create_pg_vias
    set domain_bbox [list [get_attribute [get_voltage_area_shapes -of_objects [get_power_domain  $domain]] bbox]]
    set domain_bndry [list [get_attribute [get_voltage_area_shapes -of_objects $domain] boundary]]
    echo create_pg_vias -from_layers $ulayer -to_layers $llayer -from_types strap -within_bbox $domain_bbox -nets $aon_pwr -mark_as_stripe
    set cmd "create_pg_vias -from_layers $ulayer -to_layers $llayer -from_types strap -within_bbox $domain_bbox -nets $aon_pwr -mark_as stripe"

    set wrk_arnd 1
    set _pr_via_existing ""
    set _pr_via_existing [get_objects_by_location -class via -within $domain_bndry -filter "cut_layer_names==v${n} && shape_use==stripe"]
    set status [eval $cmd]
    if {$status} {
      if {$wrk_arnd} { 
        set _pr_via_added [remove_from_collection \
          [get_objects_by_location -class via -within $domain_bndry -filter "cut_layer_names==v${n} && shape_use==stripe"] \
          $_pr_via_existing]
        set_attribute -objects $_pr_via_added -name $tag -value true

      }
      P_msg_info "Connected $cell_name ladder to PG grid"
    } else {
      P_msg_info "Unable to connect ladder to PG Grid for $cell_name. Please check"
    }
  }
}

define_proc_attributes P_check_and_insert_ladders \
  -info "Checks and inserts missing ladders over cells" \
  -define_args {
    {"-prv_connect" "Checks and inserts preroute vias for specified cells if ladders exists but no PRV" "" boolean optional}
    {"-ladder_only" "Executes only via ladder insertion command" "" boolean optional}
    {"-tag" "Tag applied for PRV check and insertion" "" string optional}
    {"-cells" "Collection of cells over which ladder existence is to be checked and ladder insertion done if missing" "" string required}
}

proc P_merge_m6 {args} {
  foreach glbl [info globals INTEL_*] {global $glbl}
  parse_proc_arguments -args $args inputs

  if {[info exists inputs(-cells)]} {
    set cells [get_cells $inputs(-cells)]
  } else {
    P_msg_info "No cells specified. Skipping..."
    return
  }

  foreach_in_collection ps_cell $cells {
    echo "PROCESSING [get_object_name $ps_cell]"

    # get the m6 VL segments
    set bbox [get_attribute $ps_cell boundary_bbox]
    set m6_seg [get_shapes -within $bbox -filter "layer.name==m6 && shape_use==user_route"]
    echo "get_shapes -within $bbox -filter layer.name==m6 && shape_use==user_route [sizeof_collection $m6_seg]"
    if {[sizeof_collection $m6_seg] > 0} {
      merge_object $m6_seg
    }
  
    set m6_seg [get_shapes -within $bbox -filter "layer.name==m6 && shape_use==user_route"]
      foreach_in_collection seg $m6_seg {
      set onepoints [get_attr $seg points]   
      set x1 [lindex $onepoints 0 0]
      set y1 [lindex $onepoints 0 1]    
      set x2 [lindex $onepoints 1 0]
      set y2 [lindex $onepoints 1 1]    
      set x1_1 [expr $x1 - 0.270]
      set x2_1 [expr $x2 + 0.270]
      set  lbox "{$x1_1 $y1} {$x2_1 $y2}"
      set_attribute $seg points "$lbox"
      }

  }
}
define_proc_attributes P_merge_m6 \
  -info "Merge m6 shapes" \
  -define_args {
    {"-cells" "Collection of cells over which ladder existence is to be checked and ladder insertion done if missing" "" string required}
}

########################################
# Procedure : report_lib_cell_purpose

if { [info commands report_lib_cell_purpose] == {} } {
  proc report_lib_cell_purpose args {
    parse_proc_arguments -args $args opts
    set proc_name [namespace tail [lindex [info level 0] 0]]
    if { [info exists opts(-lib_cells)] } {
      if { [string match _sel* $opts(-lib_cells)] } {
        if { [set obj_class [lsort -unique [get_attribute -objects $opts(-lib_cells) -name object_class]]] != {lib_cell} } {
          error "$proc_name: Invalid object class '$obj_class' of collection '[get_object_name $opts(-lib_cells)]' for -lib_cells option!  Expect 'lib_cell' object class only!"
        } else {
          set lib_cells $opts(-lib_cells)
        }
      } else {
        set lib_cells {}
        foreach lib_cell_name $opts(-lib_cells) {
          set lcells [get_lib_cells -quiet $lib_cell_name]
          if { [sizeof_collection $lcells] == 0 } {
            error "$proc_name: Failed to find any lib cell matching name '$lib_cell_name' by -lib_cells option in design!"
          } else {
            append_to_collection -unique lib_cells $lcells
          }
        }
      }
    } else {
      set lib_cells [sort_collection -dictionary [get_lib_cells -quiet */*] full_name]
    }
    set col_fmt {%-48s %-12s %-12s %-26s %-30s %-30s}
    echo [format $col_fmt {Lib cell} dont_touch dont_use included_purposes excluded_purposes valid_purposes]
    echo [format $col_fmt  --------  ---------- -------- ----------------- ----------------- --------------]
    set_message_info -id ATTR-11 -limit 1
    set lib_cell_num 0
    foreach_in_collection lib_cell $lib_cells {
      incr lib_cell_num
      set line_txt [get_object_name $lib_cell]
      foreach attr {dont_touch dont_use included_purposes excluded_purposes valid_purposes} {
        lappend line_txt [list [get_attribute -quiet -objects $lib_cell -name $attr]]
      }
      echo [format $col_fmt {*}$line_txt]
    }
    echo "Total $lib_cell_num lib cells."
    set_message_info -id ATTR-11 -limit 0
  }

  define_proc_attributes report_lib_cell_purpose \
    -info "Report purpose related attributes (dont_touch, dont_use & *_purposes) of lib cells set by set_lib_cell_purpose." \
    -define_args {
      {-lib_cells "Lib cells to report purpose related attributes. Default: All lib cells" list_or_collection list optional}
  }
}

proc P_create_fill_kor {} {
  global INTEL_MAX_ROUTING_LAYER
  set datatype 93
  set layer_name_postfix "_fill_kor"
  set x_bloat 0.000
  set y_bloat 0.000

  set all_layers  [get_attribute [get_layers -filter "layer_type==interconnect"] name]
  set layer_index [lsearch [get_attribute [get_layers -filter "layer_type==interconnect"] name] $INTEL_MAX_ROUTING_LAYER]
  set fill_kor_layers [lreplace $all_layers [expr $layer_index +1] [llength $all_layers]]
  P_msg_info "Creating m*_fill_kor on layers: $fill_kor_layers"

  foreach metal_layer $fill_kor_layers {
     set layer ${metal_layer}${layer_name_postfix}
  
     if {[get_shapes -quiet -filter "layer_name==$layer"] != "" } {
        P_msg_info "Removing existing $layer layer"     
        remove_objects [get_shapes -quiet -filter "layer_name==$layer"]
     }
     P_msg_info "Creating fill kor - $layer"

     set die [get_attribute -quiet [get_core_area] boundary]
     set m ""
     #set m [get_cells -quiet -hier -filter "is_hard_macro==true || is_soft_macro==true"]
     #append_to_collection m [remove_from_collection [get_cells -hier -quiet *halo* ] [get_cells -hier -quiet *halo_va*]]

     if {$m != ""} {
       set core [compute_polygons -operation not -objects1 $die -objects2 $m]
     } else {
       set core $die
     }

     set core [resize_polygon -size "$x_bloat $y_bloat" -objects $core]
     create_shape -shape_type poly -boundary [get_attribute $core poly_rects.point_list] -layer ${layer}:${datatype}
  }
}

proc P_create_fill_nlib {fill_oas {nlib_name ""}} {
  global INTEL_DESIGN_NAME INTEL_GDS_OUT_LAYER_MAP sh_product_version
  global INTEL_MW_LIB

  if { ![file exists $fill_oas]} {
    P_msg_error "Invalid fill oasis file being specified. Please check the existance of $fill_oas"
    return
  }

  if {$sh_product_version < "L-2016.03-SP3"} {
    P_msg_error "Need 2016.03-SP3 or later ICC2 tool version for this to work."
    return
  }

  P_msg_info "Will create fill nlib, write out fill kor and generation fill outputs"

  # construct fill ndm and write out fill outputs
  # assumption is that you already have fill oas being written out

  if {[sizeof_collection [current_lib -quiet]] > 0} {
    close_lib
  }

  sh rm -rf ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_fill.nlib
  if {$nlib_name eq ""} {
    if {[file exists ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_post_route.nlib]} {
      copy_lib -from_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_post_route.nlib -to_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_fill.nlib
    } else {
      copy_lib -from_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_upf_post_route.nlib -to_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_fill.nlib
    }
  } else {
    copy_lib -from_lib ${INTEL_MW_LIB}/$nlib_name -to_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_fill.nlib
  }

  open_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_fill.nlib
  open_block ${INTEL_DESIGN_NAME}
   
  read_fill_from_stream -layer_map $INTEL_GDS_OUT_LAYER_MAP -layer_map_format icc2 -oasis $fill_oas
  P_outputs fill
  open_block ${INTEL_DESIGN_NAME}.frame
  P_create_fill_kor
  save_block ${INTEL_DESIGN_NAME}.frame
  close_block
  save_lib

  close_lib
  P_msg_info "Fill nlib was created and fill outputs were generated"
}


proc P_create_fill_label {fill_oas} {
  global INTEL_DESIGN_NAME INTEL_GDS_OUT_LAYER_MAP sh_product_version

  if { ![file exists $fill_oas]} {
    P_msg_error "Invalid fill oasis file being specified. Please check the existance of $fill_oas"
    return
  }

  if {$sh_product_version < "L-2016.03-SP3"} {
    P_msg_error "Need 2016.03-SP3 or later ICC2 tool version for this to work."
    return
  }

  P_msg_info "Will create fill label, write out fill kor and generation fill outputs"

  # construct fill ndm and write out fill outputs
  # assumption is that you already have fill oas being written out

  if {[sizeof_collection [current_lib -quiet]] == 0} {
    open_lib ${INTEL_DESIGN_NAME}.nlib
  }

  #if {[sizeof_collection [get_blocks -quiet ${INTEL_DESIGN_NAME}]] > 0} {
  #  redirect /dev/null {remove_blocks -force ${INTEL_DESIGN_NAME}}
  #}
  #copy_block -from_block ${INTEL_DESIGN_NAME}/route -to_block ${INTEL_DESIGN_NAME}
  if {[sizeof_collection [current_block -quiet]] == 0} {
    open_block ${INTEL_DESIGN_NAME}
  }
   
  read_fill_from_stream -layer_map $INTEL_GDS_OUT_LAYER_MAP -layer_map_format icc2 -oasis $fill_oas
  save_block -label fill

  # Write out Verilog LVS netlist & OASIS polygon.
  write_verilog -exclude {scalar_wire_declarations leaf_module_declarations supply_statements} -compress gzip ./outputs/$INTEL_DESIGN_NAME.vg
  set len_prec [get_attribute -objects [get_techs -of_objects [current_lib]] -name length_precision]
  write_oasis -hierarchy all -layer_map $INTEL_GDS_OUT_LAYER_MAP -keep_data_type -units $len_prec -compress 9 ./outputs/$INTEL_DESIGN_NAME.oas

  # Write out SDC constraints for all scenarios.
  foreach_in_collection scen [all_scenarios] {
    current_scenario $scen
    write_sdc -nosplit -compress gzip -output ./outputs/$INTEL_DESIGN_NAME.[get_object_name [current_corner]].[get_object_name [current_mode]].[get_object_name $scen].sdc
  }

  # Write out SPEF parasitics.
  update_timing
  # write_parasitics automatically append .spef file extension.
  set_parasitic_parameters -corners WORST -late_spec max_mfill_tluplus -early_spec max_mfill_tluplus
  set_parasitic_parameters -corners BEST -late_spec min_mfill_tluplus -early_spec min_mfill_tluplus
  set_extraction_options -real_metalfill_extraction floating
  write_parasitics -output ./outputs/$INTEL_DESIGN_NAME

  # Write out DEF layout.
  write_def -compress gzip ./outputs/$INTEL_DESIGN_NAME.def
  #write_def -version 5.8 -compress gzip ./outputs/$INTEL_DESIGN_NAME.def

  open_block ${INTEL_DESIGN_NAME}.frame
  P_create_fill_kor
  save_block ${INTEL_DESIGN_NAME}.frame

  current_block $INTEL_DESIGN_NAME
  # Write out LEF from frame view.
  write_lef -include cell ./outputs/$INTEL_DESIGN_NAME.lef
  write_lef -include tech ./outputs/tech.lef
  
  ###
  # Create abstract view.
  if { [sizeof_collection [get_cells -quiet -physical_context -filter {design_type == module}]] > 0 } {
    set_app_options -name abstract.allow_all_level_abstract -value true
  } 
  #set_app_options -name abstract.annotate_power -value true
  #set_app_options -name abstract.enable_signal_em_analysis -value true
  create_abstract -read_only

  save_block -label fill

  close_lib
  P_msg_info "Fill label was created and fill outputs were generated"
}
proc P_add_sec_pg_hookup { args } {

  foreach glbl [info globals INTEL_*] {global $glbl}
  parse_proc_arguments -args $args inputs

  if {[info exists inputs(-cells)]} {
    set connect_cell_list [get_cells $inputs(-cells) -quiet]

  } else {
    P_msg_info "No cells specified using -cells switch. Performing secondary PG connection for  all existing ISO/AON/LS cells."

    set iso_cells [get_cells -physical_context -filter "is_isolation==true" -quiet]
    set ls_cells [get_cells -physical_context -filter "is_level_shifter==true" -quiet]

    foreach aon [lsort -unique [get_attribute [get_lib_cells */* -filter "always_on == true"] full_name]] {
      lappend aon_stdcells [string range $aon 0 8]
    }

    set aon_filter_pattern "(ref_name=~[join [lsort -unique $aon_stdcells] {*) || (ref_name =~} ]*)"
    set aon_cells [get_cells -physical_context -filter $aon_filter_pattern -quiet]

    foreach ret_flop [lsort -unique [get_attribute [get_lib_cells */* -filter "is_retention == true"] full_name]] {
      lappend ret_flop_stdcells [string range $ret_flop 0 8]
    }
    set ret_filter_pattern "(ref_name=~[join [lsort -unique $ret_flop_stdcells] {*) || (ref_name =~} ]*)"
    set ret_flop_cells [get_flat_cells -filter $ret_filter_pattern -quiet]   

    set connect_cell_list [add_to_collection $iso_cells $aon_cells]
    set connect_cell_list [add_to_collection $connect_cell_list $ls_cells]
    set connect_cell_list [add_to_collection $connect_cell_list $ret_flop_cells]
  }

  if {[sizeof_collection $connect_cell_list] == 0} {
    P_msg_info "No cells found/specified to connect secondary PG. Skipping..."
    return
  }

  if {[info exists inputs(-remove)]} {
    set remove 1
    P_msg_info "Removing existing secondary PG connection of isolation,  always-on and level-shifter cells"
    P_remove_sec_pg_hookup -cells $connect_cell_list
    return -1
  } else {
    set remove 0
  }

  if {[sizeof_collection $connect_cell_list] > 0} { 
    set_attribute $connect_cell_list is_fixed true -quiet
  }
  #define user attribute on via
  define_user_attribute -class via -type boolean _sec_hookup_ -persistent

  catch {unset tmp}
  set rm_col ""
  array set tmp {}

  if {[sizeof_collection $connect_cell_list] != 0} { 
    foreach_in_collection cell $connect_cell_list {
      set cell_name [get_object_name $cell]
      set num_vcc_pins [sizeof_collection [get_pins -of_objects $cell -filter "name =~ *vcc*" -physical_context -quiet]]
      if {$num_vcc_pins >= 2} {
        #set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *backup* && pin_type !~ *inout*" -physical_context -quiet]
        set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *primary* && name==vcc_in" -physical_context -quiet]
	if {[sizeof_collection $sec_pg_pins] == 0} {
	  set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *backup*" -physical_context -quiet]
	}
      } else {
        set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *backup*" -physical_context -quiet]
      }

      if {[sizeof_collection $sec_pg_pins] == 0} {
        P_msg_warn "Cell $cell_name does not have a secondary PG pin"
        append_to_collection rm_col $cell
        continue
      }
      set domain_name [get_object_name [get_power_domains -of_objects [get_cell $cell]]]
      set va_area [get_object_name [get_voltage_areas -of_objects [get_cell $cell]]]
      set aon_pwr [get_object_name [get_nets -of_objects $sec_pg_pins]]
      if { [llength [split $aon_pwr "/"]] > 0 } {
        if { [lsearch $INTEL_UPF_POWER_NETS [lindex [split $aon_pwr "/"] end]] > -1 } {
          set aon_pwr [lindex [split $aon_pwr "/"] end]
        }
      }
      set tmp($va_area) $aon_pwr
    }

    set connect_cell_list [remove_from_collection $connect_cell_list $rm_col]

    if {[sizeof_collection $connect_cell_list]==0} {
      P_msg_info "No cells found that require secondary PG hookup"
      return
    }

    if {[info exists INTEL_SEC_PG] && $INTEL_SEC_PG !=""} {
      set via_ladder $INTEL_SEC_PG
    } else {
      P_msg_warn "No via ladder definition for Secondary PG exists. Please check and define INTEL_SEC_PG var!"
      return
    }

    ##  set_via_ladder_constraints -pins [get_pins -of $connect_cell_list -filter "name=~*/vcc_in"] $via_ladder
    foreach_in_collection c [list $connect_cell_list] {
    set cn [get_object_name $c]
    set pn $cn/vcc_in
    set_via_ladder_constraints -pins $pn $via_ladder
  }
  ##  insert_zrt_via_ladders -verbose true -clean false -allow_drc true -allow_patching true
  insert_via_ladders -verbose true -clean false -allow_drc true -allow_patching true -ignore_rippable_shapes true
}
}


define_proc_attributes P_add_sec_pg_hookup \
  -info "Connects AON power to standard cells" \
  -define_args {
    {"-remove"  "Removes the connection of the specified cells" "" boolean optional}
    {"-cells"  "Use to specify individual cells, otherwise operation is performed on all cells" "" string optional}
}

proc P_remove_sec_pg_hookup {args} {
  parse_proc_arguments -args $args inputs

  set cell_list [get_cells $inputs(-cells)]
  foreach_in_collection cell $cell_list {
    set cell_name [get_object_name $cell]
    set num_vcc_pins [sizeof_collection [get_pins -of_objects $cell -filter "name =~ *vcc*" -physical_context -quiet]]
    if {$num_vcc_pins >= 2} {
      #set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *backup* && pin_type !~ *inout*" -physical_context -quiet]
      set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *primary* && name==vcc_in" -physical_context -quiet]
      if {[sizeof_collection $sec_pg_pins] == 0} {
        set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *backup*" -physical_context -quiet]
      }
    } else {
      set sec_pg_pins [get_pins -of_objects $cell -filter "pg_type =~ *backup*" -physical_context -quiet]
    }

    if {[sizeof_collection $sec_pg_pins] == 0} {
      P_msg_warn "Cell $cell_name does not have a secondary PG pin"
      continue
    } 
    P_remove_via_ladders -cells $cell -tag _sec_hookup_
  }
}

define_proc_attributes P_remove_sec_pg_hookup \
  -info "Remove secondary PG power hookup to standard cells" \
  -define_args {
    {"-cells" "Specify cells for which sec PG hookup should be removed" "" string required}
}

## -----------------------------------------------------------------------------
## End Of File
## -----------------------------------------------------------------------------

puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"



